{"meta":{"title":"Lomo Space","subtitle":"The unexamined life is not worth living.","description":"Do More, Say Less","author":"Lomo","url":"http://lomo.space","root":"/"},"pages":[{"title":"","date":"2022-01-14T11:40:22.893Z","updated":"2022-01-14T11:40:22.893Z","comments":true,"path":"tech/index.html","permalink":"http://lomo.space/tech/index.html","excerpt":"","text":""},{"title":"","date":"2022-01-14T11:40:22.869Z","updated":"2022-01-14T11:40:22.869Z","comments":true,"path":"404.html","permalink":"http://lomo.space/404.html","excerpt":"","text":"Lomo Space"},{"title":"About Me","date":"2014-12-20T16:10:01.000Z","updated":"2022-04-17T04:54:52.116Z","comments":true,"path":"about/index.html","permalink":"http://lomo.space/about/index.html","excerpt":"","text":"About Lomo↔️座右铭↔️「你的水平决定了你遇见的人的水平」 &amp;nbsp;&amp;nbsp;&amp;nbsp;你自己都不够好，你凭什么要求你遇见的人怎样！ 「你现在的气质里，藏着你走过的路，读过的书和爱过的人」 「真正牛逼的，不是那些可以随口拿来夸耀的事迹，而是那些在困境中依然保持微笑的凡人」 ![book](/img/book.jpeg \"书\") 📚书读书: 读书这件小事 对于我这种从小就是假好学生又爱看看书的人来说, 是从来都不会放下的. 小说: 《追风筝的人》、《偷影子的人》、《灿烂千阳》、《一个人的朝圣》、《巴别塔之犬》、《我以为你死了》、《我在雨中等你》、《乔布斯管理日志》、《乔布斯内部信件》，《明朝那些事儿》、《蹉跎坡旧事》、《匆匆那年》、《站在两个世界的边缘》、《他们最幸福》、《平凡的世界》、《没有梦想 何必远方》… … 名著？: 《1984》[乔治奥威尔], 高尔基三部曲:《童年》、《在人间》、《我的大学》、《钢铁》、《简爱》、《巴黎圣母院》、《卡夫卡》、《小王子》、《呐喊》、《彷徨》、《平凡的世界》、《白鹿原》、《尘埃落定》… … 网络类型小说: 《明朝那些事儿》、《斗破》、《诛仙》… … 其它类型书籍: 《Zero To One》、《金融市场分析》、《日本蜡烛图》、《认识经济》… … 有人说，读万卷书不如行万里路，我不认同。如果你也是，请邮件我！哈哈哈！ 程浩《站在两个世界的边缘》在中讲到: 我们都是如此渺小以至于无法抵抗任何突如其来或天降之祸，而往往重要的不是这种突如其来或天降之祸的程度有多大，而是每个人面对这些艰难困苦时的心态和行动！(对生命，对生活，对这个世界很多看法都有些许改变。希望我们都能独立、客观看待周边的人和物、看待这个世界和宇宙。) zhihu上有个关于最NB的事儿回答(程浩)说: “不是那些可以随口拿来夸耀的事迹，而是那些在困境中依然保持微笑的凡人”。不用肆意炫耀那些事情，一切皆如灰。 不得不说, 生活是把刀, 催人到老, 这两年真的很少看📚了. 一切尽力而为吧, 多了几分佛系. 🎬电影好评的、差评的都基本看过，国内的，国外的，满满的存货, 总想着能以后老了退休了和老婆一起看. 当然，美剧也是大爱，很多！权利的游戏 全季全部追完。 2020 年开始处于剧荒中 … 🎵音乐乐队当属：Coldplay ！！！ Everglow, fix youm, hymn for the weekend …乡村流行: taylor 霉霉！！！bla bla … R&amp;B 类型、什么的(Jay啊这一类也不少听)…. 全都听了个遍. I am still here。 还有很多如: The Beatles 的 Hey jude， Passenger 的 「Let her go」起始的钢琴独奏, pretty nice !… … 📅工作I am word here Now _ 「Before」 zhihu 「Now」 Meituan 🚴🚴🚴 目标 这个阶段大家都需要的啦 :]’ 无忧无虑的生活吧.(From 2020 年的新目标) 生活最近的生活有点糟糕，需要好好调理调理 都说三十而立, 然而呢? 现在的日子好像没那么糟, 但也没那么理想, 总感觉少点什么. 可能这就是人性, 趋利避害吧. 马上要有新的身份了, 希望可以更进一步, 一起加油吧💪🏻. 💻其它除了工作就是玩乐，学习。成家、立业、安天命? 人总是要学会付出和承担, 不能只想享乐和收获, 没有夏天烈日炎炎的炙烤, 哪来金秋的硕果累累时的满足和喜悦? 前后端开发(python&#x2F;Web&#x2F;H5&#x2F;react&#x2F;Angular)、Java、NodeJS，都可以搞。恩。 未来想向 AI、物联网方向走，有机会要去探探路，求 together ！！！ * * * 成长 长大后，踏上火车的那一刻还没有意识到，从此后，故乡只有冬，再无春夏秋. ![火车](/img/huoche.jpeg \"在路上\")"},{"title":"tags","date":"2022-01-14T11:40:22.892Z","updated":"2022-01-14T11:40:22.892Z","comments":true,"path":"tags/index.html","permalink":"http://lomo.space/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2022-01-14T11:40:22.890Z","updated":"2022-01-14T11:40:22.890Z","comments":true,"path":"categories/index.html","permalink":"http://lomo.space/categories/index.html","excerpt":"","text":""},{"title":"Essay -- 随笔2","date":"2022-01-14T11:40:22.890Z","updated":"2022-01-14T11:40:22.890Z","comments":true,"path":"categories/essay/2017-02-23-suibi2.html","permalink":"http://lomo.space/categories/essay/2017-02-23-suibi2.html","excerpt":"","text":"Sample 123Sample"},{"title":"Essay -- 随笔","date":"2022-01-14T11:40:22.890Z","updated":"2022-01-14T11:40:22.890Z","comments":true,"path":"categories/essay/index.html","permalink":"http://lomo.space/categories/essay/index.html","excerpt":"","text":"Sample 22Sample"}],"posts":[{"title":"k8s-app-node-port","slug":"k8s-app-node-port","date":"2018-12-18T14:09:37.000Z","updated":"2022-01-14T11:40:22.883Z","comments":true,"path":"2018/12/18/k8s-app-node-port/","link":"","permalink":"http://lomo.space/2018/12/18/k8s-app-node-port/","excerpt":"","text":"K8S 应用部署之 NodePort使用 run 命令直接创建一个简单的 deployment: kubectl run nginx-deployment –image&#x3D;nginx 需要控制台会输出一些提示: 12kubectl run --generator=deployment/apps.v1 is DEPRECATED and will be removed in a future version. Use kubectl run --generator=run-pod/v1 or kubectl create instead.deployment.apps/nginx-deployment created 提示, run deployment 的方式未来会被舍弃掉. 查看 pods: 第一个即为刚创建的 pod. 第二个是之前测试 yml 方式创建的 pod（只是一个 pod, 具体参照 nginx-pod.yml 文件） 查看 deployments: kubectl get deployment -o wide 查看 svc: kubectl get svc 目前还只有一个之前 kubernetes 这一个. 查看 rs: kubectl get rs 负载均衡 修改 replicas 的方式。 123kubectl scale --replicas=2 deployment/nginx-deployment# outputdeployment.apps/nginx-deployment scaled 查验 rs 和 pods: 查看 deployments, 也变为2个了 (kubectl get deployments) 注意: 这时删除 pod 时，直接删除 pod 会触发 replicas 的确保机制, 从而导致删除 pod 失败. 正确做法是直接删除 pod 对应的 deployment. 通过 svc 123456789kubectl expose deployment nginx-deployment --port=30001 --target-port=80# 输出service/nginx-deployment exposed# 查看kubectl get svc 或 kubectl get services# 输出NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGEkubernetes ClusterIP 10.96.0.1 &lt;none&gt; 443/TCP 14dnginx-deployment ClusterIP 10.100.28.184 &lt;none&gt; 30001/TCP 4s kubectl get pod -o wide 输出 1234NAME READY STATUS RESTARTS AGE IP NODE NOMINATED NODE READINESS GATESnginx-deployment-6c94df7599-gdcdn 1/1 Running 0 3m42s 192.168.1.23 k8s-node01 &lt;none&gt; &lt;none&gt;nginx-deployment-6c94df7599-nhp7g 1/1 Running 0 7m7s 192.168.1.22 k8s-node01 &lt;none&gt; &lt;none&gt;nginx-pod 1/1 Running 1 14d 192.168.1.19 k8s-node01 &lt;none&gt; &lt;none&gt; Cluster-ip 是集群内部分配的地址，通过 curl 10.100.28.184:30001 即可访问. 此时, 还不能在集群外访问内部的服务. 对外服务编辑 deployment 的类型: kubectl edit svc nginx-deployment tpye 默认是 ClusterIP. 保存后, 可以看到控制台输出: service/nginx-deployment edited 注：保存后，在无语法错误的前提下，该文件会被修改，如，里面的 nodePort: 30260, 即为集群对外暴露的访问端口，30001 是集群内访问端口号. 1234567# 查看 svc:kubectl get svc -o wide# 输出：NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE SELECTORkubernetes ClusterIP 10.96.0.1 &lt;none&gt; 443/TCP 14d &lt;none&gt;nginx-deployment NodePort 10.100.28.184 &lt;none&gt; 30001:30260/TCP 3m27s run=nginx-deployment 当然, pod&#x2F;deployment 也可以 edit. kubectl edit deployment nginx-deploymentkubectl edit pod nginx-pod 测试访问: 资源对象创建方式 Run 命令，通常是通过命令行方式去创建。 kubectl run nginx-deployment –image&#x3D;nginx:1.7.9 –replicas&#x3D;2 Apply 方式 kubectl apply -f nginx.yaml Nginx.yml 文件内容： 1234567891011121314apiVersion: extensions/v1beta1 #api的版本kind: Deployment #资源的类型metadata: #资源的元数据 name: nginx-deployment #资源的名称spec: #资源的说明 replicas: 2 #副本2个，缺省为1 template: #pod模板 metadata: #pod元数据 labels: #标签 app: web_server #标签选择器 spec: containers: - name: nginx image: nginx:1.79 kubectl apply 不但能够创建 Kubernetes 资源，也能对资源进行更新。 Kubernets 还提供了几个类似的命令，例如 kubectl create、kubectl replace、kubectl edit 和 kubectl patch 比较 基于命令的方式： 简单直观快捷，上手快。 适合临时测试或实验 基于配置文件的方式: 配置文件描述了 具体是什么，即应用最终要达到的状态。 配置文件提供了创建资源的模板，能够重复部署。 可以像管理代码一样管理部署。 适合正式的、跨环境的、规模化部署。 这种方式要求熟悉配置文件的语法，有一定难度.","categories":[{"name":"study","slug":"study","permalink":"http://lomo.space/categories/study/"}],"tags":[{"name":"k8s","slug":"k8s","permalink":"http://lomo.space/tags/k8s/"}]},{"title":"k8s-app","slug":"k8s-app","date":"2018-12-12T15:07:49.000Z","updated":"2022-01-14T11:40:22.883Z","comments":true,"path":"2018/12/12/k8s-app/","link":"","permalink":"http://lomo.space/2018/12/12/k8s-app/","excerpt":"","text":"K8S学习笔记之应用部署前置核心相关知识点 Kubernetes集群（Cluster）也采用了典型的“主-从”架构。一个集群主要由管理组件（Master）和工作节点（Node）组件构成. MasterMaster组件提供所有与管理相关的操作，例如调度、监控、支持对资源的操作等。 Master会通过Node Controller来定期检查所管理的Node资源的健康状况，完成Node的生命周期管理. NodeNode是实际工作的计算实例（在1.1之前版本中名字叫做Minion）。节点可以是虚拟机或者物理机器，在创建 Kubernetes 集群过程中，都要预装一些必要的软件来响应Master的管理。 Node节点有几个重要的属性: 地址信息、阶段状态、资源容量、节点信息 地址信息包括： 主机名（HostName）：节点所在系统的主机别名，基本不会用到； 外部地址（ExternalIP）：集群外部客户端可以通过该地址访问到的节点； 内部地址（InternalIP）：集群内可访问的地址，外部往往无法通过该地址访问节点。 段状态包括： 待定（Pending）：新创建节点，还未就绪状态，需要进一步的配置； 运行中（Running）：正常运行中的节点，可被分配Pod，会定期汇报运行状态消息； 终止（Terminated）：节点已经停止，处于不可用状态，判断条件为5分钟内未收到运行状态消息。 资源容量： 包括常见操作系统资源： 如CPU、内存、最多存放的Pod个数等 节点信息： 包括操作系统内核信息 Kubernetes版本信息 Docker 引擎版本信息等，会由kubelet定期汇报 资源对象 核心资源 容器组（Pod）：由位于同一节点上若干容器组成，彼此共享网络命名空间和存储卷（Volume）。Pod是Kubernetes中进行管理的最小资源单位，是最为基础的概念。跟容器类似，Pod是短暂的，随时可变的 服务（Service）：若干（往往是同类型的）Pod形成的对外提供某个功能的抽象，不随Pod改变而变化，带有唯一固定的访问路径， 如IP地址或者域名 复制控制器（Replication Controller）：负责启动Pod，并维护其健康运行的状态。是用户管理Pod的句柄 部署（Deployment）：创建Pod，并可根据参数自动创建管理 Pod的复制控制器，并且支持升级。1.2.0版本引入提供比复制控制器更方便的操作 横向Pod扩展器（Horizontal Pod Autoscaler，HPA）：类似云里面的自动扩展组，根据Pod的使用率（典型如CPU）自动调整一个部 署里面Pod的个数，保障服务可用性 辅助概念 注解（Annotation）：键值对，可以存放大量任意数据，一般用来添加对资源对象的详细说明，可供其他工具处理 标签（Label）：键值对，可以标记到资源对象上，用来对资源进行分类和筛选 名字（Name）：用户提供给资源的别名，同类资源不能重名 命名空间（Namespace）：这里是指资源的空间，避免不同租户的资源发生命名冲突，另外可以进行资源限额 持久卷（PersistentVolume）：类似于Docker中数据卷的概念，就是一个数据目录，Pod对其有访问权限 秘密数据（Secret）：存放敏感数据，例如用户认证的口令等 选择器（Selector）：基于标签概念的一个正则表达式，可通过标签来筛选出一组资源 Daemon集（DaemonSet）：确保节点上肯定运行某个Pod，一般用来采集日志和监控节点 任务（Job）：确保给定数目的Pod正常退出（完成了任务） 入口资源（Ingress Resource）：用来提供七层代理服务 资源限额（Resource Quotas）：用来限制某个命名空间下对资源的使用，开始逐渐提供多租户支持 安全上下文（Security Context）：应用到容器上的系统安全配置，包括uid、gid、capabilities、SELinux角色等 服务账号（Service Accounts）：操作资源的用户账号 nginx 服务 默认情况下, 集群对外暴露的端口范围为 30000 ~ 32767 之间. 以 Nginx 为例, 创建 nginx-pod.yaml 文件: 123456789101112131415apiVersion: v1 # 描述文件所遵循KubernetesAPI的版本 kind: Pod # 描述的类型是pod metadata: name: nginx-pod # pod的名称 labels: # 标签 app: nginx-pod env: test spec: containers: - name: nginx-pod # 容器名 image: nginx:1.15 # 镜像名称及版本 imagePullPolicy: IfNotPresent # 如果本地不存在就去远程仓库拉取 ports: - containerPort: 80 # pod对外端口 restartPolicy: Always 在 master/cluster 节点上执行: 1kubectl apply -f /path/to/nginx-pod/yaml 查看: kubectl get pods -o wide 如何在集群外访问该服务？ 方式1(端口转发): kubectl port-forward –address 0.0.0.0 nginx-pod 9999:80 访问 http://192.168.56.104:9999/ 很容易发现， 通过端口转发的方式只适合本地测试使用,一旦 port-forward 的进程终止后, 服务就无法访问了. 当然通过 nohup 等类似方式实现进程后台运行也可以, 但是终究不够优雅, 这也不是官方推荐的, prod 环境下, 更不推荐如此的使用! 相关命令Q：创建 pod A：命令：kubectl apply -f nginx-pod.yaml Q：创建 service A：命令：kubectl apply -f nginx-nodePort.yaml 发布该 service 假设 service的 nginx-nodePort.yam文件如下 1234567891011121314apiVersion: v1kind: Servicemetadata: name: k8s-test-nginx-servicespec: selector: app: nginx-pod env: test ports: - port: 80 # 服务端口, 内部可访问 targetPort: 8080 # 目标端口, 此处指的是pod的8080端口 nodePort: 30080 # 节点端口, 外部可访问 protocol: TCP type: NodePort Q：删除 service A：假设 service 创建时使用的是 nginx-nodePort.yaml，则删除时，直接： kubectl delete -f nginx-nodePort.yaml Q：卸载 kubernets A：kubeadm reset 部署方式 传统方式 手动安装, 需要解决各种证书、依赖等等的问题 简单的部署方式 （Kubeadm） 一种实现自我管理的方式，包括 k8s 本身自己。 Kubeadm 工具，k8s 官方提供的集群部署管理工具。 K8s 的组件均以容器方式运行。 Master 结点上的 4 个组件： 1234schedulerController manageApi serverEtcd 上述 master 四个组件也运行在 POD 上（静态 POD。 一键部署(脚本)工具参考: kubeasz 工具 https://github.com/easzlab/kubeasz 生产环境部署 部署规模化生产环境的需求，推荐使用 kops 或者 SaltStack 这样更复杂的部署工具(根据张磊老师推荐)","categories":[{"name":"study","slug":"study","permalink":"http://lomo.space/categories/study/"}],"tags":[{"name":"k8s","slug":"k8s","permalink":"http://lomo.space/tags/k8s/"}]},{"title":"k8s-config","slug":"k8s-config","date":"2018-12-10T14:31:26.000Z","updated":"2022-01-14T11:40:22.883Z","comments":true,"path":"2018/12/10/k8s-config/","link":"","permalink":"http://lomo.space/2018/12/10/k8s-config/","excerpt":"","text":"K8S 学习笔记之–集群配置 借助 kubeadm 这一工具快速完成搭建与学习. 安装初始化工具主要是: kubeadm, kubelet, kubectl （所有机器上都需要） 创建 repo 源: 1234567[kubernetes]name=Kubernetesbaseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/enabled=1gpgcheck=1repo_gpgcheck=1gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg 安装: yum install -y kubelet kubeadm kubectl –disableexcludes&#x3D;kubernetes 启动初始化工具并设定随机启动: systemctl enable kubelet &amp;&amp; systemctl start kubelet 解除防火墙限制: 1234567vi /etc/sysctl.d/k8s.conf# 加入以下内容net.bridge.bridge-nf-call-ip6tables = 1 net.bridge.bridge-nf-call-iptables = 1# 刷新配置使其生效sysctl --system 预下载&#x2F;拉取镜像（Master 机器执行): kubeadm config images list # 查看集群初始化所需镜像及依赖版本号 一般会失败，需要手动拉取，从阿里云拉取。使用脚本统一一次性拉取: 123mkdir scriptsvi k8s_base_image.sh 脚本具体内容: https://gitee.com/lomospace/k8s/blob/master/scripts/k8s_base_image.sh 执行脚本: 12cd scripts. k8s_base_image.sh # 或 source k8s_base_image.sh 通过 kubeadm config images pull 确认镜像拉取成功: 初始化 kubeadm(master)1kubeadm init --kubernetes-version=v1.16.2 --apiserver-advertise-address=192.168.56.104 --pod-network-cidr=192.168.0.0/16 报错了: 解决方案: 修改 虚拟机 CPU，重启后重新执行kubeadm init操作即可. init 常用主要参数: –kubernetes-version: 指定Kubenetes版本，如果不指定该参数，会从google网站下载最新的版本信息 –pod-network-cidr: 指定pod网络的IP地址范围，它的值取决于你在下一步选择的哪个网络网络插件 –apiserver-advertise-address: 指定master服务发布的Ip地址，如果不指定，则会自动检测网络接口，通常是内网IP。 –feature-gates&#x3D;CoreDNS: 是否使用CoreDNS，值为true&#x2F;false，CoreDNS插件在1.10中提升到了Beta阶段，最终会成为Kubernetes的缺省选项 Init 过程日志输出: 默认情况下, 生成的 token 有效期为 24h 继续: 123mkdir -p $HOME/.kubesudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/configsudo chown $(id -u):$(id -g) $HOME/.kube/config 该步骤必须执行, 否则会提示: The connection to the server localhost:8080 was refused - did you specify the right host or port? 查看 pods 状态 kubectl get pods -n kube-system Node 加入在上面 init 最后, 输出了形如: kubeadm join 192.168.56.104:6443 --token ........ , 复制，然后在 node 机器上执行即可. 查看所有 nodes: kubectl get nodes 此时发现均为 NotReady 状态, 因为 master 节点还未安装网络插件. 安装网络插件(master) kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml 部署完成后， 过一会即可看到它自动刷新后的结果: 注意: 集群中的master和node节点的hostname不能重复，否则会加入集群失败!!! 相关操作命令删除集群中的 node: kubectl delete node node3 重新创建 token: kubeadm token create 查看 token: Kubeadm token list 查找 hash: openssl x509 -pubkey -in &#x2F;etc&#x2F;kubernetes&#x2F;pki&#x2F;ca.crt | openssl rsa -pubin -outform der 2&gt;&#x2F;dev&#x2F;null | openssl dgst -sha256 -hex | sed ‘s&#x2F;^.* &#x2F;&#x2F;‘","categories":[{"name":"study","slug":"study","permalink":"http://lomo.space/categories/study/"}],"tags":[{"name":"k8s","slug":"k8s","permalink":"http://lomo.space/tags/k8s/"}]},{"title":"k8s-virtual-machine","slug":"k8s-virtual-machine","date":"2018-12-07T13:45:48.000Z","updated":"2022-01-14T11:40:22.883Z","comments":true,"path":"2018/12/07/k8s-virtual-machine/","link":"","permalink":"http://lomo.space/2018/12/07/k8s-virtual-machine/","excerpt":"","text":"K8S 学习笔记之开山篇–虚拟机配置准备工作所需软件: VirtualBox(测试所用物理机为 MBP 顶配) 本地虚拟机集群, 所有机器均借助 VirtualBox 和 CentOS7 实现. 虚拟主机系统统一采用：CentOS-7-x86_64-Minimal-1804.iso iso 下载地址: http://mirrors.aliyun.com/centos/7/isos/x86_64/CentOS-7-x86_64-Minimal-1804.iso 新建三台虚拟机分别设置 hostname 为 k8s-master, k8s-node01, k8s-node02 设置 hostname 使用 hostnamectl 命令即可 如: hostnamectl set-hostname k8s-node01 虚拟机启动后, 窗口调整快捷键为: command + c 虚拟机安装使用可参考: https://blog.csdn.net/yang_yun_hao/article/details/87917657 虚拟机无法连接外网问题解决: 1&gt; virtualbox 设置 偏好设置 -&gt; 网络 -&gt; 添加新 NAT 网络, 双击并勾选启用网络、支持 DHCP CentOS 网络设置 12345678sudo vim /etc/sysconfig/network-scripts/ifcfg-enp0s3# 将 ONBOOT = no 改为 yes# 再重启reboot# 或重启网卡服务即可service network restart 默认情况下, 虚拟机的 IP 由 VirtualBox的 DHCP 服务动态分配, 这在多态虚拟机的情况下不好管理, 最好一台机器固定一个 IP, 这时就需要配置静态 IP. 管理 -&gt; 主机网络管理器，点击创建按钮即可。 然后每个虚拟机配置上该网卡即可。 ip addr|grep inet ssh login 配置 配置这个, 是为了方便直接在物理机登陆虚拟机系统, 方便操作. 方式1:使用 ssh-copy-id 命令将 key 写到远程机器的 ~&#x2F;.ssh&#x2F;authorized_key 文件中. (该方法必须2端操作时为同一个用户名) 方式2: 将 本地机器的 rsa copy 至所需登陆的服务机器上. scp ~&#x2F;.ssh&#x2F;id_rsa.pub &#114;&#111;&#x6f;&#x74;&#64;&#x31;&#x39;&#50;&#46;&#x31;&#54;&#56;&#x2e;&#53;&#54;&#46;&#49;&#48;&#49;:.ssh&#x2F;id_rsa.pub 在B上的命令 (先于 A执行，A - 为本地机器): touch &#x2F;root&#x2F;.ssh&#x2F;authorized_keys # (如果已经存在这个文件, 跳过这条) 将id_rsa.pub文件从 A本地机器上 上传到 B 机器后再执行该操作： cat &#x2F;root&#x2F;.ssh&#x2F;id_rsa.pub &gt;&gt; &#x2F;root&#x2F;.ssh&#x2F;authorized_keys # (将id_rsa.pub的内容追加到authorized_keys 中) 测试登陆: ssh root@k8s-master ok. 添加 alias 更方便登陆: 12345vim ~/.bash_profile# k8s 集群信息alias k8s_master=&quot;ssh root@k8s-master&quot;alias k8s_node01=&quot;ssh root@k8s-node01&quot;alias k8s_node02=&quot;ssh root@k8s-node02&quot; 系统基础软件安装&amp;配置系统软件 每台机器都安装 12yum install -y epel-releaseyum install -y conntrack ntpdate ntp ipvsadm ipset jq iptables curl sysstat libseccomp wget 系统设置2.1 关闭防火墙 12345systemctl stop firewalld &amp;&amp; systemctl disable firewalld# 输出Removed symlink /etc/systemd/system/multi-user.target.wants/firewalld.service.Removed symlink /etc/systemd/system/dbus-org.fedoraproject.FirewallD1.service. 2.2 关闭 selinux 12setenforce 0 &amp;&amp; sed -i &quot;s/SELINUX=enforcing/SELINUX=disabled/g&quot; /etc/selinux/config# 此处无输出任何内容哈. 2.3 关闭 swap 单纯的执行 swapoff 只是临时关闭, 下次重启后还是会打开. 因此需要修改文件: vim &#x2F;etc&#x2F;fstab # 将 swap 分区一行注释即可. 使用命令行关闭方式: 1swapoff -a &amp;&amp; sed -i &quot;s/\\/dev\\/mapper\\/centos-swap/\\#\\/dev\\/mapper\\/centos-swap/g&quot; /etc/fstab docker 安装为了加速在国内安装, 使用阿里云镜像: wget -O &#x2F;etc&#x2F;yum.repos.d&#x2F;docker-ce http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 安装 docker（所有机器执行）： yum install docker-ce -y 但是提示没有可用软件包(-_-||): 解决方案1: 1234567891011# 依次执行如下命令: yum install -y yum-utils device-mapper-persistent-data lvm2yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repoyum makecache fastyum install docker-ce -y # 非一般的速度就下载安装完毕 docker# 测试docker -v# 输出:Docker version 19.03.4, build 9013bf583a 解决方案2: 123sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.reposudo yum install docker-ce -y 配置(master、node 均需要) 启动 docker 并设定随机启动: systemctl enable docker &amp;&amp; systemctl start docker 调整 docker 部分参数 123mkdir -p /etc/dockervi /etc/docker/daemon.json# 添加如下内容: 1234567891011121314&#123; &quot;exec-opts&quot;: [&quot;native.cgroupdriver=systemd&quot;], &quot;log-driver&quot;: &quot;json-file&quot;, &quot;log-opts&quot;: &#123; &quot;max-size&quot;: &quot;100m&quot; &#125;, &quot;storage-driver&quot;: &quot;overlay2&quot;, &quot;storage-opts&quot;: [ &quot;overlay2.override_kernel_check=true&quot; ], &quot;registry-mirrors&quot;: [ &quot;https://5twf62k1.mirror.aliyuncs.com&quot; ]&#125; 修改前：确认 docker 的 Cgroup Driver 信息： docker info |grep Cgroup 默认是 Cgroup Driver: cgroupfs 修改后： Cgroup Driver: systemd 重启 docker: 123# mkdir -p /etc/systemd/system/docker.service.dsystemctl daemon-reloadsystemctl restart docker","categories":[{"name":"study","slug":"study","permalink":"http://lomo.space/categories/study/"}],"tags":[{"name":"k8s","slug":"k8s","permalink":"http://lomo.space/tags/k8s/"}]},{"title":"docker deploy","slug":"docker-deploy","date":"2018-12-02T11:12:08.000Z","updated":"2022-01-14T11:40:22.876Z","comments":true,"path":"2018/12/02/docker-deploy/","link":"","permalink":"http://lomo.space/2018/12/02/docker-deploy/","excerpt":"","text":"Docker 部署问题记录 主要是针对容器内应用网络访问问题的一次小记. 缘由由于种种缘由，使用了一个开源的 BI 服务 ( Metabase )。起初，该服务在测试环境部署时毅然选择了当下主流技术：Docker。测试环境部署以及使用了一段时间后，产生了一些数据，这些数据也需要随之迁移至线上环境。该服务写了一个数据在宿主机的磁盘上，以 .db 文件的形式存在。 上线过程折腾镜像迁移将测试环境的容器镜像 commit 出来一个新的镜像，然后将该镜像部署至线上机器的容器中。 123456789sudo docker ps -a# commit 镜像sudo docker commit e7afe xx/xx-bi sha256:49f050dcb3 ... ...# 保存镜像sudo docker save -o /home/xx/xx-bi.tar xx/xxxx-bi 然后，将新 commit 出来的镜像 .tar 包文件弄出来，什么 scp, ftp 之类的。 当然使用 docker save后保存的文件再被 download 时可能提示权限问题，使用 chmod 命令解决即可。 推荐使用 docker save&#x2F;load, 使用 docker export&#x2F;import 可能有一些问题，二期导出来的包内容也不一样，可自行比较。 镜像部署机器：xxxx 线上域名：xxx.xx.com 将上面的镜像搞到线上机器后，使用 docker load 命令将该镜像加载. Nginx 配置： 123upstream $&#123;server_name&#125; &#123; server xxx.xxx.com:3000;&#125; 然后，创建容器，启动。 12sudo docker run -d -p 3000:3000 -v ~/metabase-data:/metabase-data -e &quot;MB_DB_FILE=/metabase-data/metabase.db&quot; --name 容器名 镜像名 坑的排除 sudo docker ps -a 可以看到启动的容器，但是该服务链接数据库时，就是链接不上 ！！！ 进入容器，sudo docker exec -it xxx /bin/bash, ping 数据库发现无法连通。但是在测试环境该方式是正常的。 怀疑环境隔离问题，新搞一个 mysql 容器服务来测试一下. mysql 镜像直接使用阿里的即可，参考：https://www.cnblogs.com/loovelj/p/7823093.html 启动该容器，进入容器内使用 mysql 链接时，发现还是无法链接。查看官方文档了解到 docker network: https://docs.docker.com/network/ 重新创建一个 mysql 容器服务，并指定 network, --net host, 成功链接。 最后，删除原来的容器服务，重新创建容器并指定 network, 至此问题解决。","categories":[{"name":"study","slug":"study","permalink":"http://lomo.space/categories/study/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://lomo.space/tags/docker/"}]},{"title":"python pdb","slug":"python-pdb","date":"2018-11-10T14:41:16.000Z","updated":"2022-01-14T11:40:22.885Z","comments":true,"path":"2018/11/10/python-pdb/","link":"","permalink":"http://lomo.space/2018/11/10/python-pdb/","excerpt":"","text":"pdb 调试小记起源业务层接口获取数据 GET 新接口时, 遇到以下错误 1AttributeError: Could not locate column in row for column &#x27;iteritems&#x27; 解决过程Debug 过程: 首先，在 controller 层接口代码添加 pdb 调试入口. 12345def get(lotan_session, offset, limit): scores = QualityScoreDAO.get_list_scores(offset=offset, limit=limit) import pdb pdb.set_trace() return [lotan_session.build_model(QualityScore, id=score.id) for score in scores] 然后，重启服务，模拟请求，程序运行到按照设置的 pdb 处，终端进入另一个类似 python的 console, 即开启 pdb 调试. 过程如图: 注意到 lotan_session.build_model(QualityScore, id=score.id), 在 build model 时，使用了 QualityScore 这个数据模型, 且根据 id 这个字段来进行定义 build&#96;, 而该数据模型类定义的方法为: 12345def resolve_by_id(self): return QualityScoreDAO.get_by_id(self.id)# 其调用了 QualityScoreDAO 的 get_by_id 方法. DAO 层的 get_by_id 方法: 12345678@classmethod def get_by_id(cls, id_): sql = db.tables.quality_score.select().where( db.tables.quality_score.c.id == id_ ) score = db.tables.execute(sql).fetchone() if score: return score 源码走读查看 lotan 的 build_model 方法: 12345678def build_model(self, model_cls, **kwargs): if isinstance(model_cls, six.string_types): model_cls = ModelManager().find_model_by_name(model_cls) if not model_cls: raise NameError(&quot;Model &#x27;%s&#x27; is not defiend.&quot; % model_cls) model = model_cls(**kwargs) model.attach_session(self) return model 前面的 if 只是简短的类型判断. 关键: find_model_by_name 这个方法, 该方法定义: 1234567891011121314151617181920# ModelManager 的类, 元类class ModelManager(object): __metaclass__ = SingletonMeta def __init__(self): self._models_map = &#123;&#125; def register_model(self, model_cls): self._models_map[model_cls.__name__] = model_cls def unregister_model(self, model_cls): self._models_map.pop(model_cls.__name__) def find_model_by_name(self, name): return self._models_map.get(name) @property def models(self): return self._models_map.itervalues() __metaclass__ = SingletonMeta 表示创建 ModelManager 这个类对象时会采用 SingletonMeta类 来创建 ModelManager 类. 故, SingletonMeta 类在此处是 ModelManager 的元类。 问题所在__init__ 中初始化了 名为_models_map 的 dict, 从 .get() 方法基本可以确定需要传入的参数是一个 dict 类型. 进而返回查看: return score, 使用 pdb 查看该变量属性: 12(Pdb) type(score)&lt;class &#x27;sqlalchemy.engine.result.RowProxy&#x27;&gt; 类型明显不对. \b即问题所在 return 处。将返回改为 dict(score) 即可。 12(Pdb) dict(score)&#123;&#x27;end_type&#x27;: &#x27;sdf&#x27;, &#x27;version&#x27;: &#x27;2.0&#x27;, &#x27;created_at&#x27;: datetime.datetime(2017, 11, 28, 18, 22, 36), &#x27;updated_at&#x27;: datetime.datetime(2017, 11, 28, 18, 22, 36), &#x27;pa_name&#x27;: &#x27;mxxe-platform&#x27;, &#x27;score&#x27;: 0.972, &#x27;id&#x27;: 122, &#x27;origin_score&#x27;: 102&#125; 参考\b资料PDB 具体用法, https://www.ibm.com/developerworks/cn/linux/l-cn-pythondebugger/index.html Python 元类, http://blog.jobbole.com/21351/","categories":[{"name":"program","slug":"program","permalink":"http://lomo.space/categories/program/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://lomo.space/tags/Python/"},{"name":"PDB","slug":"PDB","permalink":"http://lomo.space/tags/PDB/"}]},{"title":"stored procedure","slug":"stored-procedure","date":"2018-10-10T14:50:32.000Z","updated":"2022-01-14T11:40:22.887Z","comments":true,"path":"2018/10/10/stored-procedure/","link":"","permalink":"http://lomo.space/2018/10/10/stored-procedure/","excerpt":"","text":"存储过程定义存储过程，类似程序语言的一组&#x2F;系列 实现特定功能的 SQL \b组合(包含了常见的 SQL 语句、基本的流程控制, if else、 case when then、concat 等等). 它经过编译后存储在数据库中, 以后不需要再次编译而可以直接调用(call). 存储过程的格式类似函数, 有名字、参数. 常用的 MySQL, 其存储过程的定义有三种参数类型: in, out, inout 创建&#x2F;使用&#x2F;删除创建: 123456-- # 关键字 create 和 procedurecreate procedure sp_xxName()begin-- # ...-- # ...end 调用: call sp_xxName(), 调用时 存储过程名后面必须加 (), 无论其定义时是否有参数. 删除: drop procedure sp_xxName() 查看: show procedure status 显示数据库中所有存储的存储过程基本信息，包括所属数据库，存储过程名称，创建时间等 show create procedure sp_name 显示某一个mysql存储过程的详细信息 示例以 MySQL DBMS 为例. e.g.1 不带参数的存储过程 创建一个简单(不带参数)的存储过程： create procedure sp_test() select 1; 查看创建的这个存储过程： show create procedure sp_test; 调用存储过程： call sp_test(); e.g.2 带输入参数 输入参数(in关键字)，调用存储过程时必须要传入该参数，且存储过程中修改该参数的值不能被返回. DELIMITER原本就是“；”的意思，因此用这个命令转换一下“；”为“&#x2F;&#x2F;”，这样只有收到“&#x2F;&#x2F;”才认为指令结束可以执行. 创建一个带参数的存储过程: 12345678delimiter //create procedure sp1_test(in p int)comment &#x27; insert into value &#x27;begindeclare v1 int;set v1 = p;Insert into test(id) values(v1);end // 调用存储过程： call sp1_test(1); // e.g.3(带输出参数) 关键字out，表示该参数值 在 存储过程内部 改变并返回该值； 创建存储过程: 12345create procedure sp2_test(out p int)DETERMINISTICbeginselect max(id) into p from test;end // 调用: 必须要加 @ 符号！ call sp2_test(@max); // 获取调用后的结果: select @max; // e.g.4 (带输入输出参数) 创建: 1234567891011121314drop procedure if exists sp3_test //create procedure sp3_test(in p int , out s int)beginif p = 1 thenset @v = 111; // 与declare 声明变量方式类似，该方式必须在变量名前加@elseset @v = 333;end if;insert into test(id) values(@v);select max(id) into s from test;end // 调用: call sp3_test(1, @res1); // 获取调用后的结果: 1234567select @res1; //+-------+| @res1 |+-------+| 212 |+-------+1 row in set (0.00 sec) 结果不是111，因为表中之前已存的最大数是212。 Call sp3_test(3, @res2); // 获取存储过程返回值: 1234567mysql&gt; select @res2; //+-------+| @res2 |+-------+| 333 |+-------+1 row in set (0.00 sec) e.g.5(同时作输入输出参数的存储过程)： drop procedure if exists sp4_test // 创建: 12345678910create procedure sp4_test(inout s int)beginif s = 100 thenset @v = 1000;elseset @v = 999;end if; /* 必须加分号 */select @v;end // 调用: 12345-- #先设定变量：set @x = 100; //Set @x2 = 1;call sp4_test(@x); //","categories":[{"name":"study","slug":"study","permalink":"http://lomo.space/categories/study/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://lomo.space/tags/mysql/"},{"name":"sql","slug":"sql","permalink":"http://lomo.space/tags/sql/"}]},{"title":"rxjs notes","slug":"rxjs-notes","date":"2018-09-05T09:32:02.000Z","updated":"2022-01-14T11:40:22.887Z","comments":true,"path":"2018/09/05/rxjs-notes/","link":"","permalink":"http://lomo.space/2018/09/05/rxjs-notes/","excerpt":"","text":"rxjs什么事RxJSRXJS 是 ReactiveX编程理念&#x2F;思想的 JavaScript实现版本. 其它语言里, 如 Java 有对应的 RxJava[https://github.com/ReactiveX/RxJava] ReactiveX是一种针对异步数据流的编程; ReactiveX 是由微软xx架构师创造. ReactiveX 参考: http://reactivex.io/intro.html RxJS主要成员(核心概念) Observable 数据生产、传播 Observer 数据消费 Subscriber 连接 Observable 和 Observer Operator 数据流、传播途中对数据值进行操作&#x2F;转换的操作符 Subject 包含 Observable 和 Observer Example123456789mkdir rxjs_exercisecd rxjs_exercisenpm init# or -gnpm install --save-dev ts-node# mustnpm install rxjs --save Observable 创建e.g. 1 【from】 app.ts 123456789101112131415161718192021import &#123; Observable, &#125; from &#x27;rxjs&#x27;;import &#x27;rxjs/add/observable/from&#x27;; # 操作符 fromlet persons = [ &#123; name: &#x27;Dave&#x27;, age: 34, salary: 2000 &#125;, &#123; name: &#x27;Nick&#x27;, age: 37, salary: 32000 &#125;, &#123; name: &#x27;Howie&#x27;, age: 40, salary: 26000 &#125;, &#123; name: &#x27;Brian&#x27;, age: 40, salary: 30000 &#125;, &#123; name: &#x27;Kevin&#x27;, age: 47, salary: 24000 &#125;,];let index = 0;Observable.from(persons).subscribe( person =&gt; &#123; console.log(++index, person); &#125;, error =&gt; console.log(error), () =&gt; console.log(&#x27;stream end/// &#x27;)); 12345678910ts-node app# 输出结果1 &#123; name: &#x27;Dave&#x27;, age: 34, salary: 2000 &#125;2 &#123; name: &#x27;Nick&#x27;, age: 37, salary: 32000 &#125;3 &#123; name: &#x27;Howie&#x27;, age: 40, salary: 26000 &#125;4 &#123; name: &#x27;Brian&#x27;, age: 40, salary: 30000 &#125;5 &#123; name: &#x27;Kevin&#x27;, age: 47, salary: 24000 &#125;stream end/// subscribe方法里有三个方法参数, from 操作符用来读取 person 对象, subscribe里的方法开始执行时, Observable 才开始想它推送 (person)对象数据. e.g. 2 [create] 12345678910111213141516171819202122232425262728293031import &#123;Observable&#125; from &#x27;rxjs/Observable&#x27;;// generateData 对象function generateData() &#123; const people = [ &#123; name: &#x27;David&#x27;, age: 3, salary: 2000 &#125;, &#123; name: &#x27;Dav&#x27;, age: 17, salary: 12000 &#125;, &#123; name: &#x27;Lomo&#x27;, age: 20, salary: 16000 &#125;, &#123; name: &#x27;Dev&#x27;, age: 20, salary: 10000 &#125;, &#123; name: &#x27;Amy&#x27;, age: 7, salary: 34000 &#125;, ]; return Observable.create( observer =&gt; &#123; let i = 0; people.forEach( p =&gt; &#123; console.log(&#x27;推送第 &#x27; + (++i) + &#x27; 条数据&#x27;); observer.next(p) &#125;); observer.complete(); &#125; );&#125;generateData().subscribe( people =&gt; &#123; console.log(people.name + &#x27;--&#x27; + people.age + &#x27;--&#x27; + people.salary); &#125;, error =&gt; &#123; console.log(error); &#125;, () =&gt; &#123; console.log(&#x27;消费完了.&#x27;); &#125;); 12345678910111213# ts-node create 运行结果如下:推送第 1 条数据David--3--2000推送第 2 条数据Dav--17--12000推送第 3 条数据Lomo--20--16000推送第 4 条数据Dev--20--10000推送第 5 条数据Amy--7--34000消费完了. Observable.create() 方法接受一个 function 方法参数. 通过运行结果发现， 当订阅者每消费一条数据, observable 就会推送一条数据, 并逐次推送对象里的数据给消费者, 直到 complete(), 从而形成 流式. 尝试将 .subscriobe() 方法里的三个方法注释掉, 1234567generateData().subscribe( // people =&gt; &#123; // console.log(people.name + &#x27;--&#x27; + people.age + &#x27;--&#x27; + people.salary); // &#125;, // error =&gt; &#123; console.log(error); &#125;, // () =&gt; &#123; console.log(&#x27;消费完了.&#x27;); &#125;); 运行结果: 12345推送第 1 条数据推送第 2 条数据推送第 3 条数据推送第 4 条数据推送第 5 条数据 整个数据流的传递 只有 Observable 在被订阅(.subscribe())消费时才会去推送数据流(不管订阅者是否处理消费, 只要订阅了 就给你推送). Operator 操作符常见操作符: of, map, reduce, filter, take, first, Timer, Interval. 操作符本质上是一个 function, 用来处理、加工 Observable 中传递的数据流里的数据. 这个 操作符 function() 输入、输出(返回)均为Observable类型 e.g. 123456789101112131415161718192021222324import &#123; Observable &#125; from &#x27;rxjs/Observable&#x27;;import &#x27;rxjs/add/observable/from&#x27;;import &#x27;rxjs/add/operator/map&#x27;;import &#x27;rxjs/add/operator/reduce&#x27;;let persons = [ &#123; name: &#x27;David&#x27;, age: 3, salary: 2000 &#125;, &#123; name: &#x27;Dav&#x27;, age: 17, salary: 12000 &#125;, &#123; name: &#x27;Lomo&#x27;, age: 20, salary: 16000 &#125;, &#123; name: &#x27;Dev&#x27;, age: 20, salary: 10000 &#125;, &#123; name: &#x27;Amy&#x27;, age: 7, salary: 34000 &#125;,];// reduce 里的0 是设定的一个默认返回值, 可以不给.Observable.from(persons).map(p =&gt; p.salary).reduce((total, current) =&gt; total + current, 0).subscribe( total =&gt; &#123; console.log(`total salary is: $&#123;total&#125;`) // console.log(persons); &#125;, err =&gt; console.log(err), () =&gt; console.log(&#x27;finished.&#x27;)); 123# ts-node operatortotal salary is: 74000finished. 通过 map 方法获取数据流的所有salary, 并交给reduce 计算获取总和 参考: https://www.jianshu.com/p/d8cb71554008 https://segmentfault.com/a/1190000008834251 catch() 错误处理错误处理需要在 数据流 到达 Observer 之前拦截处理。","categories":[{"name":"program","slug":"program","permalink":"http://lomo.space/categories/program/"}],"tags":[{"name":"js","slug":"js","permalink":"http://lomo.space/tags/js/"},{"name":"rxjs","slug":"rxjs","permalink":"http://lomo.space/tags/rxjs/"}]},{"title":"react/antd notes","slug":"react-antd-notes","date":"2018-09-01T14:33:15.000Z","updated":"2022-01-14T11:40:22.886Z","comments":true,"path":"2018/09/01/react-antd-notes/","link":"","permalink":"http://lomo.space/2018/09/01/react-antd-notes/","excerpt":"","text":"Ant Design Pro使用小记背景 从Angular变更到React技术栈… 吾队, 统一使用React了, 别问为什么, 我想了好几天也没搞明白. 写吧写吧. 如今, 就一个人好好搬砖吧. 本次项目直接使用antd pro, 阿里的那一套…… https://pro.ant.design/ 初始化工作 由于本次直接使用的是 ali 的antd pro 中台解决方案. 基本相当于二次开发…… 安装脚手架 1234567npm install dva-cli -gdva -vdva-cli version 0.9.2# 创建项目dva new# ... ... 本地运行: 123456cd projectNamenpm start# http://localhost:8000/# build prodnpm build 项目目录解析1234567891011# 未包含隐藏.xx相关配置文件.├── appveyor.yml├── jest.config.js├── mock├── node_modules├── package-lock.json├── package.json├── public├── src└── tests mock 目录下都是mock数据用的文件 public 目录下存放静态资源文件 src 项目的源码 tests 单元测试代码 关于以 . 开头的隐藏文件说明: .roadhogrc.mock.js 该文件主要是用来在本地mock数据时 拦截、代理本地接口请求用的. 具体使用, 后续会讲到. .webpackrc.js webpack打包配置相关设定, 可以看到已经将antd这个库设置为打包进去了, 使用react官方脚手架，创建时 时需要人为配置. .eslint.js, .babelrc.ks 都是相关配置文件, 暂不需要过度关注和修改. src目录说明1234567891011121314151617.├── assets├── common├── components├── e2e├── index.ejs├── index.js├── index.less├── layouts├── models├── polyfill.js├── rollbar.js├── router.js├── routes├── services├── theme.js└── utils assets文件夹, 静态资源存放 common文件夹, 公共的, 按照ant pro设定就2个文件 components文件夹, 纯UI组件 e2e, end 2 end 测试 models 文件夹, 存放模型Model(和数据操作密切相关的)文件, 和dva密切关联. utils, 一些常用函数工具类库 services, 存放一些接口请求相关的封装 routes文件夹, 存放页面相关的route component(不是纯UI组件, 其包含了一些具体的页面操作交互、方法定义、周期钩子函数componentDidMount等). layouts, 整个页面的布局设定 polyfill.js, 兼容性设置 index.js, 整个应用入口 其它暂时不用管…… 项目示例需求: 需要展示一个 product 列表, 并在左侧导航栏的二级菜单下有一个入口. menu配置 菜单配置, 添加入口, 修改src/common/menu.js文件.找到 path: &#39;management&#39; 关键字, 在 children下按照同样的语法格式添加即可. 该语法和 Angular 中的路由配置类似. 1234567path: &#x27;management&#x27;, children: [ &#123; name: &#x27;产品线&#x27;, path: &#x27;product_line&#x27;, &#125;, ], 路由配置 添加路由配置, 修改src/common/router.js文件. 在 routerConfig 对象找个合适的位置按照同样的语法添加即可. 12345&#x27;/management/product_line&#x27;: &#123; component: dynamicWrapper(app, [&#x27;productline&#x27;], () =&gt; import(&#x27;../routes/Management/ProductLine/ProductLine&#x27;) ), &#125;, 注意, dynamicWrapper 方法的第二个数组参数, 通常用来设置该路由组件(即ProductLine)所对应的Model. view层router component组件 添加该View层的路由组件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176&lt;!-- 页面视图 --&gt;import React, &#123; PureComponent, Fragment &#125; from &#x27;react&#x27;;import &#123; connect &#125; from &#x27;dva&#x27;;import &#123; Card, Button, Form, Table, Popconfirm, Divider, message &#125; from &#x27;antd&#x27;;import ProductLineModal from &#x27;./ProductLineModal&#x27;;import PageHeaderLayout from &#x27;../../../layouts/PageHeaderLayout&#x27;;import styles from &#x27;./ProductLine.less&#x27;;@connect((&#123; productline, loading &#125;) =&gt; (&#123; productline, loading: loading.effects[&#x27;productline/fetch&#x27;],&#125;))@Form.create()export default class ProductLine extends PureComponent &#123; state = &#123; modalVisible: false, mode: null, currentRow: &#123;&#125;, &#125;; componentDidMount() &#123; const &#123; dispatch &#125; = this.props; dispatch(&#123; type: &#x27;productline/fetch&#x27;, &#125;); &#125; handleModalVisible = (flag, row = &#123;&#125;, mode = &#x27;create&#x27;) =&gt; &#123; this.setState(&#123; modalVisible: !!flag, mode, currentRow: row, &#125;); &#125;; confirmDelete = fields =&gt; &#123; const &#123; dispatch &#125; = this.props; dispatch(&#123; type: &#x27;productline/remove&#x27;, payload: &#123; deleteData: fields, &#125;, &#125;); console.log(&#x27;删除的内容: &#x27;); console.log(fields); message.success(&#x27;删除成功&#x27;); this.setState(&#123; modalVisible: false, &#125;); &#125;; handleUpdate = fields =&gt; &#123; const &#123; dispatch &#125; = this.props; dispatch(&#123; type: &#x27;productline/update&#x27;, payload: &#123; postData: fields, &#125;, &#125;); console.log(&#x27;更新的内容: &#x27;); console.log(fields); // console.log( fields.desc); // undefined message.success(&#x27;更新成功&#x27;); this.setState(&#123; modalVisible: false, &#125;); &#125;; handleAdd = fields =&gt; &#123; const &#123; dispatch &#125; = this.props; dispatch(&#123; type: &#x27;productline/add&#x27;, payload: &#123; postData: fields, &#125;, &#125;); console.log(&#x27;新增的内容: &#x27;); console.log(fields); // console.log( fields.desc); // undefined message.success(&#x27;添加成功&#x27;); this.setState(&#123; modalVisible: false, &#125;); &#125;; render() &#123; const &#123; productline: &#123; list: &#123; list: dataSource &#125;, &#125;, loading, &#125; = this.props; const &#123; modalVisible, mode, currentRow &#125; = this.state; const columns = [ &#123; title: &#x27;名称&#x27;, dataIndex: &#x27;name&#x27;, align: &#x27;center&#x27;, &#125;, &#123; title: &#x27;所属 PA&#x27;, dataIndex: &#x27;pa&#x27;, align: &#x27;center&#x27;, &#125;, &#123; title: &#x27;描述&#x27;, dataIndex: &#x27;description&#x27;, align: &#x27;center&#x27;, &#125;, &#123; title: &#x27;操作&#x27;, align: &#x27;center&#x27;, render: (text, record) =&gt; ( &lt;Fragment&gt; &lt;Button type=&quot;primary&quot; icon=&quot;edit&quot; onClick=&#123;() =&gt; this.handleModalVisible(true, record, &#x27;update&#x27;)&#125; /&gt; 编辑 &lt;Divider type=&quot;vertical&quot; /&gt; &lt;Popconfirm title=&quot;确认删除?&quot; okText=&quot;确认&quot; cancelText=&quot;取消&quot; onConfirm=&#123;() =&gt; this.confirmDelete(record)&#125; &gt; &lt;Button type=&quot;danger&quot; icon=&quot;delete&quot; /&gt; 删除 &lt;/Popconfirm&gt; &lt;/Fragment&gt; ), &#125;, ]; const parentMethods = &#123; handleAdd: this.handleAdd, handleUpdate: this.handleUpdate, handleModalVisible: this.handleModalVisible, &#125;; const parentData = &#123; modalVisible, mode, values: currentRow, &#125;; return ( &lt;PageHeaderLayout title=&quot;产品线&quot;&gt; &lt;Card bordered&gt; &lt;div className=&#123;styles.tableList&#125;&gt; &lt;div className=&#123;styles.tableListOperator&#125;&gt; &lt;Button icon=&quot;plus&quot; type=&quot;primary&quot; onClick=&#123;() =&gt; this.handleModalVisible(true)&#125;&gt; 新建 &lt;/Button&gt; &lt;/div&gt; &lt;Table rowKey=&quot;id&quot; loading=&#123;loading&#125; dataSource=&#123;dataSource&#125; columns=&#123;columns&#125; bordered /&gt; &lt;/div&gt; &lt;/Card&gt; &lt;ProductLineModal &#123;...parentMethods&#125; &#123;...parentData&#125; /&gt; &lt;/PageHeaderLayout&gt; ); &#125;&#125; 模态框的简单封装: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;!-- 上面👆那个页面用到的模态框封装 --&gt;import React, &#123; PureComponent &#125; from &#x27;react&#x27;;import &#123; Form, Input, Select, Modal &#125; from &#x27;antd&#x27;;const FormItem = Form.Item;const &#123; TextArea &#125; = Input;const &#123; Option &#125; = Select;const areas = [&#x27;社区&#x27;, &#x27;商业&#x27;, &#x27;大学&#x27;, &#x27;智能工具&#x27;, &#x27;基础架构&#x27;];@Form.create()export default class ProductLineModal extends PureComponent &#123; componentDidUpdate(prevProps) &#123; if (prevProps.modalVisible === false &amp;&amp; this.props.modalVisible === true) &#123; const &#123; form, values: &#123; name, pa, description &#125;, &#125; = this.props; form.setFieldsValue(&#123; name, pa, description, &#125;); &#125; &#125; okHandle = () =&gt; &#123; console.log(this.props.mode); // &#x27;create&#x27;, &#x27;update&#x27; const &#123; form, handleAdd, handleUpdate &#125; = this.props; form.validateFields((err, fieldsValue) =&gt; &#123; if (err) return; form.resetFields(); if (this.props.mode === &#x27;update&#x27;) &#123; handleUpdate(fieldsValue); &#125; else &#123; handleAdd(fieldsValue); &#125; &#125;); &#125;; render() &#123; const &#123; form, modalVisible, handleModalVisible, mode &#125; = this.props; const title = `$&#123;mode === &#x27;create&#x27; ? &#x27;新建&#x27; : &#x27;编辑&#x27;&#125;产品线`; return ( &lt;Modal title=&#123;title&#125; visible=&#123;modalVisible&#125; onOk=&#123;this.okHandle&#125; onCancel=&#123;() =&gt; handleModalVisible()&#125; &gt; &lt;FormItem labelCol=&#123;&#123; span: 5 &#125;&#125; wrapperCol=&#123;&#123; span: 15 &#125;&#125; label=&quot;产品线名称&quot;&gt; &#123;form.getFieldDecorator(&#x27;name&#x27;, &#123; rules: [&#123; required: true, message: &#x27;请输入产品线名称&#x27; &#125;], &#125;)(&lt;Input placeholder=&quot;请输入产品线名称&quot; /&gt;)&#125; &lt;/FormItem&gt; &lt;FormItem labelCol=&#123;&#123; span: 5 &#125;&#125; wrapperCol=&#123;&#123; span: 15 &#125;&#125; label=&quot;所属 PA&quot;&gt; &#123;form.getFieldDecorator(&#x27;pa&#x27;, &#123; rules: [&#123; required: true, message: &#x27;请选择所属 PA&#x27; &#125;], &#125;)( &lt;Select placeholder=&quot;请选择所属 PA&quot; style=&#123;&#123; width: &#x27;100%&#x27; &#125;&#125;&gt; &#123;areas.map(area =&gt; &#123; return ( &lt;Option key=&#123;area&#125; value=&#123;area&#125;&gt; &#123;area&#125; &lt;/Option&gt; ); &#125;)&#125; &lt;/Select&gt; )&#125; &lt;/FormItem&gt; &lt;FormItem labelCol=&#123;&#123; span: 5 &#125;&#125; wrapperCol=&#123;&#123; span: 15 &#125;&#125; label=&quot;描述&quot;&gt; &#123;form.getFieldDecorator(&#x27;description&#x27;, &#123; rules: [&#123; required: true, message: &#x27;请输入描述&#x27; &#125;], &#125;)(&lt;TextArea rows=&#123;3&#125; /&gt;)&#125; &lt;/FormItem&gt; &lt;/Modal&gt; ); &#125;&#125; view层router component组件对应的model 通信 针对上述3中的route component组件, 发现其中有几个方法以及与接口API交互的方法. 第一个: 进入当前页面路由后, 初始化加载的数据. 在 ProductLine 类中可以看到: 123456componentDidMount() &#123; const &#123; dispatch &#125; = this.props; dispatch(&#123; type: &#x27;productline/fetch&#x27;, &#125;); &#125; 这是 React 提供的生命周期钩子函数, render 渲染到 DOM 时就会自动触发该钩子函数, 从而发起请求fetch; 具体写法: model的namespace/方法名. 在类中调用该接口请求, 另一个必须的依赖就是 dva (阿里基于redux + react-router + redux-saga 等库的轻量封装). 使用 connect 连接到该组件的 model 该组件的model如下: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970import &#123; queryProductLine, addNewProducLine, updateProductLine, removeProductLine,&#125; from &#x27;../services/productline&#x27;;export default &#123; namespace: &#x27;productline&#x27;, state: &#123; list: [], &#125;, effects: &#123; *fetch(_, &#123; call, put &#125;) &#123; const response = yield call(queryProductLine); yield put(&#123; type: &#x27;saveProductLine&#x27;, payload: response, &#125;); &#125;, // 添加新的产品线 *add(&#123; payload, callback &#125;, &#123; call, put &#125;) &#123; const response = yield call(addNewProducLine, payload); console.log(&#x27;接收到的payload:&#x27;); console.log(payload); // 请求发出后，暂不更新数据，模拟接口返回的数据不是个list 会导致view重新渲染为空白列表 ~~ yield put(&#123; type: &#x27;saveProductLine&#x27;, payload: response, &#125;); if (callback) callback(); &#125;, // 修改某条产品线的信息 *update(&#123; payload, callback &#125;, &#123; call, put &#125;) &#123; const response = yield call(updateProductLine, payload); // console.log(&#x27;接收要修改的的payload:&#x27;); // console.log(payload); // 请求发出后，暂不更新数据，模拟接口返回的数据不是个list 会导致view重新渲染为空白列表 ~~ yield put(&#123; type: &#x27;saveProductLine&#x27;, payload: response, &#125;); if (callback) callback(); &#125;, // 删除某条产品线 *remove(&#123; payload, callback &#125;, &#123; call, put &#125;) &#123; const response = yield call(removeProductLine, payload); // console.log(&#x27;接收要删除的的payload:&#x27;); // console.log(payload); yield put(&#123; type: &#x27;saveProductLine&#x27;, payload: response, &#125;); if (callback) callback(); &#125;, &#125;, reducers: &#123; saveProductLine(state, action) &#123; return &#123; ...state, list: action.payload, &#125;; &#125;, &#125;,&#125;; 可以看到 view 层的 router component 组件调用了其对用的 model 里封装的方法. 但是实际的接口地址在哪里呢? 在下面👇 接口services层封装 在上面的第4步中可以看到该 model 从 services 文件夹下的 productline 中导入了几个方法. 接口 service 如下: 123456789101112131415161718192021222324252627282930313233343536373839import request from &#x27;../utils/request&#x27;;export async function queryProductLine() &#123; return request(&#x27;/api/productline&#x27;);&#125;// 添加新product lineexport async function addNewProducLine(params) &#123; return request(&#x27;/api/productlinepost&#x27;, &#123; method: &#x27;POST&#x27;, body: &#123; ...params, method: &#x27;post&#x27;, &#125;, &#125;);&#125;// 修改product line 信息export async function updateProductLine(params) &#123; return request(&#x27;api/productlineput&#x27;, &#123; method: &#x27;PUT&#x27;, body: &#123; ...params, method: &#x27;put&#x27;, &#125;, &#125;);&#125;// 删除product lineexport async function removeProductLine(params) &#123; return request(&#x27;api/productlinedelete&#x27;, &#123; method: &#x27;DELETE&#x27;, body: &#123; ...params, method: &#x27;delete&#x27;, &#125;, &#125;);&#125; 这里配置的URL 都是本地mock的, 默认是被本地mock接口拦截的. 至此, 整个数据流向和API请求使用, 按照上面的步骤 一步步下来 就很清晰了. 数据流 Ant Design Pro 内置使用的是 dva. 对照此图即可 明了. 应用的数据流向(和API交互过程) 数据流向Action: Action是把数据从应用(如：用户输入、点击事件触发的数据、或是从接口请求获取的数据) 传递到store的一个载体。 Action本质上是JS 普通对象。约定：Action内必须有一个字符串类的type 字段，用来表示将要执行的动作。 一般&#x2F;多数情况下，type会被定义成字符串常量； Reducer: 指定 应用状态的变化如何响应actions并发送到store（actions只描述有事情发生这一事实，没有描述应用如何更新state）； Reducer是个纯函数，主要作用：接受旧的state和action，返回新的state。 Redux应用中, 所有的state都被保存在一个单一对象中。 所以，reducer函数中 只是单纯进行计算(返回新的state)，没有API请求、没有变量修改、 Store:Store就是把action和reducer联系到一起的对象。 React简单说明 React 并不是Web应用的完整解决方案, 只是DOM的抽象层. React中值传递 都是向下传递的、单向的; 只能从父级 流向 子级. 组件声明规范: 无论是函数方式还是ES6中的class方式声明组件, 组件的命名规范: 首字母必须大写! dva 说明dva 是alibaba基于 redux + react-router + redux-saga 的一层轻量封装. 关于Redux Redux和react没有 什么直接关系. Redux不仅支持react, 也支持angular、ember、jQuery、纯JS. 关于Andt ProAnt Design of React 只是一个React相关的组件库。类似angular相关的UI库 ng-zorro. 而 Ant Design Pro相当于一个更上层的应用&#x2F;模板，协助快速开发出应用。 相关资料关于 dva 使用:官方:https://dvajs.com/guide/ 练习:https://gitee.com/lomospace/dva-sample React Google即可. Ant Design Pro官方:https://pro.ant.design/ 练习:https://gitee.com/lomospace/antPro ReduxDoc(中文)https://cn.redux.js.org/ 视频(英文)https://egghead.io/lessons/ React 脚手架官方:https://github.com/facebook/create-react-app dva系: 12345678910# installnpm install dva-cli -g# createdva new projectNamecd projetName# local runnpm start https://dvajs.com/guide/getting-started.html#%E5%AE%89%E8%A3%85-dva-cli","categories":[{"name":"program","slug":"program","permalink":"http://lomo.space/categories/program/"}],"tags":[{"name":"js","slug":"js","permalink":"http://lomo.space/tags/js/"},{"name":"react","slug":"react","permalink":"http://lomo.space/tags/react/"}]},{"title":"python-itertools","slug":"python-itertools","date":"2018-07-17T13:56:29.000Z","updated":"2022-01-14T11:40:22.885Z","comments":true,"path":"2018/07/17/python-itertools/","link":"","permalink":"http://lomo.space/2018/07/17/python-itertools/","excerpt":"","text":"Python 内置模块之 itertools组合函数 combinations combinations 示例: 给定一个数组 [‘a’, ‘b’, ‘c’, ‘d’], 求该数组的所有子串集合 转为求字符串 ‘abcd’ 子串 (答案：a, b, c, d, ab, ac, ad, bc, bd, abc, abd ….. abcd 共15个). 借助 combinations 函数实现随机不重复组合. 1234567891011arr = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;]string = &#x27;&#x27;.join(arr) # &#x27;abcd&#x27;substring = []for i in range(len(string)): # print(&#x27;i = &#123;0&#125;&#x27;.format(i)) # 0, 1, 2, 3 print(list(combinations(string, i+1))) # 输出见下面 substring.extend(list(combinations(string, i+1))) substring = [&#x27;&#x27;.join(s) for s in substring] print(substring) for 循环中 print 输出是 list(tuple) 类型: 1234[(&#x27;a&#x27;,), (&#x27;b&#x27;,), (&#x27;c&#x27;,), (&#x27;d&#x27;,)][(&#x27;a&#x27;, &#x27;b&#x27;), (&#x27;a&#x27;, &#x27;c&#x27;), (&#x27;a&#x27;, &#x27;d&#x27;), (&#x27;b&#x27;, &#x27;c&#x27;), (&#x27;b&#x27;, &#x27;d&#x27;), (&#x27;c&#x27;, &#x27;d&#x27;)][(&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;), (&#x27;a&#x27;, &#x27;b&#x27;, &#x27;d&#x27;), (&#x27;a&#x27;, &#x27;c&#x27;, &#x27;d&#x27;), (&#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;)][(&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;)] combinations(str, n), 该方法即为 取 str 中的n个字符组合. combinations(string, i+1) 的返回值为 combinations object:形如: 1234&lt;itertools.combinations object at 0x10ca179b0&gt;&lt;itertools.combinations object at 0x10ca179b0&gt;&lt;itertools.combinations object at 0x10ca8d9b0&gt;&lt;itertools.combinations object at 0x10ca8d9b0&gt; 所以, 该方法主要是用来组合!!! 排列函数 permutations permutations 12&gt;&gt;&gt; list(permutations([1,3,5], None))[(1, 3, 5), (1, 5, 3), (3, 1, 5), (3, 5, 1), (5, 1, 3), (5, 3, 1)] 继续使用上面的例子. 123456789res_per = []for i in range(len(string)): # 这里不能使用 append! 🙂 res_per.extend(list(permutations(string, i + 1))) res_per = [&#x27;&#x27;.join(s) for s in res_per]print(res_per)print(len(res_per)) # 64 res_per 的输出结果为: 1[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;ab&#x27;, &#x27;ac&#x27;, &#x27;ad&#x27;, &#x27;ba&#x27;, &#x27;bc&#x27;, &#x27;bd&#x27;, &#x27;ca&#x27;, &#x27;cb&#x27;, &#x27;cd&#x27;, &#x27;da&#x27;, &#x27;db&#x27;, &#x27;dc&#x27;, &#x27;abc&#x27;, &#x27;abd&#x27;, &#x27;acb&#x27;, &#x27;acd&#x27;, &#x27;adb&#x27;, &#x27;adc&#x27;, &#x27;bac&#x27;, &#x27;bad&#x27;, &#x27;bca&#x27;, &#x27;bcd&#x27;, &#x27;bda&#x27;, &#x27;bdc&#x27;, &#x27;cab&#x27;, &#x27;cad&#x27;, &#x27;cba&#x27;, &#x27;cbd&#x27;, &#x27;cda&#x27;, &#x27;cdb&#x27;, &#x27;dab&#x27;, &#x27;dac&#x27;, &#x27;dba&#x27;, &#x27;dbc&#x27;, &#x27;dca&#x27;, &#x27;dcb&#x27;, &#x27;abcd&#x27;, &#x27;abdc&#x27;, &#x27;acbd&#x27;, &#x27;acdb&#x27;, &#x27;adbc&#x27;, &#x27;adcb&#x27;, &#x27;bacd&#x27;, &#x27;badc&#x27;, &#x27;bcad&#x27;, &#x27;bcda&#x27;, &#x27;bdac&#x27;, &#x27;bdca&#x27;, &#x27;cabd&#x27;, &#x27;cadb&#x27;, &#x27;cbad&#x27;, &#x27;cbda&#x27;, &#x27;cdab&#x27;, &#x27;cdba&#x27;, &#x27;dabc&#x27;, &#x27;dacb&#x27;, &#x27;dbac&#x27;, &#x27;dbca&#x27;, &#x27;dcab&#x27;, &#x27;dcba&#x27;] 共 64 个组合. 该方法主要用来排列!!! TODO 源码阅读参考实现: 12345678910111213141516171819def combinations(iterable, r): # combinations(&#x27;ABCD&#x27;, 2) --&gt; AB AC AD BC BD CD # combinations(range(4), 3) --&gt; 012 013 023 123 pool = tuple(iterable) n = len(pool) if r &gt; n: return indices = list(range(r)) yield tuple(pool[i] for i in indices) while True: for i in reversed(range(r)): if indices[i] != i + n - r: break else: return indices[i] += 1 for j in range(i+1, r): indices[j] = indices[j-1] + 1 yield tuple(pool[i] for i in indices) 解析 … python 3.7 https://docs.python.org/3.7/library/itertools.html python 2.7 https://docs.python.org/2/library/itertools.html 附 append 与 extend 区别这2个方法都是用来向数组&#x2F;list 中增加数据的。 .append(x) 接受的参数: 可以是一个数字或字符串，也可以是一个数组 list 或 tuple 或 dict, 简言之，.append()可接受任何类型的数据塞进已有的 list 中. 12345&gt;&gt;&gt; test3[1, 3, 5]&gt;&gt;&gt; test3.append(&#123;&#x27;name&#x27;: &#x27;lomo123&#x27;&#125;)&gt;&gt;&gt; test3[1, 3, 5, &#123;&#x27;name&#x27;: &#x27;lomo123&#x27;&#125;] 注意：如果 append 传入的参数 x 是 数组 list 类型，则该 list 维数会在原来的基础上+1，如 ori &#x3D; [], ori.append([1,2,3]), 则 ori &#x3D; [[1,2,3]] 变为二维数组了，使用 extend 则不会。 .extend(x) 接收的参数必须是一个str类型的字符串或 list 数组类型 或 tuple 类型. 如，e.g. 1234567891011121314151617181920212223242526272829test2 = [1,3,5]test2.extend(1) # 会报错test2.extend(&#x27;a&#x27;) # [1, 3, 5, &#x27;a&#x27;]# 传字符串test2.extend(&#x27;123&#x27;) # 会将该字符串转为 list 然后与原数组合并# 输出：&gt;&gt;&gt; test2[1, 3, 5, &#x27;a&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;]# 传 tuple： &gt;&gt;&gt; test2.extend((&#x27;c&#x27;,&#x27;d&#x27;)) &gt;&gt;&gt; test2 [1, 3, 5, &#x27;a&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;c&#x27;, &#x27;d&#x27;]# 传 list：&gt;&gt;&gt; test2.extend([11,&#x27;lomo&#x27;])&gt;&gt;&gt; test2[1, 3, 5, &#x27;a&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, 11, &#x27;lomo&#x27;]# 传 dict：&gt;&gt;&gt; test3[1, 3, 5]&gt;&gt;&gt; test3.extend(&#123;&#x27;name&#x27;: &#x27;lomo6&#x27;&#125;)&gt;&gt;&gt; test3[1, 3, 5, &#x27;name&#x27;]&gt;&gt;&gt; test3.extend(&#123;&#x27;age&#x27;: 8&#125;)&gt;&gt;&gt; test3[1, 3, 5, &#x27;name&#x27;, &#x27;age&#x27;] 可以看到传入 dict 时，extend 只会把 dict 的 key 取出来 append 到数组最后。 参考排列与组合公式: https://www.zhihu.com/question/26094736","categories":[{"name":"program","slug":"program","permalink":"http://lomo.space/categories/program/"}],"tags":[{"name":"python","slug":"python","permalink":"http://lomo.space/tags/python/"}]},{"title":"java multiThreads","slug":"java-multiThreads","date":"2018-05-28T15:08:56.000Z","updated":"2022-01-14T11:40:22.881Z","comments":true,"path":"2018/05/28/java-multiThreads/","link":"","permalink":"http://lomo.space/2018/05/28/java-multiThreads/","excerpt":"","text":"Java创建多线程的几种方法 前几天被问，只想起来第一种，其它几种忘记了，特此补补。 通过Thread类 第一种，通过继承Thread类，重写run方法。 12345678910111213141516171819202122232425262728293031323334353637&lt;!-- 测试类 --&gt;public class MultiThreads extends Thread &#123; public static void main(String... args) &#123; // Main m = new Main(&quot;Lomo1&quot;); // m.start(); // Main m2 = new Main(&quot;Lomo2&quot;); // m2.start(); Main m = new Main(&quot;Lomo1&quot;); Main m2 = new Main(&quot;Lomo2&quot;); m.start(); // m.start(); 重复调用是会抛异常的！！！ // m.run(); // 是可以的，直接调用了Main类重写后的run方法！ m2.start(); // 上面2个对象调用顺序无关 不影响结果 &#125;&#125;&lt;!-- 多线程实现类 --&gt;class Main extends Thread&#123; private static int num = 5; private String name; Main(String s) &#123; this.name = s; System.out.println(&quot;--子类Main--&quot; + s); &#125; // 多线程的处理逻辑 重写于此 @Override public void run() &#123; for (int i = 0; i &lt; this.num; i ++) &#123; System.out.println(&quot;线程&quot; + this.name + &quot;: &quot; + Thread.currentThread().getName() + &quot; num = &quot; + i); &#125; &#125;&#125; 结果： 123456789101112--子类Main--Lomo1--子类Main--Lomo2线程Lomo1: Thread-0 num = 0线程Lomo1: Thread-0 num = 1线程Lomo1: Thread-0 num = 2线程Lomo2: Thread-1 num = 0线程Lomo1: Thread-0 num = 3线程Lomo2: Thread-1 num = 1线程Lomo1: Thread-0 num = 4线程Lomo2: Thread-1 num = 2线程Lomo2: Thread-1 num = 3线程Lomo2: Thread-1 num = 4 每次运行，可以看到顺序并不同，说明多线程里，那个线程先执行、什么时候执行 均取决于CPU资源的调度。 在注释中m.start();是无法多次调用该方法实现多线程共享同一个对象资源的，因为：start()方法是启动&#x2F;创建一个新线程，新线程会执行相应的run方法，其不能被同一个对象重复调用。 通过Runnable接口 通过实现Runnable接口重写其run()方法. 1234567891011121314151617181920212223242526272829303132333435/** * 第二种：通过实现Runnable接口实现多线程 * Created by lomo. * */public class MultiThreadsByRunNable &#123; public static void main(String[] args) &#123;// Mains ms = new Mains(&quot;lomoa&quot;);// // 第一个线程// new Thread(ms).start();// // 第二个线程// new Thread(ms).start();// 或这样写(推荐！) new Thread(new Mains(&quot;lomoa&quot;)).start(); new Thread(new Mains(&quot;lomoaa&quot;)).start(); &#125;&#125;class Mains implements Runnable &#123; private static int N = 5; private String name; Mains(String s) &#123; this.name = s; System.out.println(&quot;constructor is called --&quot; + s); &#125; @Override public void run() &#123; for (int i = 0; i &lt; N; i ++) &#123; System.out.println(&quot;线程&quot; + this.name + &quot;: &quot; + Thread.currentThread().getName() + &quot;运行了...&quot; + i); &#125; &#125;&#125; 运行结果： 123456789101112constructor is called --lomoaconstructor is called --lomoaa线程lomoa: Thread-0运行了...0线程lomoa: Thread-0运行了...1线程lomoa: Thread-0运行了...2线程lomoaa: Thread-1运行了...0线程lomoa: Thread-0运行了...3线程lomoaa: Thread-1运行了...1线程lomoa: Thread-0运行了...4线程lomoaa: Thread-1运行了...2线程lomoaa: Thread-1运行了...3线程lomoaa: Thread-1运行了...4 第一种，继承Thread类的实现方法，通过查看Thread的源码，发现其也是实现了Runnable接口方法，本质上是一样的。 通过实现Runnable接口实现方式的有点: 121. 避免Java中类单继承带来的问题。假设：某个类A已继承了类B，此时需要将类A放入多线程，那么通过实现接口的方式去实现是最好的(接口可以实现多继承)2. 多个线程可以共享同一个对象资源。 通过Callable和Future 通过实现Callable接口的call()方法。该call方法作为多线程处理逻辑，类似前面的run方法。call方法要求有返回值. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package javaClassExercise.multiThreading;import java.util.concurrent.Callable;import java.util.concurrent.FutureTask;/** * 第三种：通过Callable接口方式实现多线程 * Created by lomo . */public class MultiThreadsByCall implements Callable&lt;Integer&gt;&#123; private static int N = 10; MultiThreadsByCall() &#123; &#125; // main函数会启动main线程. public static void main(String[] args) &#123; MultiThreadsByCall multiThreadsByCall = new MultiThreadsByCall(); FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;Integer&gt;(multiThreadsByCall);// new Thread(futureTask).start(); for (int i = 0; i &lt; MultiThreadsByCall.N; i ++) &#123; System.out.println(&quot;线程 &quot;+ Thread.currentThread().getName() + &quot; 的当前循环变量值为：&quot; + i); if (i == 5) &#123; new Thread(futureTask, &quot;有返回值的线程&quot;).start(); &#125; &#125; try &#123; System.out.println(&quot;子线程的返回值: &quot; + futureTask.get()); &#125;catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; @Override public Integer call() throws Exception &#123; int i; for (i = 0; i &lt; this.N; i ++) &#123; System.out.println(&quot;线程: &quot; + Thread.currentThread().getName() + &quot; 调用了 &quot; + i); &#125; return i; &#125;&#125; 运行结果: 123456789101112131415161718192021线程 main 的当前循环变量值为：0线程 main 的当前循环变量值为：1线程 main 的当前循环变量值为：2线程 main 的当前循环变量值为：3线程 main 的当前循环变量值为：4线程 main 的当前循环变量值为：5线程: 有返回值的线程 调用了 0线程: 有返回值的线程 调用了 1线程: 有返回值的线程 调用了 2线程: 有返回值的线程 调用了 3线程: 有返回值的线程 调用了 4线程: 有返回值的线程 调用了 5线程: 有返回值的线程 调用了 6线程: 有返回值的线程 调用了 7线程: 有返回值的线程 调用了 8线程: 有返回值的线程 调用了 9线程 main 的当前循环变量值为：6线程 main 的当前循环变量值为：7线程 main 的当前循环变量值为：8线程 main 的当前循环变量值为：9子线程的返回值: 10","categories":[{"name":"study","slug":"study","permalink":"http://lomo.space/categories/study/"}],"tags":[{"name":"java","slug":"java","permalink":"http://lomo.space/tags/java/"}]},{"title":"interface-abstract-class","slug":"interface-abstract-class","date":"2018-05-27T14:39:11.000Z","updated":"2022-01-14T11:40:22.880Z","comments":true,"path":"2018/05/27/interface-abstract-class/","link":"","permalink":"http://lomo.space/2018/05/27/interface-abstract-class/","excerpt":"","text":"接口、抽象类、类的区别写在前面昨天被问到Java中接口、抽象类、类的区别&#x2F;差异。突然懵逼了，只是简单回答了成员属性以及方法声明的简单差异（太尴尬了，其实这个问题很简单~~） 反思下: 因为确实很久没有写Java代码了(大学又非CS专业，第一份工作中基本没有用到过Java)，Java知识还是来到现东家后靠自己业余时间现学现用。 Notes For 2018-05-26(PM) and for study ! 三者区别先上代码（show me the code, no bb😁） e.g. 1234567891011121314151617181920&lt;!-- 接口 actionList --&gt;package javaClassExercise.javaInterface;/** * Created by lomo. */public interface actionList &#123; //默认访问级别为public，变量默认为static/final类型常量！ String author = &quot;Lomo&quot;; void eat(); void listen(String s); void walk(Double x); Integer studyScore(int num); // static &#123; // &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738&lt;!-- 抽象类 --&gt;package javaClassExercise.javaInterface;/** * Created by lomo. */public abstract class peopleAction implements actionList&#123; // 构造器/构造函数 peopleAction() &#123; System.out.println(&quot;Author: &quot; + author); &#125; //重写的方法必须加修饰符，因为这在类中！ public void eat() &#123; &#125; // 重载eat方法 void eat(String s) &#123; System.out.println(&quot;i ate&quot; + s); &#125; public void listen(String s) &#123; System.out.println(&quot;i listened&quot; + s); &#125; public void walk(Double s) &#123; &#125; public Integer studyScore(int num) &#123; return num; //System.out.println(&quot;i get score: &quot; + num); &#125; // 抽象方法 protected abstract String abstractTestMethod(String s);&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!-- 普通类 --&gt;package javaClassExercise.javaInterface;/** * Created by lomo. */public class peopleActionTest extends peopleAction &#123; //在对子类进行初始化的时候，会先调用父类的构造器 peopleActionTest() &#123; super(); // 手动显式调用上面👆抽象类的peopleAction构造函数 System.out.println(&quot;子类&quot;); &#125; @Override protected String abstractTestMethod(String s) &#123; return s; &#125; @Override public void walk(Double s) &#123; System.out.println(&quot;Lomo has been walked &quot; + s + &quot;km&quot;); &#125; //重载walk方法 public void walk(String Name, Double s) &#123; System.out.println(Name + &quot;had been walked &quot; + s + &quot;km ...&quot;); &#125; public static void main(String[] args) &#123; peopleAction p = new peopleActionTest();// peopleAction pp = new peopleAction(); p.eat(&quot;米饭&quot;); p.walk(2.5); peopleActionTest ps = new peopleActionTest(); ps.walk(4.2); ps.walk(&quot;chenqiao&quot;, 7.8); &#125;&#125; Update针对第⑥点总结示例: 123456789101112131415/*** 接口中不能有`main`主函数方法，而抽象类、普通类可以有*/// 单纯声明一个包含main方法的抽象类abstract class staticAbstractClass &#123; staticAbstractClass() &#123; System.out.println(&quot;抽象类的构造函数被调用了...&quot;); &#125; abstract void printSth(String s); public static void main(String[] args) &#123; System.out.println(&quot;包含main方法的抽象类&quot;); &#125;&#125; 在ide中调试直接运行, 可以发现可以被执行了。输出 1包含main方法的抽象类 即 调用了抽象类的main方法。 对其进一步改进: 123456789101112131415161718192021222324252627public class abstractStaticMethod extends staticAbstractClass&#123; abstractStaticMethod() &#123; System.out.println(&quot;abstractStaticMethod被调用了&quot;); &#125; void printSth(String s) &#123; System.out.println(s); &#125; public static void main(String ...args) &#123; System.out.println(&quot;Lomo 168 aa aa...&quot;); abstractStaticMethod asm = new abstractStaticMethod(); asm.printSth(&quot;lomo178&quot;); &#125;&#125;abstract class staticAbstractClass &#123; staticAbstractClass() &#123; System.out.println(&quot;抽象类的构造函数被调用了...&quot;); &#125; abstract void printSth(String s); public static void main(String[] args) &#123; System.out.println(&quot;包含main方法的抽象类&quot;); &#125;&#125; 右键运行abstractStaticMethod方法，输出结果 1234Lomo 168 aa aa...抽象类的构造函数被调用了...abstractStaticMethod被调用了lomo178 可以看到运行该public时，其并没有调用父类抽象类的main方法，而是只执行本类的main方法。(此外，构造函数执行顺序：父类(抽象类)-&gt;子类(本类) ). 通常，抽象类中定义main方法好像意义不大! ① 关于成员属性(变量)方面: 接口中的成员属性一般为static final修饰，即：默认访问权限为public且接口中声明的成员属性一般为写死的(final)不能为修改. ② 关于static关键字方面: 接口中不能包含static修饰的方法或static静态代码块. 可以手动尝试，在接口中声明一个static 代码块或方法，IDE就会直接报错！😁 ③ 关于方法的声明方面: 接口中的所有方法均无方法体(即无具体的方法实现逻辑、运算过程…)，抽象类中一般都包含抽象方法(即无具体方法体的方法，只声明了函数名以及函数访问修饰符、返回值类型、参数个数、参数类型)，但是抽象类中可以包含有具体实现的方法也可以包含静态代码块(接口则不行)。抽象类的抽象方法修饰符一般为public或protected(无private, 如果是private则无法被继承的类去继承重写该方法!)且抽象方法也没有具体的方法体实现，只有声明，与接口中的类似. ④ 关于继承方面: 一个普通类一次只能继承extends一个类(该类可以是普通类、抽象类)，但是可以同时实现implements多个接口，继承抽象类时，需要在该类中实现抽象类中的所有抽象方法，实现几个接口就要重写实现接口中的所有(抽象)方法. 另, 一个接口可以同时继承多个其它接口。 但是，一个接口不能实现另一个接口!!! 12345// 单一接口继承多个接口// 预定义 接口bInterface, cInterface, dInterfaceinterface A extends bInterface, cInterface, dInterface &#123; // TODO ...&#125; ⑤ 关于构造器方面： 接口无构造器; 抽象类、类可以有(手动显式&#x2F;默认隐式) ⑥ main方法方面: 接口中不能有main主函数方法，而抽象类可以有(见上例)、普通类可以有. ⑦ 添加新方法方面: 接口中添加新方法，需要考虑那些实现了该接口的类(必须要改变、操作实现了该接口的类)，而添加在抽象类中，则可以给出默认具体实现而不必去修改该类的子类. 另，Java是单继承!!!","categories":[{"name":"study","slug":"study","permalink":"http://lomo.space/categories/study/"}],"tags":[{"name":"java","slug":"java","permalink":"http://lomo.space/tags/java/"}]},{"title":"迷你版k8s","slug":"minikube-study","date":"2018-03-17T15:57:23.000Z","updated":"2022-01-14T11:40:22.884Z","comments":true,"path":"2018/03/17/minikube-study/","link":"","permalink":"http://lomo.space/2018/03/17/minikube-study/","excerpt":"","text":"关于Kubernets 一个流行的容器编排引擎、自动化容器操作的开源平台。 主要是针对集群，包含但不限于：对容器的部署、调度、节点集群扩展等等功能。 关于minikube 迷你版minikube（来自阿里云）。方便本地部署学习Kubernetes(k8s)。 安装minikube预置 以Mac OSX上实验为例。 1&gt; 安装Kubectl Kubectl安装直接使用brew即可。 参考： https://kubernetes.io/docs/tasks/kubectl/install/?spm=a2c4e.11153940.blogcont221687.19.7dd57733VzYIPy 2&gt; 安装VM(Virtual Box虚拟机) 官网下载.dmg文件双击安装即可。 3&gt; minikube 12# 执行以下命令即可curl -Lo minikube http://kubernetes.oss-cn-hangzhou.aliyuncs.com/minikube/releases/v0.26.1/minikube-darwin-amd64 &amp;&amp; chmod +x minikube &amp;&amp; sudo mv minikube /usr/local/bin/ 4&gt; 启动 minikube默认使用virtual box启动本地 Kubernetes 环境（利用本地虚拟机部署 Kubernetes环境）。所以前面要求安装VM，否则执行到该步骤会报错. 12# terminal execminikube start --registry-mirror=https://registry.docker-cn.com 此时，会看到控制台下载了一些镜像文件。 下载完后： 5&gt; 启动web UI(Dashboard) 1minikube dashboard 执行后，会自动打开浏览器跳至URL http://192.168.99.100:30000/#!/overview?namespace=default 如图: 最后通过控制台console发现，minikube前端是使用Angular开发(1.6.6版本，😁) 后续继续研究 k8s … …","categories":[{"name":"study","slug":"study","permalink":"http://lomo.space/categories/study/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://lomo.space/tags/docker/"},{"name":"k8s","slug":"k8s","permalink":"http://lomo.space/tags/k8s/"}]},{"title":"observable","slug":"observable","date":"2018-02-24T11:11:51.000Z","updated":"2022-01-14T11:40:22.885Z","comments":true,"path":"2018/02/24/observable/","link":"","permalink":"http://lomo.space/2018/02/24/observable/","excerpt":"","text":"设计模式之订阅者模式 简单记录Observable. 该设计模式是RxJS的核心之一。 定义 一个目标对象 管理者所有依赖于它的观察者对象，当它(该目标对象)发生改变时，它会主动发出通知，告知所有订阅了该目标对象的观察者对象，进而使这些观察者对象自我更新。 示例： 很多媒体、新闻网站都会有订阅功能，网友通过订阅该网站的某些栏目或类别的信息，就会定期收到更新的内容通知，网友就可以进行阅览。当网友取消订阅，就不会再接收任何消息。 在该过程中： 该网站 =&gt; 目标对象； 网友 =&gt; 观察者； 这是一个简单的一对多模型。 应用场景 RxJS 常见的Web应用中对DOM添加事件监听( addEventListener )。 示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// 目标对象类，被订阅者class Subject &#123; private observerCollection: Array&lt;any&gt;; constructor() &#123; this.observerCollection = []; &#125; // 注册订阅者 registerObserver(observer: Observer) &#123; this.observerCollection.push(observer); &#125; // 移除订阅者 unregisterObserver(observer: Observer) &#123; // 查找订阅者 let index = this.observerCollection.indexOf(observer); if (index &gt;= 0) // 去除该订阅者 this.observerCollection.splice(index, 1); &#125; // 通知所有订阅者 notifyObservers() &#123; this.observerCollection.forEach((observer: Observer) =&gt; observer.notify()); &#125;&#125;// 观察者类，观察者class Observer &#123; private name: any; constructor(name) &#123; this.name = name; &#125; notify() &#123; console.log(`$&#123;this.name&#125; has been notified.`); &#125;&#125;// 创建目标对象let subject = new Subject();// 创建观察者对象let observer1 = new Observer(&#x27;lomo0&#x27;);let observer2 = new Observer(&#x27;lomo1&#x27;);// 注册订阅者(给观察者对象添加订阅)subject.registerObserver(observer1);subject.registerObserver(observer2);// 1. 通知注册者(观察者对象)// lomo0 has been notified.// lomo1 has been notified.subject.notifyObservers();// 2. 移除订阅者subject.unregisterObserver(observer1);// 验证移除是否Ok// lomo1 has been notified.subject.notifyObservers(); Angular中的应用 ng2+中; 后续添加项目应用code.","categories":[{"name":"study","slug":"study","permalink":"http://lomo.space/categories/study/"}],"tags":[{"name":"DesignPatterns","slug":"DesignPatterns","permalink":"http://lomo.space/tags/DesignPatterns/"},{"name":"observable","slug":"observable","permalink":"http://lomo.space/tags/observable/"}]},{"title":"general sql grammar","slug":"general-sql-grammar","date":"2017-10-03T06:14:27.000Z","updated":"2022-01-14T11:40:22.876Z","comments":true,"path":"2017/10/03/general-sql-grammar/","link":"","permalink":"http://lomo.space/2017/10/03/general-sql-grammar/","excerpt":"","text":"MySQL内置函数 平时写 SQL 用(到)过的一些 MySQL 内置函数. 常见查询e.g.1 version 表: 12345678910111213+-------------+---------------------+------+-----+---------------------+----------------+| Field | Type | Null | Key | Default | Extra |+-------------+---------------------+------+-----+---------------------+----------------+| id | bigint(20) unsigned | NO | PRI | NULL | auto_increment || project_id | int(11) | NO | | NULL | || version | varchar(32) | NO | | NULL | || build | int(11) | NO | | NULL | || stage | varchar(32) | NO | | NULL | || created_at | timestamp | NO | | CURRENT_TIMESTAMP | || released_at | timestamp | NO | | 0000-00-00 00:00:00 | || commit_hash | varchar(128) | YES | | NULL | |+-------------+---------------------+------+-----+---------------------+----------------+8 rows in set (0.01 sec) project_id 只有2个值 分别为 1、2 代表 iOS 和 Android. Q: 从version表取出: 指定版本号(version)、阶段(stage)的最小build号对应的id A: 查出结果集 1select * from version where version=&#x27;5.26.0&#x27; and stage=&#x27;grey&#x27; order by build limit 1; 12345+----+------------+---------+-------+-------+---------------------+---------------------+------------------------------------------+| id | project_id | version | build | stage | created_at | released_at | commit_hash |+----+------------+---------+-------+-------+---------------------+---------------------+------------------------------------------+| 37 | 2 | 5.26.0 | 898 | grey | 2018-09-14 15:31:19 | 0000-00-00 00:00:00 | 369f6761d4a2162a96151799fd879509d34dfdeb |+----+------------+---------+-------+-------+---------------------+---------------------+------------------------------------------+ 只获取所需的 id 1select v.id from (select * from version where version=&#x27;5.26.0&#x27; and stage=&#x27;grey&#x27; order by build limit 1) as v; 123456+----+| id |+----+| 37 |+----+1 row in set (0.06 sec) 使用了 select 子查询. 注意子查询语句后的 as 语法. 跨表查询(join) join 默认为 left join e.g.2 现同一DB下有另一张 table 名为 mr, 结构如下: 12345678910111213141516171819202122232425262728293031mysql&gt; desc mr;+------------------+---------------------+------+-----+---------------------+-----------------------------+| Field | Type | Null | Key | Default | Extra |+------------------+---------------------+------+-----+---------------------+-----------------------------+| id | bigint(20) unsigned | NO | PRI | NULL | auto_increment || project_id | int(11) | NO | MUL | NULL | || mr_id | int(11) unsigned | NO | | NULL | || version_id | int(11) | YES | | NULL | || product_id | int(11) | YES | | NULL | || testcase | varchar(512) | YES | | NULL | || description | text | YES | | NULL | || reject | tinyint(11) | NO | | 0 | || failed | tinyint(11) | NO | | 0 | || author | varchar(64) | NO | | NULL | || title | varchar(128) | NO | | NULL | || jira_key | varchar(64) | NO | | | || status | varchar(32) | YES | | NULL | || changed_file | int(11) unsigned | NO | | NULL | || additions | int(11) unsigned | NO | | NULL | || deletions | int(11) unsigned | NO | | NULL | || created_at | timestamp | NO | | CURRENT_TIMESTAMP | || merged_at | timestamp | NO | | 0000-00-00 00:00:00 | || updated_at | timestamp | NO | | CURRENT_TIMESTAMP | on update CURRENT_TIMESTAMP || total_review | int(11) | YES | | NULL | || resolved_review | int(11) | YES | | NULL | || pa_name | varchar(32) | YES | | NULL | || bug_count | int(11) unsigned | NO | | 0 | || severe_bug_count | int(11) unsigned | NO | | 0 | || bug_list | text | YES | | NULL | |+------------------+---------------------+------+-----+---------------------+-----------------------------+25 rows in set (0.02 sec) mr 表中的 version_id 字段和 version表中的 id 相等. Q: 给定一个版本号(如: 5.26.0)、且 stage=grey情况下 获取 mr 表中该版本该 stage 对应的数据. 123select mr_id, jira_key, title, author,pa_name,changed_file,additions,deletions from mr where version_id in (select v.id from (select * from version where version=&#x27;5.26.0&#x27; and stage=&#x27;grey&#x27; order by build limit 1) as v); 子查询中使用了 limit 1 表示 只取 version 表中的最小的 id. e.g.3 Q: 查询 iOS 所有版本的 mr 关键信息 A: 123select distinct version.version as &#x27;版本号&#x27;,sum(mr.changed_file) as &#x27;修改文件数&#x27;, sum(mr.additions) as &#x27;新增代码行数&#x27;, sum(mr.deletions) as &#x27;删除代码行数&#x27;, pa_name from version left join mr on version.id=mr.version_id where mr.project_id=1 group by version; 12345678910111213141516+-----------+-----------------+--------------------+--------------------+-----------------+| 版本号 | 修改文件数 | 新增代码行数 | 删除代码行数 | pa_name |+-----------+-----------------+--------------------+--------------------+-----------------+| 4.24.0 | 44 | 242 | 50 | smart-community || 4.24.1 | 1 | 29 | 0 | NULL || 4.25.0 | 31 | 177 | 115 | community || 4.25.1 | 43 | 199 | 141 | community || 4.26.0 | 366 | 7897 | 3083 | community || 4.26.1 | 127 | 776 | 339 | community || 4.26.2 | 10 | 53 | 10 | community || 4.26.3 | 0 | 0 | 0 | community || 4.27.0 | 376 | 5241 | 2321 | mobile-platform || 4.27.1 | 63 | 838 | 561 | NULL || 4.28.0 | 424 | 1117 | 15794 | community |+-----------+-----------------+--------------------+--------------------+-----------------+11 rows in set (0.03 sec) e.g.4 Q: 以pa_name 为维度 查询某个Android grey阶段 某个版本 （如: version=&#39;5.26.0&#39; , stage=&#39;grey&#39; , project_id=2） mr 表中的关键信息. A: 12345select count(mr_id) as &#x27;MR 数&#x27;,pa_name as &#x27;PA&#x27;,sum(changed_file) as &#x27;修改文件数&#x27;, sum(additions) as &#x27;新增代码行数&#x27;, sum(deletions) as &#x27;删除代码行数&#x27; from mr where version_id in (select v.id from (select * from version where version=&#x27;5.26.0&#x27; and stage=&#x27;grey&#x27; and project_id=2 order by build limit 1) as v) group by pa_name; 结果集: 123456789+--------+-----------------+-----------------+--------------------+--------------------+| MR 数 | PA | 修改文件数 | 新增代码行数 | 删除代码行数 |+--------+-----------------+-----------------+--------------------+--------------------+| 3 | commercial | 3 | 3 | 3 || 6 | community | 19 | 3821 | 18 || 1 | mobile-platform | 1 | 1 | 1 || 1 | smart-community | 1 | 1 | 1 |+--------+-----------------+-----------------+--------------------+--------------------+4 rows in set (0.02 sec) 合并查询(union)现有另一张表 diff, 其中某些字段类型 和 mr 表的一些字段(pa_name, changed_file, additions, deletions)含义类似. 结构如下: 12345678910111213141516171819202122232425262728mysql&gt; desc diff;+------------------+---------------------+------+-----+-------------------+-----------------------------+| Field | Type | Null | Key | Default | Extra |+------------------+---------------------+------+-----+-------------------+-----------------------------+| id | bigint(20) unsigned | NO | PRI | NULL | auto_increment || project_id | int(11) | NO | | NULL | || module_name | varchar(64) | NO | | NULL | || version_from | varchar(128) | YES | | | || version_to | varchar(128) | YES | | | || version_id | int(11) | NO | | NULL | || product_id | int(11) | YES | | NULL | || testcase | varchar(512) | YES | | NULL | || description | text | YES | | NULL | || reject | tinyint(11) | NO | | 0 | || failed | tinyint(11) | NO | | 0 | || author | varchar(64) | NO | | NULL | || jira_key | varchar(64) | NO | | | || changed_file | int(11) unsigned | YES | | 0 | || additions | int(11) unsigned | YES | | 0 | || deletions | int(11) unsigned | YES | | 0 | || created_at | timestamp | NO | | CURRENT_TIMESTAMP | || updated_at | timestamp | NO | | CURRENT_TIMESTAMP | on update CURRENT_TIMESTAMP || pa_name | varchar(32) | YES | | NULL | || severe_bug_count | int(11) unsigned | NO | | 0 | || bug_count | int(11) unsigned | NO | | 0 | || bug_list | text | YES | | NULL | |+------------------+---------------------+------+-----+-------------------+-----------------------------+22 rows in set (0.02 sec) Q: 现需要获取, Android 某个版本(如: 5.26.0) 灰度(stage&#x3D;grey) 所有 mr 与 diff 表中的 changed_file, additions, deletions 总和 结果以 pa_name 升序排列. A: 12345678select t.pa_name as &#x27;PA&#x27;, sum(t.changed_file) as &#x27;修改文件数&#x27;, sum(t.additions) as &#x27;新增代码行数&#x27;, sum(t.deletions) as &#x27;删除代码行数&#x27; from (select version_id,pa_name,changed_file, additions, deletions from mr union all select version_id,pa_name, changed_file, additions, deletions from diff) twhere t.version_id in (select v.id from (select * from version where version=&#x27;5.26.0&#x27; and stage=&#x27;grey&#x27; and project_id=2 order by build limit 1) as v) group by t.pa_name; 123456789+-----------------+-----------------+--------------------+--------------------+| PA | 修改文件数 | 新增代码行数 | 删除代码行数 |+-----------------+-----------------+--------------------+--------------------+| commercial | 4 | 4 | 4 || community | 19 | 3821 | 18 || mobile-platform | 1 | 1 | 1 || smart-community | 59 | 2061 | 220 |+-----------------+-----------------+--------------------+--------------------+4 rows in set (0.02 sec) 涉及到 union all 组合查询. union 会把重复的记录从结果集中去除掉;unoin 会把所有的记录返回, 所以效率比上一个高. 常见时间日期操作现有 downtime 表, 结构如下: 12345678910111213141516171819mysql&gt; desc downtime;+----------------+---------------------+------+-----+---------------------+----------------+| Field | Type | Null | Key | Default | Extra |+----------------+---------------------+------+-----+---------------------+----------------+| id | bigint(20) unsigned | NO | PRI | NULL | auto_increment || downtime_id | varchar(128) | NO | | NULL | || title | varchar(128) | NO | | NULL | || author | varchar(32) | NO | | NULL | || status | varchar(32) | NO | | NULL | || level | varchar(32) | NO | | NULL | || introduce_type | varchar(32) | NO | | NULL | || end_type | varchar(32) | NO | | NULL | || teams | text | YES | | NULL | || start_time | timestamp | NO | | CURRENT_TIMESTAMP | || end_time | timestamp | NO | | 0000-00-00 00:00:00 | || created_at | timestamp | NO | | 0000-00-00 00:00:00 | || updated_at | timestamp | NO | | 0000-00-00 00:00:00 | |+----------------+---------------------+------+-----+---------------------+----------------+13 rows in set (0.02 sec) e.g.1 Q: 以 level 为维度统计本年度(2018) downtime 表中的故障信息 A: 12select count(*) as &#x27;数量&#x27;, level as &#x27;等级&#x27;, year(created_at) as &#x27;创建时间&#x27; from downtime where year(created_at)=2018 group by level, year(created_at) order by level, year(created_at) asc; 1234567891011+--------+--------+--------------+| 数量 | 等级 | 创建时间 |+--------+--------+--------------+| 36 | P0 | 2018 || 66 | P1 | 2018 || 97 | P2 | 2018 || 67 | P3 | 2018 || 42 | P4 | 2018 || 5 | P5 | 2018 |+--------+--------+--------------+6 rows in set (0.29 sec) 使用了 内置的 year 函数. year 函数根据 表中存储的时间戳(如: ‘2018-08-28 14:58:00’), year(2018-08-28 14:58:00) 返回 2018. e.g.2 Q: 求本年度downtime平均时长 使用 TIMESTAMPDIFF 来计算两个时间段之间的差值. 这个mysql中的函数 可以用来计算2个时间段差值。第一个参数是精确单位： YEAR&#x2F; MONTH&#x2F;QUARTER&#x2F;WEEK&#x2F;DAY&#x2F;HOUR&#x2F;MINUTE&#x2F;SECOND&#x2F;FRAC_SECOND FRAC_SECOND: 毫秒 A: 1select avg(TIMESTAMPDIFF(HOUR, start_time, end_time)) from downtime where year(created_at)=2018; e.g.3 Q: 以周为维度统计本年度 downtime 信息(P2 +) A: 123select concat(&#x27;第&#x27;, week(created_at,1), &#x27;周&#x27;) as &#x27;Week&#x27;, count(*) as &#x27;新增 Downtime 数量&#x27;, sum(if(level in (&#x27;P0&#x27;, &#x27;P1&#x27;, &#x27;P2&#x27;), 1, 0)) as &#x27;新增 P2 以上 Downtime 数量&#x27; from downtime where year(created_at)=2018 group by week(created_at,1); 使用 week函数，第二个参数 1 代表 从每周从 Monday开始计算(mysql默认无参数表示从 sunday周日 算起 为一周开始). 12345678910111213141516171819202122232425262728293031323334353637383940414243+----------+------------------------+----------------------------------+| Week | 新增 Downtime 数量 | 新增 P2 以上 Downtime 数量 |+----------+------------------------+----------------------------------+| 第2周 | 5 | 2 || 第3周 | 10 | 5 || 第4周 | 6 | 6 || 第5周 | 7 | 2 || 第6周 | 3 | 1 || 第9周 | 4 | 2 || 第10周 | 8 | 6 || 第11周 | 3 | 1 || 第12周 | 8 | 2 || 第13周 | 5 | 3 || 第14周 | 10 | 4 || 第15周 | 10 | 7 || 第16周 | 7 | 5 || 第17周 | 9 | 7 || 第18周 | 3 | 3 || 第19周 | 9 | 7 || 第20周 | 10 | 6 || 第21周 | 11 | 8 || 第22周 | 9 | 8 || 第23周 | 10 | 6 || 第24周 | 8 | 6 || 第25周 | 9 | 6 || 第26周 | 10 | 7 || 第27周 | 13 | 10 || 第28周 | 10 | 9 || 第29周 | 5 | 5 || 第30周 | 8 | 5 || 第31周 | 15 | 8 || 第32周 | 8 | 4 || 第33周 | 7 | 2 || 第34周 | 5 | 2 || 第35周 | 13 | 9 || 第36周 | 4 | 2 || 第37周 | 8 | 6 || 第38周 | 14 | 7 || 第39周 | 13 | 9 || 第41周 | 6 | 5 || 第42周 | 10 | 6 |+----------+------------------------+----------------------------------+38 rows in set (0.03 sec) e.g.4 Q: 以月为维度统计本年度 downtime 信息(P2 +) A: 123select concat(&#x27;第&#x27;, month(created_at), &#x27;月&#x27;) as &#x27;Month&#x27;, count(*) as &#x27;新增 Downtime 数量&#x27;, sum(if(level in (&#x27;P0&#x27;, &#x27;P1&#x27;, &#x27;P2&#x27;), 1, 0)) as &#x27;新增 P2 以上 Downtime 数量&#x27; from downtime where year(created_at)=2018 group by month(created_at); 使用 month 函数， 该函数默认返回的是当前时间对应的月份(数字 1~12) monthname函数 函数可以获得对应的英文格式的月份. A: 123select monthname(created_at) as &#x27;Month&#x27;, count(*) as &#x27;新增 Downtime 数量&#x27;, sum(if(level in (&#x27;P0&#x27;, &#x27;P1&#x27;, &#x27;P2&#x27;), 1, 0)) as &#x27;新增 P2 以上 Downtime 数量&#x27; from downtime where year(created_at)=2018 group by month(created_at) 结果集: 123456789101112131415+-----------+------------------------+----------------------------------+| Month | 新增 Downtime 数量 | 新增 P2 以上 Downtime 数量 |+-----------+------------------------+----------------------------------+| January | 26 | 14 || February | 7 | 3 || March | 26 | 13 || April | 36 | 23 || May | 40 | 31 || June | 39 | 26 || July | 44 | 33 || August | 39 | 20 || September | 40 | 25 || October | 16 | 11 |+-----------+------------------------+----------------------------------+10 rows in set (0.28 sec) e.g.5 Q: 以季度为维度统计本年度 downtime 信息(P2 +) A: 123select concat(&#x27;Q-&#x27;, quarter(start_time)) as &#x27;季度&#x27;, count(start_time) as &#x27;新增 Downtime 数量&#x27;, sum(if(level in (&#x27;P0&#x27;, &#x27;P1&#x27;, &#x27;P2&#x27;), 1, 0)) as &#x27;新增 P2 以上 Downtime 数量&#x27; from downtime where year(start_time)=2018 group by quarter(start_time); 结果集: 123456789+--------+------------------------+----------------------------------+| 季度 | 新增 Downtime 数量 | 新增 P2 以上 Downtime 数量 |+--------+------------------------+----------------------------------+| Q-1 | 68 | 36 || Q-2 | 115 | 83 || Q-3 | 113 | 69 || Q-4 | 10 | 8 |+--------+------------------------+----------------------------------+4 rows in set (0.03 sec) 季度统计，主要使用 quarter 函数. MySQL时间日期函数参考: http://wiki.jikexueyuan.com/project/mysql/useful-functions/time-functions.html","categories":[{"name":"study","slug":"study","permalink":"http://lomo.space/categories/study/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://lomo.space/tags/mysql/"}]},{"title":"angular notes","slug":"angular-notes","date":"2017-09-26T07:14:21.000Z","updated":"2022-01-14T11:40:22.873Z","comments":true,"path":"2017/09/26/angular-notes/","link":"","permalink":"http://lomo.space/2017/09/26/angular-notes/","excerpt":"","text":"Angular项目笔记 记录📝点Angular项目开发过程中 不熟悉的、陌生的、自认为有需要注意的。 以 autoPublisher Project为例. 项目结构划分： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#root├── Temp├── app├── build├── build_w├── data├── demo├── dist├── gulpfile.js├── node_modules├── package-lock.json├── package.json├── readme.md├── tmp└── webpack.config.js#app.├── app.js├── css│ ├── fishBone.css│ └── imports.css├── favicon.ico├── img│ ├── arrow.png│ ├── jdb_blue_logo.png│ ├── jdb_logo.png│ ├── line-first.png│ ├── line-point.png│ ├── loading.gif│ └── title.png├── index.html├── js│ ├── controllers│ ├── directives│ ├── filters│ └── services├── lib│ ├── angular│ ├── bootstrap│ ├── fishBone.js│ ├── font-awesome-4.7.0│ ├── jquery│ └── layui└── views ├── autoPublishFishBone.html ├── autoPublishFooter.html ├── autoPublishNavigationBar.html └── autoPublishVersion.html#app/js, tree -L 2.├── controllers│ └── index.controller.js├── directives│ ├── indexFishBone.directive.js│ ├── indexFooter.directive.js│ ├── indexNavigationBar.directive.js│ └── indexVersion.directive.js├── filters│ └── fishBone.filter.js└── services ├── api.service.js ├── fishBone.service.js ├── fishBoneAction.service.js └── utils.service.js 核心功能主要在app/js下实现。 controllers 主要是对整个控制器。directives是对页面每个块儿的定义以及监听数据变化然后调用Service方法进行页面渲染、数据更新等。filters是对接口返回的数据进行二次处理与包装的过滤器。services文件夹下的Service主要是对公共方法封装以及提供给directive中使用的一些方法。 在页面中这 controllers directives filters services 的引用顺序： 123456789101112131415// AMD、ES6require(&#x27;./js/services/utils.service.js&#x27;); //基本公共方法require(&#x27;./js/services/api.service.js&#x27;); //$http请求封装，其它接口相关require(&#x27;./js/services/fishBone.service.js&#x27;); //页面渲染Servicerequire(&#x27;./js/services/fishBoneAction.service.js&#x27;); //事件require(&#x27;./js/controllers/index.controller.js&#x27;); //控制器require(&#x27;./js/filters/fishBone.filter.js&#x27;); //数据过滤器require(&#x27;./js/directives/indexNavigationBar.directive.js&#x27;); //nav bar directiverequire(&#x27;./js/directives/indexVersion.directive.js&#x27;); //input directiverequire(&#x27;./js/directives/indexFishBone.directive.js&#x27;); //fishBone, page mainrequire(&#x27;./js/directives/indexFooter.directive.js&#x27;); //footer 首先，控制器index.controller依赖： 12345678910111213141516171819202122// 依赖api.service.js的jdbAutoPublisherAPIModule ... 将其依赖一次添加至jdbAutoPublisherApps模块。var jdbAutoPublisherApps = angular.module(&#x27;jdbAutoPublisherApp&#x27;, [&#x27;jdbAutoPublisherAPIModule&#x27;, &#x27;jdbAutoPublisherFishBoneModule&#x27;, &#x27;jdbAutoPublishUtilsModule&#x27;, &#x27;jdbAutoPublisherFishBoneActionModule&#x27;]);// 控制器里调用了哪些函数、方法、无论是自定义还是Angular内置，在此处的function里依次注入即可// 第一种：隐示注入，书写简单，但是在js进行压缩时候会出错，需要使用插件gulp-ng-annotate(若使用gulp的话)jdbAutoPublisherApps.controller(&#x27;jdbAutoPublisherCtrl&#x27;, function($scope, jdbAutoPublishUtilsService, jdbAutoPublisherAPIService, $filter) &#123; // do sth...&#125;//上面👆这个controller依赖注入的另一种写法：// 显示注入，代码长，不易阅读，压缩不出错jdbAutoPublisherApps.controller(&#x27;jdbAutoPublisherCtrl&#x27;, [&#x27;$scope&#x27;, &#x27;jdbAutoPublishUtilsService&#x27;, &#x27;jdbAutoPublisherAPIService&#x27;, &#x27;$filter&#x27;, function($scope, jdbAutoPublishUtilsService, jdbAutoPublisherAPIService, $filter) &#123; // do sth...&#125;]);// 第三种, $inject的方式jdbAutoPublisherApps.controller(&#x27;jdbAutoPublisherCtrl&#x27;, controllerFn);controllerFn.$inject = [&#x27;$scope&#x27;, &#x27;jdbAutoPublishUtilsService&#x27;, &#x27;jdbAutoPublisherAPIService&#x27;, &#x27;$filter&#x27;];function controllerFn() &#123; // do sth...&#125; 在controller中如何正确使用Filter ? 首先，依赖注入$filter, 其次，使用语法： $filter(&#39;filter名字&#39;)(参数)即可。 再看看 indexFishBone.directive， 其需要调用fishBone.service 和 api.service 以及 fishBoneAction.serivce里的方法，那么只需在controller的moudle声明是添加对应的依赖，然后再这个directive中的function里注入依赖的Service名即可。 BTW，如果在directive的return里声明了scope: &#123;&#125;则表示该directive的scope作用域与controller中以及该应用其它地方声明的所有scope作用域都是隔离的。 其次，directive中如何获取controller中的值？或：controller与directive如何通信？ 当controller通过Service或filter获取到数据后，绑定到scope作用域，在directive中使用$watch监听该作用域上的值即可。(前提：directive中的Scope作用域未隔离！) 123456// wathch第一个参数为绑定在scope作用域上的变量scope.$watch(&#x27;fishData&#x27;, function(newVlaue) &#123; if (scope.fishData) &#123; // do sth &#125;&#125;);","categories":[{"name":"study","slug":"study","permalink":"http://lomo.space/categories/study/"}],"tags":[{"name":"angular","slug":"angular","permalink":"http://lomo.space/tags/angular/"}]},{"title":"JavaScript之setTimeout","slug":"JavaScript之setTimeout","date":"2017-09-15T01:52:23.000Z","updated":"2022-01-14T11:40:22.871Z","comments":true,"path":"2017/09/15/JavaScript之setTimeout/","link":"","permalink":"http://lomo.space/2017/09/15/JavaScript%E4%B9%8BsetTimeout/","excerpt":"","text":"JavaScript之setTimeout由setTimeout引发的一些了解 -&gt; 事件循环机制、异步队列、时钟周期、执行上下文 js里常见的2个定时器：setTimeout 和 setInterval，指定一定时间后触发其第一个参数函数(异步回调函数)然后执行函数体内的代码发生一些操作、变化…. e.g.1 123456789101112setTimeout(function()&#123;console.log(4)&#125;,0);new Promise(function(resolve)&#123; console.log(1) for( var i=0 ; i&lt;10000 ; i++ )&#123; i==9999 &amp;&amp; resolve() &#125; console.log(2)&#125;).then(function()&#123; console.log(5)&#125;);console.log(3);// 输出结果：1 2 3 5 4 Pormise，Promise 对象代表一个异步操作，它有三种状态：Pending（进行中）、Resolved（已完成，又称 Fulfilled）和 Rejected（已失败），Promise 对象的状态改变，只有两种可能：从 Pending 变为 Resolved 和从 Pending 变为 Rejected。 先看 123setTimeout(function () &#123; console.log(123) &#125;, 0); 在浏览器控制台可以看到好像确实是立马就输出123了。 先看下 123456for (var i = 0; i &lt; 1000; i++) &#123; console.log(i);&#125;setTimeout(function () &#123; console.log(&#x27;I am Here !&#x27;);&#125;, 0); 这个很好理解，常规思维都是顺序执行，这个结果也是如常规思维所想。 再看（改变下顺序）： 123456setTimeout(function () &#123; console.log(&#x27;I am Here !&#x27;);&#125;, 0);for (var i = 0; i &lt; 1000; i++) &#123; console.log(i);&#125; 在浏览器控制台执行，发现先输出的是for循环内的内容，无论循环条件里是1000还是100 或是 10，都是先执行的循环体最后执行的setTimeout 分析：首先代码被JS解释引擎(如V8)顺序加载解释并执行，到遇到setTimeout函数时，会将其第一个function参数函数放入异步队列排队等待线程空闲后再按照队列顺序执行。 new Promise是第一个参数是一个同步函数，new Promise 最终返回的结果是一个promise对象， .then()方法也是异步的，所以代码执行到此处时会将.then()的回调函数放入一个异步队列，当new Promise返回的promise达到fulfilled状态时且当前线程空闲时就会执行.then()内的异步回调函数输出结果5, 再接着执行console.log(3); 控制台输出3。 最后当前JS线程已将代码遍历完并执行完，然后获取异步队列的内回调函数，这里关键在于：为什么先执行的是new Promise返回的Promise对象的.then()里的方法而不是setTimeout里的参数函数。因为浏览器或webview的时间钟，时间钟是由机器硬件的时间周期决定(CPU时钟周期)。 总结：js主线程在执行当前代码这个线程手里，当前线程只有空闲后，才回去处理事件队列，虽然setTimeout 设定的时间已到，但是也得等队列里所有代码已执行完毕，最后才处理setTimeout里的东西。 12setTimeout(&quot;console.log(&#x27;test!&#x27;)&quot;, 1000); alert(&#x27;主线程挂起！&#x27;); 执行试试。必须要等待用户点击确认按钮后才会继续执行。 因为alert挂起了主线程，使得当前主线程被block(同样的函数还是prompt(), confirm())，主线程被挂起，整个当前执行js的进程进入等待状态，事件触发或代码执行都被中断，计时器也会暂停计时 ，当主线程恢复后，余下的代码继续执行，计时器安装时钟周期重新开始计时。 再看外国网站的例子[JakeArchibald.com]e.g.2 123456789101112131415console.log(&#x27;script start&#x27;);setTimeout(function() &#123; console.log(&#x27;setTimeout&#x27;);&#125;, 0);//promise链式调用Promise.resolve().then(function() &#123; console.log(&#x27;promise1&#x27;);&#125;).then(function() &#123; console.log(&#x27;promise2&#x27;);&#125;);console.log(&#x27;script end&#x27;); 运行输出： 12345script startscript endpromise1promise2setTimeout Promise对象经过resolve后的.then 是异步的. 所以promise1 和 promise2的输出会在第3、4行输出；(setTimtout是因为 异步队列+系统时钟周期导致最后被执行–即当前线程空闲时) 进一步修改示例e.g.3 12345678910111213console.log(&#x27;script start&#x27;);setTimeout(function() &#123; console.log(&#x27;setTimeout&#x27;);&#125;, 0);new Promise(function(resolve)&#123;console.log(123)&#125;).then(function() &#123; console.log(&#x27;promise1&#x27;);&#125;).then(function() &#123; console.log(&#x27;promise2&#x27;);&#125;);console.log(&#x27;script end&#x27;); 运行后输出： 12345script start123script endsetTimeout 再修改：e.g.4 1234567891011121314151617181920console.log(&#x27;script start&#x27;);setTimeout(function() &#123; console.log(&#x27;setTimeout&#x27;);&#125;, 0);let promise = new Promise(function(resolve, reject)&#123; console.log(&quot;执行了new Promise里的resolve&quot;); resolve(123); &#125;);promise.then(function() &#123; console.log(&#x27;promise1&#x27;);&#125;).then(function() &#123; console.log(&#x27;promise2&#x27;);&#125;).then(function()&#123; console.log(&#x27;promise 3&#x27;);&#125;);console.log(&#x27;script end&#x27;); 123456789#输出：script start执行了new Promise里的resolvescript endpromise1promise2promise 3setTimeout 这是因为 new Promise()里接受一个函数参数function(resolve,reject)用来执行异步执行成功或失败后的处理逻辑。 12345678910111213let promise = new Promise(function(resolve, reject)&#123; if(value/*success */)&#123; resolve(value); &#125;else&#123; reject(value); &#125;&#125;);promise.then(function(successValue)&#123; console.log(successValue); // 此函数可以接收resolve过来的对象。此处：打印resole过来的值&#125;, function(failInfo)&#123; console.log(failInfo); // 打印错误信息&#125;); new Promise()里的参数函数，在代码被执行到此处时可以认为是同步执行的，其返回的Promise对象使用.then链式调用时其内的函数是被异步执行。 参考:https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/https://github.com/abbshr/abbshr.github.io/issues/32 http://www.jianshu.com/p/063f7e490e9a [Promise基础]","categories":[{"name":"essay","slug":"essay","permalink":"http://lomo.space/categories/essay/"}],"tags":[{"name":"js","slug":"js","permalink":"http://lomo.space/tags/js/"}]},{"title":"angularjs之directive","slug":"angularjs之directive","date":"2017-09-14T08:22:31.000Z","updated":"2022-01-14T11:40:22.874Z","comments":true,"path":"2017/09/14/angularjs之directive/","link":"","permalink":"http://lomo.space/2017/09/14/angularjs%E4%B9%8Bdirective/","excerpt":"","text":"angularjs之directive指令directive的控制器controller、链接link和编译compile directive指令： 123&lt;div class=&quot;row&quot;&gt; &lt;jdb-introductionhtml&gt;&lt;/jdb-introductionhtml&gt;&lt;/div&gt; directive.js 123456789101112131415161718192021222324detailsApp.directive(&#x27;jdbIntroductionhtml&#x27;, function(utilsService) &#123; return &#123; restrict: &#x27;EAC&#x27;, replace: false, // scope: &#123;&#125;, template: &#x27;统计周期：本月（&lt;strong&gt;&#123;&#123;beginDate&#125;&#125;~&#123;&#123;endDate&#125;&#125;&lt;/strong&gt;）&lt;/p&gt;&lt;p style=margin-left:40px&gt;&lt;/p&gt;&#x27;, controller: function($scope) &#123; console.log(&quot;1.directive -- controller&quot;); $scope.beginDate = &#x27;0902&#x27;; $scope.endDate = &quot;0931&quot;; console.log(utilsService.getPeriod()); &#125;, link: function($scope) &#123; console.log(&quot;2.directive -- link&quot;); $scope.beginDate = &#x27;0903&#x27;; $scope.endDate = &#x27;0909&#x27;; &#125;, compile: function($scope) &#123; console.log(&quot;3.directive -- compile&quot;); $scope.beginDate = &#x27;0903&#x27;; $scope.endDate = &#x27;0908&#x27;; &#125; &#125;;&#125;); 在chrome Console 看到输出顺序：3.directive -- compile, 1.directive -- controller,发现link并未打印。是link function没有执行吗。 了解下它们之间的区别： angular对directive指令执行顺序：编译调用compile生成dom对象，再调用link绑定到对应的$scope域(设置事件监听器，监视数据变化和实时的操作DOM.)，最后执行controller； 使用场景： 控制器和link函数可以进行互换;控制器主要是用来提供可在指令间复用的行为，但链接函数只能在当前内部指令中定义行为,无法被其它指令间复用；link函数可以将指令互相隔离开来，而controller则定义可复用的行为以供其它指令来调用该指令； link 对特定元素添加&#x2F;注册事件、增加功能、使用scope的$watch()或者想要与DOM元素做实时的交互； 简言之，在directive的controller中写的方法操作等可以被暴露出来给其他指令使用；link函数中写的方法只在本指令中使用、有效；compile指令在Angularjs解析我们自定义的HTML标签时最先执行的编译，将自定义的标签进行编译然后进行link或controller 最后产出供浏览器可以识别的DOM进行页面渲染…. 参考： https://stackoverflow.com/questions/24615103/angular-directives-when-and-how-to-use-compile-controller-pre-link-and-post","categories":[{"name":"study","slug":"study","permalink":"http://lomo.space/categories/study/"}],"tags":[{"name":"js","slug":"js","permalink":"http://lomo.space/tags/js/"}]},{"title":"Appium/WDA Docs","slug":"wda-usage-docs","date":"2017-09-07T09:39:11.000Z","updated":"2022-01-14T11:40:22.888Z","comments":true,"path":"2017/09/07/wda-usage-docs/","link":"","permalink":"http://lomo.space/2017/09/07/wda-usage-docs/","excerpt":"","text":"Appium 环境配置本文主要内容:Mac 下 基于 Appium 的自动化测试环境配置笔记。(所有环境版本号以当前最新版本为基础) 环境准备Mac 环境123456789101112131415# 系统环境sw_versProductName: Mac OS XProductVersion: 10.14.6BuildVersion: 18G95ruby -vruby 2.3.7p456# brew 安装, brew 使用参考：https://brew.sh//usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;# Xcode App Store 直接安装最新版即可xcodebuild -versionXcode 10.3 其它依赖的开发软件:Xcode、Android studio，Android Studio 安装完毕后，下载 SDK ( Android )。 Java&#x2F;Android 基础环境1234567# Java，推荐使用 JDK8 或 JDK11，暂不推荐最新版 JDK12# 注意: 目前官网下载 JDK 是需要 Oracle 账户java -versionjava version &quot;1.8.0_221&quot;mvn -vApache Maven 3.6.1 Java 及其相关环境变量配置参考: 123456789101112JAVA_HOME=&quot;/Library/Java/JavaVirtualMachines/jdk1.8.0_221.jdk/Contents/Home/&quot;PATH=$JAVA_HOME/bin:$PATHMAVEN_HOME=&quot;/Users/lomo/env/apache-maven-3.6.1&quot;PATH=$MAVEN_HOME/bin:$PATH#Android environmentexport ANDROID_HOME=&quot;/Users/lomo/Library/Android/sdk&quot;export PATH=$&#123;PATH&#125;:$&#123;ANDROID_HOME&#125;/toolsexport PATH=$&#123;PATH&#125;:$&#123;ANDROID_HOME&#125;/platform-toolsexport JAVA_HOME=&quot;/Library/Java/JavaVirtualMachines/jdk1.8.0_221.jdk/Contents/Home/&quot;export PATH=/usr/local/bin:/usr/local/sbin:~/bin:$PATH 系统依赖软件安装AppiumAppium 安装有 2 种方式: 1.GUI 版 下载 dmg 文件安装即可.该种方式对应的 WDA 文件路径: &#x2F;Applications&#x2F;Appium.app&#x2F;Contents&#x2F;Resources&#x2F;app&#x2F;node_modules&#x2F;appium&#x2F;node_modules&#x2F;appium-xcuitest-driver&#x2F;WebDriverAgent 2.无 GUI 版 npm install -g appium 安装指定版本: npm install -g &#97;&#x70;&#112;&#x69;&#x75;&#x6d;&#64;&#49;&#46;&#49;&#x33;&#46;&#48; 此种方式的 WDA 路径: &#x2F;usr&#x2F;local&#x2F;lib&#x2F;node_modules&#x2F;appium&#x2F;node_modules&#x2F;&#x5f;&#97;&#112;&#x70;&#105;&#x75;&#109;&#x2d;&#119;&#101;&#98;&#100;&#x72;&#105;&#118;&#x65;&#114;&#97;&#103;&#x65;&#110;&#x74;&#x40;&#49;&#x2e;&#50;&#46;&#48;@appium-webdriveragent 如果 npm 较慢或者有其它问题，则使用 cnpm 即可. npm install -g cnpm –registry&#x3D;https://registry.npm.taobao.org iOS 真机环境相关1.Carthage套件管理工具，与 CocoaPods 类似。详细说明可参考: https://gist.github.com/weihanglo/97e949a9dbf92deb111999b6e42e9654 brew update &amp;&amp; brew install carthage 2.ios-deploy 终端安装和调试iPhone应用的是第三方开源库 使用参考: https://www.jianshu.com/p/9b9136fa1444 安装通过 npm npm install -g ios-deploy 3.libimobiledevice该开源工具包，支持 Linux 链接 iPhone 等 iOS 设备. 这个工具包的作用就是要做一个类似于 Android 中的 adb 命令行工具！！！ brew update &amp;&amp; brew install libimobiledevice –HEAD 查看 iOS 设备 uuid: idevice_id –list 4.ideviceinstaller方便查看 iOS 设备上安装的 APP 的 bundleId brew install ideviceinstaller 使用:ideviceinstaller –help ideviceinstaller -l # 列出本机安装的所有 app 的bundle id 安装 ipa: ideviceinstaller -i xxx.ipa 卸载 ipa ideviceinstaller -U [bundleID] 如果使用时报错类似如下信息: 1Could not connect to lockdownd. Exiting. 解决方案: 123456brew uninstall -f libimobiledevice ideviceinstaller usbmuxd# 或：brew uninstall --ignore-dependencies libimobiledevice ideviceinstaller usbmuxd# 再源码编译安装即可brew install -v --HEAD --build-from-source usbmuxd libimobiledevice ideviceinstaller 参考: https://github.com/libimobiledevice/ideviceinstaller 4.xcpretty主要是增加 xcodebuild 输出可读性. 可选 ! gem install xcpretty Gem 是 Ruby 依赖包管理工具。类似于 iOS 开发中的 CocoaPods，Java 中的 maven、ant ….. Android 真机环境配置好 JAVA、Android 相关的环境变量，安装一个 SDK，并选择同意相关的 License，然后就直接配置参数链接真机操作即可。 编译 WDA 本地编译 WDA 主要是为了 iOS 解决相关证书问题。该步骤针对链接 iOS 设备是必经步骤！ 桌面版&#x2F;无 GUI 版，按照上述的安装路径，打开对应的 xcode 工程, 打开项目导航(点击最左侧导航栏文件夹按钮),然后右侧会展示 PROJECT 导航，选择 TARGETS 下的，分别选中 WebDriverAgentLib 和 WebDriverAgentRunner，修改其 Signing 签名，改为自己的 Apple ID 即可，同时修改 Build Settings 下 Packaging 下的 Bundle Identifier。 主要是将原来的 xxx.facebook.xx.wda.xx 中的 facebook 改一下即可，为了区分 bundleId 选择手机编译至对应的 iOS 设备上即可 (AgentRunner)。 注意: 如果 Build 真机还报错，则将下面的几个 Targets 页添加上, 主要是 bunlderId 修改和 Signing. 添加成功后，会看到签名对应处 Signing Certificate iPhone Developer: 你的 Apple ID (Team ID: 一个长度为10的大写字母串) iOS 真机配置Desired Capabilities 配置如下: 12345678&#123; &quot;udid&quot;: &quot;uuid&quot;, &quot;platformName&quot;: &quot;iOS&quot;, &quot;automationName&quot;: &quot;XCUITest&quot;, &quot;bundleId&quot;: &quot;APP的 bundleId&quot;, &quot;platformVersion&quot;: &quot;11.4.1&quot;, &quot;deviceName&quot;: &quot;设备名&quot;&#125; 设备名称通过 idevicename 即可获取uuid 通过 idevice_id -l 获取通过 USB 链接的 iOS 设备列表 Android 真机配置1234567&#123; &quot;platformName&quot;: &quot;Android&quot;, &quot;platformVersion&quot;: &quot;7.1.1&quot;, &quot;deviceName&quot;: &quot;Lomo-note3&quot;, &quot;noReset&quot;: true, &quot;app&quot;: &quot;/Users/lomo/Downloads/app-debug.apk&quot;&#125; 框架设计关注点: 12341. 可扩展性2. 可维护性3. 可推广性4. 投入/产出比 具体框架设计细节暂不赘述.","categories":[{"name":"program","slug":"program","permalink":"http://lomo.space/categories/program/"}],"tags":[{"name":"appium","slug":"appium","permalink":"http://lomo.space/tags/appium/"},{"name":"wda","slug":"wda","permalink":"http://lomo.space/tags/wda/"}]},{"title":"angularjs之timeout","slug":"angularjs之timeout","date":"2017-08-20T07:51:13.000Z","updated":"2022-01-14T11:40:22.874Z","comments":true,"path":"2017/08/20/angularjs之timeout/","link":"","permalink":"http://lomo.space/2017/08/20/angularjs%E4%B9%8Btimeout/","excerpt":"","text":"AngularJS之$timeout问题需求：用户登录时，如果用户名或密码输入框输入错误，予以相应的错误提示并将错误提示实现类似于jQuery的 fadeOut()效果，几秒后自动消失。 使用 ng-show 或 ng-if 来显示对应错误，这2个ng指令属性默认值为false。 当controller work起来触发了相应的条件时，controller会将对应的 ng-show 或 ng-if 值置为 true, 并给对应的错误信息变量赋值. 过程+结果html部分 1234&lt;p class=&quot;error-info&quot;&gt; &lt;span class=&quot;text-error text-danger&quot; ng-show=&quot;isError&quot;&gt;&#123;&#123;errorInfo&#125;&#125;&lt;/span&gt;&lt;/p&gt; #双大括号在某些条件不友好，可使用 ng-cloak 等参考：http://lomo.space/2016/12/21/angular-study-note/#Angular表达式 js部分 1234567891011121314151617181920var loginAPP = angular.module(&quot;loginApp&quot;, [&#x27;loginModel&#x27;]);loginAPP.controller(&#x27;loginAppController&#x27;, function($scope, $http, loginService) &#123; $scope.loginLdap = function() &#123; var username = $scope.username; var password = $scope.password; //影藏错误信息, 使用setTimeout简单实现fadeOut功能（忽略动画） setTimeout(function() &#123; $scope.isError = false; //$scope.errorInfo = &quot;&quot;; $scope.$apply(); // important !!! &#125;, 3000); &#125; if (username === undefined || password === undefined) &#123; $scope.isError = true; $scope.errorInfo = &quot;用户名/密码不能为空！&quot;; &#125; &#125;;&#125;); 当触发条件后，JS手动修改的model &#123;&#123;isError&#125;&#125; 的值，model被修改后并未通知AngulaJS, 所以ng 不会主动去update view, 需要手动调用 $scope.$apply(); . $scope.$apply() 这种无参形式调用，不推荐！应该将对应的函数作为一个参数传给$apply()，Angular的 $apply()会将传入的参数function包装进 try catch 块儿中，当参数函数抛异常时就能被catch块儿捕获。 修改后： 123 $timeout(function() &#123; $scope.isError = false;&#125;, 2000); 总结：当使用原生JS或其它非AngularJS内置函数&#x2F;方法更新了Model后都需要手动调用 $apply() 以此来通知Angular的 watcher , watcher 被触发后，Angular就会检测scope模型model。 参考：http://blog.csdn.net/dm_vincent/article/details/38705099","categories":[{"name":"program","slug":"program","permalink":"http://lomo.space/categories/program/"}],"tags":[{"name":"js","slug":"js","permalink":"http://lomo.space/tags/js/"},{"name":"angularjs","slug":"angularjs","permalink":"http://lomo.space/tags/angularjs/"}]},{"title":"nodejs链接ldap","slug":"nodejs链接ldap","date":"2017-08-18T02:42:27.000Z","updated":"2022-01-14T11:40:22.885Z","comments":true,"path":"2017/08/18/nodejs链接ldap/","link":"","permalink":"http://lomo.space/2017/08/18/nodejs%E9%93%BE%E6%8E%A5ldap/","excerpt":"","text":"NodeJS 链接LDAP LDAP是一个轻量级的目录访问协议。关于LDAP更多解读，参考:http://www.openldap.org/https://baike.baidu.com/item/LDAP/2875565?fr=aladdin 通过以上，了解基本概念、：DN、basic_dn….. ldap认证过程局域网内用户若需要统LDAP进行认证，则需要对应的应用服务接入LDAP。(假设LDAP服务已建立) 使用 NodeJS 来进行访问LDAP服务器，进行用户基本信息验证和校验。 其中，NodeJS有一个第三分包叫 ldapjs 封装了与ldap进行通信的方法。 12345官方网站：http://ldapjs.org/https://github.com/mcavage/node-ldapjs 通过LDAP验证用户合法性过程： 前端获取用户输入的用户名+密码 将用户名和密码传给后端上层接口 接口做基本校验(如：验证码是否ok等) 上层接口使用具有管理权限的口令进行 bind 操作 （会通过 LDAP 扩展&#x3D;&gt; ldapjs ） bind 操作成功后, 并根据用户名获取该用户的 DN ( search 操作， Search不到该用户返回错误，反之返回该用户的所有信息) 根据第三步获取dn， 加上用户的密码再次进行 bind, LDAP服务器会根据密码是否ok返回结果 接口处理完毕返回对应信息给前端 进行封装123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172// ldap.jsconst ldap = require(&#x27;ldapjs&#x27;);// config文件里配置LDAP相关信息const ldapConfig = require(&#x27;../config/config&#x27;);var ldapAuth = &#123; /** * username: 用户名 * userPassword: 用户输入的密码 * * */ loginAuth: function(username, userPassword) &#123; let client = ldap.createClient(&#123; url: ldapConfig.url &#125;); let options = &#123; filter: &#x27;(sAMAccountName=&#x27; + username + &#x27;)&#x27;, //查询条件过滤器, 查找username该用户节点 scope: &#x27;sub&#x27;, //查询范围 timeLimit: 500 // 超时 &#125;; return new Promise(function(resolve, reject) &#123; client.bind(ldapConfig.adminDn, ldapConfig.adminPwd, function(err, matched) &#123; client.search(ldapConfig.bashDn, options, function(err, res2) &#123; res2.on(&#x27;searchEntry&#x27;, function(entry) &#123; //获取查询的对象 let user = entry.object; //var userText = JSON.stringify(user, null, 2); //console.log(&quot;查询的用户信息如下:\\r\\n&quot; + userText); //获取user DN userDN = user.dn; //校验该用户的密码是否ok client.bind(userDN, userPassword, function(err, res) &#123; if (err) &#123; //console.log(&#x27;验证失败！用户名或密码错误&#x27;); reject(err); &#125; else &#123; //console.log(&quot;验证通过，success！！！&quot; + res); resolve(user); &#125; &#125;); &#125;); res2.on(&#x27;searchReference&#x27;, function(referral) &#123; //console.log(&#x27;referral: &#x27; + referral.uris.join()); &#125;); //查询错误事件 res2.on(&#x27;error&#x27;, function(err) &#123; console.error(&#x27;error: &#x27; + err.message); //unbind操作，必须要做 client.unbind(); &#125;); //查询结束 res2.on(&#x27;end&#x27;, function(result) &#123; //console.log(&#x27;search status: &#x27; + result.status); //unbind操作，必须要做 client.unbind(); &#125;); &#125;); &#125;); &#125;); &#125;&#125;;module.exports = ldapAuth; 1234567891011//config.js&#x27;use strict&#x27;;var ldapConfig = &#123; url: &quot;ldap://xx..xxx:389/&quot;, adminDn: &quot;admin name&quot;, adminPwd: &quot;admin password&quot;, bashDn: &quot;basic DN&quot;&#125;;module.exports = ldapConfig; 注意到，ldap.js组件导出的是一个 ldapAuth 对象， 该对象封装了 loginAuth 方法 且该方法返回的是一个 Promise对象。 那么如何使用呢？ 1234567891011121314var ldapAuth = require(&#x27;../components/ldap&#x27;);var verify = async function() &#123; try &#123; let res = await ldapAuth.loginAuth(&quot;testName&quot;, &quot;testPwd&quot;); //console.log(&quot;======================&quot;); console.log(res); &#125; catch (err) &#123; console.log(&quot;用户名或密码不正确!&quot;); &#125;&#125;;verify(); 测试及结构如下图： POSTMAN 测试： 参考http://www.jb51.net/article/72954.htm async/await https://cnodejs.org/topic/5640b80d3a6aa72c5e0030b6 http://www.ruanyifeng.com/blog/2015/05/async.html http://www.runoob.com/nodejs/nodejs-express-framework.html","categories":[{"name":"study","slug":"study","permalink":"http://lomo.space/categories/study/"}],"tags":[{"name":"ldap","slug":"ldap","permalink":"http://lomo.space/tags/ldap/"},{"name":"nodejs","slug":"nodejs","permalink":"http://lomo.space/tags/nodejs/"}]},{"title":"gogs support ldap","slug":"gogs-support-ldap","date":"2017-08-15T07:50:50.000Z","updated":"2022-01-14T11:40:22.877Z","comments":true,"path":"2017/08/15/gogs-support-ldap/","link":"","permalink":"http://lomo.space/2017/08/15/gogs-support-ldap/","excerpt":"","text":"配置Gog支持LDAP登录认证名称：随意写。 安全协议：选择-&gt; Unencrypted 主机地址：(通常是一个内网IP地址) 主机端口：389(通常是) 绑定DN: 域管理员提供DN（如：&#76;&#x44;&#x41;&#80;&#46;&#x79;&#117;&#x6e;&#x77;&#x65;&#x69;&#x40;&#x78;&#x78;&#120;&#99;&#x6f;&#109;&#112;&#97;&#x6e;&#x79;&#46;&#x63;&#x6f;&#x6d;） 绑定密码：(同上,和上面的对应) 用户搜索基准：（一般为：dc&#x3D;xxx..xx,dc&#x3D;com） 用户搜索基准：(&amp;(objectClass=user)(sAMAccountName=%s)) 管理员过滤规则：不用填 用户名属性：sAMAccountName（和搜索基准里的一致） 名字、姓氏属性都不用填写。。。 邮箱属性：mail 最后2项： 12从 Bind DN 中拉取属性信息该授权认证已经启用 全部勾选☑️。 保存或点击更新认证即可立刻生效。 登录时只需要使用域账号的前缀即可（不用谢@及其后缀）。","categories":[{"name":"study","slug":"study","permalink":"http://lomo.space/categories/study/"}],"tags":[{"name":"git","slug":"git","permalink":"http://lomo.space/tags/git/"},{"name":"gogs","slug":"gogs","permalink":"http://lomo.space/tags/gogs/"},{"name":"ldap","slug":"ldap","permalink":"http://lomo.space/tags/ldap/"}]},{"title":"highcharts plotOptions issue","slug":"highcharts-plotOptions-issue","date":"2017-06-18T07:36:58.000Z","updated":"2022-01-14T11:40:22.878Z","comments":true,"path":"2017/06/18/highcharts-plotOptions-issue/","link":"","permalink":"http://lomo.space/2017/06/18/highcharts-plotOptions-issue/","excerpt":"","text":"highcharts饼图&#x2F;图例文字过长 因为某些原因，highcharts绘制的饼图上显示的文字或图例文字过长导致显示错乱问题。 错误❌截图如下: 图例文字过长 饼图上的显示文字过长 图例文案过长解决 图例控制在 legend 中. 12345678910111213labelFormatter: function () &#123; var legendMsg; legendMsg = &#x27;&lt;a title=&quot;&#x27; + this.name + &#x27;&quot;&gt;&#x27;; if (this.name.length &gt; 5) &#123; legendMsg += (this.name).substring(0, 3); legendMsg += &#x27;...&#x27;; legendMsg += (this.name).substring(this.name.length - 2, this.name.length); &#125; else &#123; legendMsg += this.name; &#125; legendMsg += &#x27;&lt;/a&gt;&#x27;; return legendMsg;&#125; 完整的legend配置 12345678910111213141516171819202122232425var legend = &#123; //图例位置 layout: &#x27;vertical&#x27;, //显示形式，支持水平horizontal和垂直vertical align: &#x27;right&#x27;, //对其方式，默认为center verticalAlign: &#x27;top&#x27;, borderWidth: 0, itemStyle: &#123; &#x27;fontSize&#x27;: &#x27;10px&#x27;, &#x27;font-family&#x27;: &#x27;Microsoft YaHei&#x27; &#125;, useHTML: true, //必须要设为TRUE，默认为FALSE labelFormatter: function () &#123; var legendMsg; legendMsg = &#x27;&lt;a title=&quot;&#x27; + this.name + &#x27;&quot;&gt;&#x27;; if (this.name.length &gt; 5) &#123; legendMsg += (this.name).substring(0, 3); legendMsg += &#x27;...&#x27;; legendMsg += (this.name).substring(this.name.length - 2, this.name.length); &#125; else &#123; legendMsg += this.name; &#125; legendMsg += &#x27;&lt;/a&gt;&#x27;; return legendMsg; &#125;&#125;; 饼图文字过长解决 饼图上显示的数据和文案在 plotOptions 里控制. 123456789formatter: function() &#123; var text; if (this.point.name.length &gt; 3) &#123; text = &#x27;&lt;a title=&quot;&#x27; + this.point.name + &#x27;&quot;&gt;&#x27; + this.point.name.substring(0, 2) + &#x27;&lt;/a&gt;&#x27;; &#125; else &#123; text = this.point.name; &#125; return text + &quot;: &quot; + this.percentage.toFixed(2) + &quot;%&quot;; &#125; 12345678910111213141516171819202122232425262728var plotOptions = &#123; pie: &#123; allowPointSelect: true, cursor: &#x27;pointer&#x27;, dataLabels: &#123; enabled: true, useHTML: true, //必须要添加 maxStaggerLines: 1, //format: &#x27;&lt;b&gt;&#123;point.name&#125;&lt;/b&gt;: &#123;point.percentage:.1f&#125; %&#x27;, style: &#123; color: (Highcharts.theme &amp;&amp; Highcharts.theme.contrastTextColor) || &#x27;black&#x27;, fontFamily: &#x27;Microsoft YaHei&#x27;, fontSize: &#x27;8px&#x27; &#125;, formatter: function () &#123; var text; if (this.point.name.length &gt; 3) &#123; text = &#x27;&lt;a title=&quot;&#x27; + this.point.name + &#x27;&quot;&gt;&#x27; + this.point.name.substring(0, 2) + &#x27;&lt;/a&gt;&#x27;; &#125; else &#123; text = this.point.name; &#125; return text + &quot;: &quot; + this.percentage.toFixed(2) + &quot;%&quot;; &#125; &#125;, showInLegend: true //图例 &#125;&#125;; 参考API： https://api.hcharts.cn/highcharts#legend.labelFormatter https://api.hcharts.cn/highcharts#plotOptions.pie.dataLabels.formatter 附： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102//绘制饼图完整方法angular.module(&#x27;xxModule&#x27;).factory(&#x27;xxxService&#x27;, function()&#123; return &#123; //method xxx... _createPie: function(Title, documentID, arrayData) &#123; var chart = &#123; plotBackgroundColor: null, plotBorderWidth: null, plotShadow: false &#125;; var title = Title; var tooltip = &#123; shared: true, useHTML: true, style: &#123; color: &#x27;orange&#x27;, fontSize: &#x27;8px&#x27;, fontWeight: &#x27;normal&#x27;, fontFamily: &#x27;Microsoft YaHei&#x27; &#125;, pointFormat: &#x27;&#123;series.name&#125;: &lt;b&gt;&#123;point.percentage:.1f&#125;%&lt;/b&gt;&#x27; &#125;; var plotOptions = &#123; pie: &#123; allowPointSelect: true, cursor: &#x27;pointer&#x27;, dataLabels: &#123; enabled: true, useHTML: true, maxStaggerLines: 1, //format: &#x27;&lt;b&gt;&#123;point.name&#125;&lt;/b&gt;: &#123;point.percentage:.1f&#125; %&#x27;, style: &#123; color: (Highcharts.theme &amp;&amp; Highcharts.theme.contrastTextColor) || &#x27;black&#x27;, fontFamily: &#x27;Microsoft YaHei&#x27;, fontSize: &#x27;8px&#x27; &#125;, formatter: function() &#123; var text; if (this.point.name.length &gt; 3) &#123; text = &#x27;&lt;a title=&quot;&#x27; + this.point.name + &#x27;&quot;&gt;&#x27; + this.point.name.substring(0, 2) + &#x27;&lt;/a&gt;&#x27;; &#125; else &#123; text = this.point.name; &#125; return text + &quot;: &quot; + this.percentage.toFixed(2) + &quot;%&quot;; &#125; &#125;, showInLegend: true //图例 &#125; &#125;; var legend = &#123; //图例位置 layout: &#x27;vertical&#x27;, //显示形式，支持水平horizontal和垂直vertical align: &#x27;right&#x27;, //对其方式，默认为center verticalAlign: &#x27;top&#x27;, borderWidth: 0, itemStyle: &#123; &#x27;fontSize&#x27;: &#x27;10px&#x27;, &#x27;font-family&#x27;: &#x27;Microsoft YaHei&#x27; &#125;, useHTML: true, labelFormatter: function() &#123; var legendMsg; legendMsg = &#x27;&lt;a title=&quot;&#x27; + this.name + &#x27;&quot;&gt;&#x27;; if (this.name.length &gt; 5) &#123; legendMsg += (this.name).substring(0, 3); legendMsg += &#x27;...&#x27;; legendMsg += (this.name).substring(this.name.length - 2, this.name.length); &#125; else &#123; legendMsg += this.name; &#125; legendMsg += &#x27;&lt;/a&gt;&#x27;; return legendMsg; &#125; &#125;; var series = [&#123; type: &#x27;pie&#x27;, name: &#x27;百分比: &#x27;, data: arrayData &#125;]; var credits = &#123; enabled: false &#125;; var json = &#123;&#125;; json.chart = chart; json.title = title; json.tooltip = tooltip; json.series = series; json.plotOptions = plotOptions; json.legend = legend; json.credits = credits; $(documentID).highcharts(json); &#125; //method xxxx... &#125;;&#125;);","categories":[{"name":"study","slug":"study","permalink":"http://lomo.space/categories/study/"}],"tags":[{"name":"highcharts","slug":"highcharts","permalink":"http://lomo.space/tags/highcharts/"}]},{"title":"messy code in MySQL on Linux by chinese","slug":"messy-code-in-MySQL-on-Linux-by-chinese","date":"2017-05-17T03:17:06.000Z","updated":"2022-01-14T11:40:22.884Z","comments":true,"path":"2017/05/17/messy-code-in-MySQL-on-Linux-by-chinese/","link":"","permalink":"http://lomo.space/2017/05/17/messy-code-in-MySQL-on-Linux-by-chinese/","excerpt":"","text":"MySQL字符编码问题缘由 本地开发环境下数据库MySQL中插入中英文插入、读取都ok，无论是MySQL控制台下插入、读取还是借助第三方GUI工具都是ok的，但是部署到线上Linux机器后插入MySQL后，查看中文部分是乱码。 1234#development enviromentPHP Version 7.0.15MySQL 5.7.16Apache 2.0 Handler 1234#online environmentPHP Version 7.0.19Apache 2.0 + Nginx 1.10MySQL 5.7.16 问题分析MySQL相关封装 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130#mysqlhelper.class.php&lt;?php/** * * Class mysqlHelper * Author: Lomo * Email: lomo@lomo.space * URL: http://lomo.space * Date: 2017-05 * */ include_once &#x27;sql.interface.php&#x27;;class mysqlHelper implements ISQLHelper&#123; private $host; private $userName; private $passWord; //private $defaultDB; private $conn; /** * SqlHelper constructor. * * @param $host * @param $userName * @param $passWord */ public function __construct($host, $userName, $passWord) &#123; $this-&gt;host = $host; $this-&gt;userName = $userName; $this-&gt;passWord = $passWord; //$this-&gt;dbName = $defaultDB; $this-&gt;conn = new mysqli($this-&gt;host, $this-&gt;userName, $this-&gt;passWord) or die(&quot;Fail to Connect MySQL Server&quot;.mysqli_error()); &#125; /** * @param $db * switch DataBase * @return new $conn */ public function _selectDB($db) &#123; mysqli_select_db($this-&gt;conn, $db); &#125; /** * @param $sql * DQL - 执行SQL查询 * @return object $res * * $res-&gt;num_rows; 返回查询结果集行数 */ public function _query($sql) &#123; return mysqli_query($this-&gt;conn, $sql); &#125; /** * 判断是否查询有结果, 有则返回TRUE,反之FALSE * @param $sql * * @return bool */ public function isExistData($sql) &#123; $result = $this-&gt;_query($sql); if($result-&gt;num_rows &gt;= 1) &#123; return true; &#125;else&#123; return false; &#125; &#125; /** * @param $sql * DQL - 查询并返回关联数组形式的查询结果 * @return array */ public function execute_dql2($sql)&#123; $arr = array(); $i = 0; $res = mysqli_query($this-&gt;conn, $sql) or die(mysqli_error($this-&gt;conn)); while ($row = mysqli_fetch_assoc($res)) &#123; $arr[$i++]=$row; &#125; mysqli_free_result($res); return $arr; &#125; /** * @param $sql * DML - 数据操作 * @return int * 0 //操作失败 * 1 //操作成功, 数据表受到影响 * 2 //操作成功, 但是未修改任何数据 */ public function execute_dml($sql)&#123; $r = mysqli_query($this-&gt;conn, $sql); if(!$r)&#123; return 0; &#125;else&#123; if(mysqli_affected_rows($this-&gt;conn) &gt; 0)&#123; return 1; &#125;else&#123; return 2; &#125; &#125; &#125; /** * close connect */ public function close_connect()&#123; if(!empty($this-&gt;conn))&#123; mysqli_close($this-&gt;conn); &#125; &#125;&#125; 本地run脚本插入读取带有中文的数据一切OK，本地run 链接远程数据库时，插入读取中文相关也ok。当把脚本放在online机器时就产生了乱码问题。 检查MySQL配置文件my.cnf12345678[client]default-character-set=utf8[mysql]default-character-set=utf8[mysqld]collation-server=utf8_unicode_ciinit-connect=&#x27;SET NAMES utf8&#x27;character-set-server=utf8 配置文件ok。 修改链接层字符mysqli_query(&quot;set names utf8&quot;);尝试无果。 Bing搜索🔍查询，有一个PHP针对MySQL连接层字符编码设置 mysqli_set_charset($link, ); [PHP官方推荐使用！] 源码定义： 12345678910# PHP 5 &gt;= 5.0.5, PHP 7/** * Sets the default client character set * @link http://php.net/manual/en/mysqli.set-charset.php * @param mysqli $link A link identifier returned by mysqli_connect() or mysqli_init() * @param string $charset * @return bool */function mysqli_set_charset ($link, $charset) &#123;&#125; 通过在连接层设置字符编码为utf8即可解决。 mysqli_set_charset($this-&gt;conn, &quot;utf8&quot;);。 参考：https://stackoverflow.com/questions/26596294/set-names-vs-mysqli-set-charset-besides-affecting-mysqli-escape-string-are","categories":[{"name":"study","slug":"study","permalink":"http://lomo.space/categories/study/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://lomo.space/tags/PHP/"},{"name":"MySQL","slug":"MySQL","permalink":"http://lomo.space/tags/MySQL/"}]},{"title":"WebDriver maxsize Chrome window","slug":"WebDriver-maxsize-Chrome-window","date":"2017-05-10T03:04:49.000Z","updated":"2022-01-14T11:40:22.872Z","comments":true,"path":"2017/05/10/WebDriver-maxsize-Chrome-window/","link":"","permalink":"http://lomo.space/2017/05/10/WebDriver-maxsize-Chrome-window/","excerpt":"","text":"WebDriver最大化Chrome浏览器窗口问题 升级最新WebDriver，在用Chrome最新版自动化测试时，遇到2个问题，第一个：driver打开浏览器后，Chrome左上角感叹号❗️设置提示不安全操作具体信息： 1Chrome is being controlled by automated test software 第二个问题：浏览器最大化问题。 Solutions问题一、 很好解决： 12345ChromeOptions options = new ChromeOptions();options.addArguments(&quot;disable-infobars=true&quot;);//或//options.addArguments(&quot;disable-infobars&quot;); 问题二、 1234567891011ChromeOptions options = new ChromeOptions();options.addArguments(&quot;test-type&quot;);options.addArguments(&quot;start-maximized&quot;);//options.addArguments(&quot;start-fullscreen&quot;);options.addArguments(&quot;kiosk&quot;);//options.addArguments(&quot;--js-flags=--expose-gc&quot;);//options.addArguments(&quot;--enable-precise-memory-info&quot;);//options.addArguments(&quot;--disable-popup-blocking&quot;);//options.addArguments(&quot;--disable-default-apps&quot;);//options.addArguments(&quot;credentials_enable_service=false&quot;); options.addArguments(&quot;kiosk&quot;); 会完全全屏最大化，导致浏览器的地址栏都看不到(Mac Pro 13 上测试)，前2个选项基本不会使浏览器最大化，driver启动时多大就多大； driver.manage().window().maximize(); 也不会起作用 ！！！ Chrome Driver最新版Chrome Driver 2.29 支持Chrome v56-58. 最新版下载： https://chromedriver.storage.googleapis.com/index.html?path=2.29/ 历史版本支持查询： https://sites.google.com/a/chromium.org/chromedriver/downloads","categories":[{"name":"program","slug":"program","permalink":"http://lomo.space/categories/program/"}],"tags":[{"name":"WebDriver","slug":"WebDriver","permalink":"http://lomo.space/tags/WebDriver/"},{"name":"Chrome","slug":"Chrome","permalink":"http://lomo.space/tags/Chrome/"}]},{"title":"mysql start issue","slug":"mysql-start-issue","date":"2017-04-03T15:39:41.000Z","updated":"2022-01-14T11:40:22.884Z","comments":true,"path":"2017/04/03/mysql-start-issue/","link":"","permalink":"http://lomo.space/2017/04/03/mysql-start-issue/","excerpt":"","text":"MySQL在Mac上无法启动 warning: The &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;data directory is not owned by the ‘mysql’ or ‘_mysql’ user. 如图： 解决办法： sudo chown -R _mysql:wheel /usr/local/mysql/data 重新启动MySQL即可。 链接问题123# use xxDB 时 提示如下:Reading table information for completion of table and column names You can turn off this feature to get a quicker startup with -A 可能数据库存储的数据太大. 在链接时 使用 -A 参数, 禁止预读已存储的大量信息即可 加快访问速度.","categories":[{"name":"study","slug":"study","permalink":"http://lomo.space/categories/study/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://lomo.space/tags/mysql/"}]},{"title":"gulp compress html/css/js","slug":"gulp-compress-html-css-js","date":"2017-04-02T03:09:41.000Z","updated":"2022-01-14T11:40:22.877Z","comments":true,"path":"2017/04/02/gulp-compress-html-css-js/","link":"","permalink":"http://lomo.space/2017/04/02/gulp-compress-html-css-js/","excerpt":"","text":"Gulp使用安装12npm install gulp-cli -gnpm install gulp -D 安装完成后在项目根目录下创建gulpfile.js文件。此文件名不能修改！touch gulpfile.js gulp官方及Gulp插件： https://gulpjs.com/plugins/ 打包压缩示例项目结构根目录结构 123456789101112#&gt; tree -L 1├── README.md├── Temp├── app├── bower.json├── bower_components├── build├── data├── gulpfile.js├── node_modules├── package.json└── reportTemplates 源码目录结构： 12345678910111213141516171819202122# app&gt; tree -L 2├── 404.html├── assets│ ├── css│ ├── images│ └── js #包括：service、controller、directive等。├── demo.html #demo文件，忽略├── editor.html├── favicon.ico├── index.html├── reportdetails.html├── reportdetails_nk.html #无用文件，忽略├── reportlist.html├── vendor #第三方│ ├── css│ ├── fonts│ └── js└── views #ng视图文件 ├── content.html ├── footer.html ├── header_logo.html └── herosection.html gulpfile.js文件📃： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214// =============================================================================// Gulp Task Dependencies// =============================================================================var gulp = require(&#x27;gulp&#x27;);var browserSync = require(&#x27;browser-sync&#x27;); //local servicevar reload = browserSync.create().reload;var clean = require(&#x27;gulp-clean&#x27;); //del filevar rev = require(&#x27;gulp-rev&#x27;); //update version number , md5var revCollector = require(&#x27;gulp-rev-collector&#x27;); // deprecatedvar wiredep = require(&#x27;wiredep&#x27;).stream;/** update lib reference in HTML */var inject = require(&#x27;gulp-inject&#x27;);var series = require(&#x27;stream-series&#x27;);var htmlReplace = require(&#x27;gulp-html-replace&#x27;);/** Compress HTML */var htmlmin = require(&#x27;gulp-htmlmin&#x27;);var gulpRemoveHtml = require(&#x27;gulp-remove-html&#x27;);var removeEmptyLines = require(&#x27;gulp-remove-empty-lines&#x27;);/** Compress CSS */var minify = require(&#x27;gulp-minify-css&#x27;); //deprecatedvar cleanCSS = require(&#x27;gulp-clean-css&#x27;); //compress CSSvar eslint = require(&#x27;gulp-eslint&#x27;); //check jsvar jshint = require(&#x27;gulp-jshint&#x27;);/** Compress JS */var uglify = require(&#x27;gulp-uglify&#x27;); //compress&amp;ugly jsvar rename = require(&#x27;gulp-rename&#x27;); //rename files&#x27; namevar concat = require(&#x27;gulp-concat&#x27;); //merge multi files/** Compress Image */var imagemin = require(&#x27;gulp-imagemin&#x27;); //compress imagevar runSequence = require(&#x27;run-sequence&#x27;);// var gulpSequence = require(&#x27;gulp-sequence&#x27;);/* 解决AngularJS 缩写写法 gulp打包压缩后JS报错问题 */var ngAnnotate = require(&#x27;gulp-ng-annotate&#x27;);// =============================================================================// Gulp Task// =============================================================================var buildBasePath = &#x27;build&#x27;; //build ouput files folder// =======================================================================// Local -- Preview Task, No Compress, No Package, No Mix...// =======================================================================gulp.task(&#x27;cleanTemp&#x27;, function() &#123; return gulp.src(&#x27;./Temp&#x27;, &#123; read: false &#125;) .pipe(clean());&#125;);/** Start Local Server */gulp.task(&#x27;start:local&#x27;, function() &#123; browserSync(&#123; open: true, port: &#x27;9000&#x27;, proxy: &#x27;http://localhost/sites/JDBToolsPlatform/ProcessQualityReport/Temp&#x27;, https: false &#125;); gulp.watch(&#x27;./app/**/*&#x27;, [&#x27;copy:temp&#x27;]); //gulp.watch(&#x27;./Temp/*.html&#x27;).on(&#x27;change&#x27;, reload);&#125;);/** Copy Original Files To Temp */gulp.task(&#x27;copy:temp&#x27;, function() &#123; return gulp.src(&#x27;./app/**/*&#x27;) .pipe(gulp.dest(&#x27;./Temp&#x27;)) .pipe(browserSync.reload(&#123; stream: true &#125;)); //所有文件都会刷新;Todo&#125;);/** 将bower依赖自动注入HTML文件中 */gulp.task(&#x27;bowerInject&#x27;, function() &#123; return gulp.src(&#x27;./app/index.html&#x27;) .pipe(wiredep(&#123; optional: &#x27;configuration&#x27;, goes: &#x27;here&#x27; &#125;)) .pipe(gulp.dest(&#x27;./tmp&#x27;));&#125;);/** 本地测试组合任务 -- 无压缩、带注释 */gulp.task(&#x27;local&#x27;, function() &#123; runSequence(&#x27;cleanTemp&#x27;, &#x27;copy:temp&#x27;, &#x27;start:local&#x27;);&#125;);// =======================================================================// Prod -- Local Preview Task, Compressed, Mixed, md5 ...// =======================================================================/** Clean The Whole build Folder */gulp.task(&#x27;cleanBuild&#x27;, function() &#123; return gulp.src(buildBasePath, &#123; read: false &#125;) .pipe(clean());&#125;);/** Copy Vendor Lib Files To Prod */gulp.task(&#x27;copyVendor2prod&#x27;, function() &#123; return gulp.src(&#x27;./app/vendor/**/*&#x27;) .pipe(gulp.dest(buildBasePath + &#x27;/vendor&#x27;));&#125;);gulp.task(&#x27;copyFavicon&#x27;, function() &#123; return gulp.src(&#x27;./app/favicon.ico&#x27;) .pipe(gulp.dest(buildBasePath));&#125;);/** 压缩HTML(先合并HTML中CSS/JS)*/gulp.task(&#x27;minifyHtml&#x27;, function() &#123; var options = &#123; removeComments: true, //清除HTML注释 collapseWhitespace: true, //压缩HTML为一行 collapseBooleanAttributes: true, //省略布尔属性的值 &lt;input checked=&quot;true&quot;/&gt; ==&gt; &lt;input /&gt; removeEmptyAttributes: true, //删除所有空格作属性值 &lt;input id=&quot;&quot; /&gt; ==&gt; &lt;input /&gt; removeScriptTypeAttributes: true, //删除&lt;script&gt;的type=&quot;text/javascript&quot; removeStyleLinkTypeAttributes: true, //删除&lt;style&gt;和&lt;link&gt;的type=&quot;text/css&quot; minifyJS: true, //压缩页面JS minifyCSS: true //压缩页面CSS &#125;; return gulp.src(buildBasePath + &#x27;/**/*.html&#x27;) .pipe(gulpRemoveHtml()) //清除特定标签 .pipe(removeEmptyLines()) .pipe(removeEmptyLines(&#123; removeComments: true &#125;)) //清除注释 .pipe(htmlmin(options)) .pipe(gulp.dest(buildBasePath)) .pipe(browserSync.reload(&#123; stream: true &#125;));&#125;);/** 压缩CSS */gulp.task(&#x27;minifyCss&#x27;, function() &#123; return gulp.src(&#x27;./app/assets/css/*.css&#x27;) //.pipe(rename(&#123; suffix: &#x27;.min&#x27; &#125;)) .pipe(cleanCSS(&#123; debug: true &#125;, function(details) &#123; console.log(details.name + &#x27;: &#x27; + details.stats.originalSize); console.log(details.name + &#x27;: &#x27; + details.stats.minifiedSize); &#125;)) .pipe(concat(&#x27;bundle.min.css&#x27;)) //合并为一个文件 //.pipe(rev()) //添加md5 .pipe(gulp.dest(buildBasePath + &#x27;/assets/css&#x27;)) .pipe(browserSync.reload(&#123; stream: true &#125;));&#125;);/** 压缩JS */gulp.task(&#x27;minifyjsmd5&#x27;, function() &#123; return gulp.src(&#x27;./app/assets/**/*.js&#x27;) //.pipe(concat(&#x27;bundle.min.js&#x27;)) //合并压缩后的js为一个文件 //.pipe(uglify()) //压缩js到一行 //.pipe(rev()) //文件名加MD5后缀 .pipe(gulp.dest(buildBasePath + &#x27;/assets/&#x27;)) .pipe(browserSync.reload(&#123; stream: true &#125;)); //输出到js目录&#125;);gulp.task(&#x27;minifyJS&#x27;, function() &#123; return gulp.src(&#x27;./app/assets/js/**/*.js&#x27;) .pipe(ngAnnotate()) .pipe(concat(&#x27;bundle.min.js&#x27;)) .pipe(uglify()) .pipe(gulp.dest(buildBasePath + &#x27;/assets/js&#x27;));&#125;);/** 压缩图片 */gulp.task(&#x27;minifyImg&#x27;, function() &#123; return gulp.src(&#x27;./app/assets/images/*&#x27;) .pipe(imagemin()) .pipe(gulp.dest(buildBasePath + &#x27;/assets/images&#x27;)) .pipe(browserSync.reload(&#123; stream: true &#125;));&#125;);/** Start Build Server Preview */gulp.task(&#x27;start:build&#x27;, function() &#123; browserSync(&#123; open: true, port: &#x27;9001&#x27;, proxy: &#x27;http://localhost/sites/JDBToolsPlatform/ProcessQualityReport/&#x27; + buildBasePath, https: false, &#125;);&#125;);/** * 清除HTML中所有CSS JS引用 * &lt;!-- build:css --&gt; * ...... * &lt;!-- endbuild --&gt; * &lt;!-- build:js --&gt; * ...... * &lt;!-- endbuild --&gt; *///var autoInjectHTMLFiles = [&#x27;app/index.html&#x27;, &#x27;app/editor.html&#x27;, &#x27;app/reportdetails.html&#x27;];gulp.task(&#x27;autoInject&#x27;, function() &#123; return gulp.src(&#x27;app/**/*.html&#x27;) .pipe(htmlReplace(&#123; &#x27;css&#x27;: &#x27;./assets/css/bundle.min.css&#x27;, &#x27;js&#x27;: &#x27;./assets/js/bundle.min.js&#x27; &#125;)) .pipe(gulp.dest(buildBasePath));&#125;);gulp.task(&#x27;prod&#x27;, function() &#123; runSequence(&#x27;cleanBuild&#x27;, &#x27;copyVendor2prod&#x27;, &#x27;copyFavicon&#x27;, &#x27;minifyJS&#x27;, &#x27;minifyCss&#x27;, &#x27;minifyImg&#x27;, &#x27;autoInject&#x27;, &#x27;minifyHtml&#x27;, &#x27;start:build&#x27;);&#125;); package.json文件📃： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&#123; &quot;name&quot;: &quot;processqualityreport&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;xxxx质量分析&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot; &#125;, &quot;keywords&quot;: [ &quot;xx1&quot;, &quot;报告&quot;, &quot;分析&quot; ], &quot;author&quot;: &quot;Lomo&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;dependencies&quot;: &#123; &quot;bootstrap&quot;: &quot;^3.3.7&quot;, &quot;bower&quot;: &quot;^1.8.0&quot;, &quot;browser-sync&quot;: &quot;^2.18.8&quot;, &quot;browserify&quot;: &quot;^14.3.0&quot;, &quot;gulp&quot;: &quot;^3.9.1&quot;, &quot;gulp-clean&quot;: &quot;^0.3.2&quot;, &quot;gulp-clean-css&quot;: &quot;^3.0.4&quot;, &quot;gulp-concat&quot;: &quot;^2.6.1&quot;, &quot;gulp-eslint&quot;: &quot;^3.0.0&quot;, &quot;gulp-html-replace&quot;: &quot;^1.6.2&quot;, &quot;gulp-htmlmin&quot;: &quot;^3.0.0&quot;, &quot;gulp-imagemin&quot;: &quot;^3.2.0&quot;, &quot;gulp-jshint&quot;: &quot;^2.0.4&quot;, &quot;gulp-linker&quot;: &quot;^0.1.7&quot;, &quot;gulp-order&quot;: &quot;^1.1.1&quot;, &quot;gulp-remove-empty-lines&quot;: &quot;0.0.8&quot;, &quot;gulp-remove-html&quot;: &quot;^1.3.0&quot;, &quot;gulp-rename&quot;: &quot;^1.2.2&quot;, &quot;gulp-replace&quot;: &quot;^0.5.4&quot;, &quot;gulp-rev&quot;: &quot;^7.1.2&quot;, &quot;gulp-rev-collector&quot;: &quot;^1.0.5&quot;, &quot;gulp-sequence&quot;: &quot;^0.4.6&quot;, &quot;gulp-sync&quot;: &quot;^0.1.4&quot;, &quot;gulp-sync-task&quot;: &quot;^1.0.3&quot;, &quot;gulp-uglify&quot;: &quot;^2.0.0&quot;, &quot;jshint&quot;: &quot;^2.9.4&quot;, &quot;run-sequence&quot;: &quot;^1.2.2&quot;, &quot;wiredep&quot;: &quot;^4.0.0&quot; &#125;, &quot;devDependencies&quot;: &#123; &quot;eslint&quot;: &quot;^3.19.0&quot;, &quot;eslint-config-standard&quot;: &quot;^10.2.1&quot;, &quot;eslint-plugin-angular&quot;: &quot;^2.4.0&quot;, &quot;eslint-plugin-promise&quot;: &quot;^3.5.0&quot;, &quot;eslint-plugin-standard&quot;: &quot;^3.0.1&quot;, &quot;gulp-html-replace&quot;: &quot;^1.6.2&quot;, &quot;gulp-inject&quot;: &quot;^4.2.0&quot;, &quot;gulp-minify-css&quot;: &quot;^1.2.4&quot;, &quot;gulp-ng-annotate&quot;: &quot;^2.0.0&quot;, &quot;gulp-replace&quot;: &quot;^0.5.4&quot;, &quot;stream-series&quot;: &quot;^0.1.1&quot; &#125;&#125; 执行gulp prod产生线上部署所需文件 1234567891011121314151617181920# build/assets&gt; tree -L 2├── css│ └── bundle.min.css├── images│ ├── blog-placeholder-vertical.png│ ├── hero-1.jpg│ ├── hero-4.jpg│ ├── image-in-content-1.jpg│ ├── image-in-content-2.jpg│ ├── jdb-zhifuhuanbifenxi.png│ ├── jdb_blue_logo.png│ ├── jdb_logo.png│ ├── jdb_qa_process_intro--.png│ ├── jdb_qa_process_intro.png│ ├── jdb_qa_process_intro_backup.png│ ├── jdb_qa_process_intro_nk.png│ ├── login-background.jpg│ └── placeholder.png└── js └── bundle.min.js 将自定义的CSS以及JS等压缩混淆并各自合并为一个单独的文件。图片进行一定程度的压缩。","categories":[{"name":"study","slug":"study","permalink":"http://lomo.space/categories/study/"}],"tags":[{"name":"gulp","slug":"gulp","permalink":"http://lomo.space/tags/gulp/"}]},{"title":"git tag","slug":"git-tag","date":"2017-04-01T06:47:31.000Z","updated":"2022-01-14T11:40:22.877Z","comments":true,"path":"2017/04/01/git-tag/","link":"","permalink":"http://lomo.space/2017/04/01/git-tag/","excerpt":"","text":"Git–Tag操作增加12git tag -a tag名 -m &quot;备注信息...&quot; #含附注类型的taggit tag tag名 #tag名通常以版本号命名[简写版] 1git tag #查看所有tag 注: 打tag标签操作, 是在我们commit修改到本地仓库后! 删除删除本地Tag: 1git tag show # show 为tags中的一个 删除远端仓库的Tag: 1234git push origin :refs/tags/show# 或git push lomo :refs/tags/show# lomo 为另一个git远端仓库地址别名 标签推送12git push origin master --tags #推送所有taggit push lomo master -tag tag名 #推送指定的tag到制定的远端仓库","categories":[{"name":"study","slug":"study","permalink":"http://lomo.space/categories/study/"}],"tags":[{"name":"git","slug":"git","permalink":"http://lomo.space/tags/git/"}]},{"title":"two version xcode in osx","slug":"two-version-xcode-in-osx","date":"2017-03-20T15:12:05.000Z","updated":"2022-01-14T11:40:22.887Z","comments":true,"path":"2017/03/20/two-version-xcode-in-osx/","link":"","permalink":"http://lomo.space/2017/03/20/two-version-xcode-in-osx/","excerpt":"","text":"MacOS Sierra系统多版Xcode共存 使用brew安装一些东西比如Nginx时，会提示Xcode版本太低的一些错误导致无法进行，恰好因为appium V1.5.3目前支持的是Xcode8以下，本机安装的是7.3.1版Xcode, 需要更新Xcode到最新版8.3即可. 安装新版Xcode时，备份下旧版本，直接在&#x2F;Applications文件夹下降旧版本的Xcode.app加上后缀备份即可：Xcode731.app Xcode最新按照正常流程更新即可. 安装完毕后，即可轻松切换Xcode版本， 使用xcode-select命令完成 1234567891011121314lomo@LomodeMacBook-Pro:~ % xcode-select -hUsage: xcode-select [options]Print or change the path to the active developer directory. This directorycontrols which tools are used for the Xcode command line tools (for example,xcodebuild) as well as the BSD development commands (such as cc and make).Options: -h, --help print this help message and exit -p, --print-path print the path of the active developer directory -s &lt;path&gt;, --switch &lt;path&gt; set the path for the active developer directory --install open a dialog for installation of the command line developer tools -v, --version print the xcode-select version -r, --reset reset to the default command line tools path 根据-help文件即可切换对应所需的版本。 为了方便，使用alias来一键快速切换开发环境的Xcode版本. 编辑配置文件 vim ~/.zshrc 前提是已安装oh-my-zsh 加入以下alias即可: 12sudo xcode-select -s /Applications/Xcode731.appsudo xcode-select -s /Applications/Xcode.app Done. 这样，就可以根据需要随时切换环境的的Xcode版本.","categories":[{"name":"study","slug":"study","permalink":"http://lomo.space/categories/study/"}],"tags":[{"name":"xcode","slug":"xcode","permalink":"http://lomo.space/tags/xcode/"},{"name":"MacOSX","slug":"MacOSX","permalink":"http://lomo.space/tags/MacOSX/"}]},{"title":"CentOS upgrade Git","slug":"CentOS-upgrade-Git","date":"2017-03-20T03:46:31.000Z","updated":"2022-01-14T11:40:22.869Z","comments":true,"path":"2017/03/20/CentOS-upgrade-Git/","link":"","permalink":"http://lomo.space/2017/03/20/CentOS-upgrade-Git/","excerpt":"","text":"CentOS6.5升级Git[编译方式]卸载旧版git12345git --version# 1.7.X#卸载yum remove git 下载&#x2F;解压源码12345wget https://github.com/git/git/archive/v2.9.2.tar.gz#解压tar zxvf v2.9.2.tar.gzcd git-2.9.2 编译、安装1234make configure./configure --prefix=/usr/local/git --with-iconv=/usr/local/libiconvmake all docsudo make install install-doc install-html make configure产生Makefile文件并进行编译 ./configure --prefix=/usr/local/git 通过configure命令对安装进行控制，将git安装到/usr/local/git目录下。 make all doc 编译生成doc文件 sudo make install install-doc install-html 安装程序文件 环境变量配置12345sudo vim /etc/profileexport PATH=/usr/local/git/bin:$PATHsource /etc/profile # 生效修改 12git --version#git version 2.9.2 如果机器部署了其它需要依赖Git的服务(比如：GitLab、git、gogs等)，升级后，需要重启下服务。本机安装的gogs在升级git后未重启服务进入项目就会提示An error has occurred : exec: &quot;git&quot;: executable file not found in $PATH 错误信息.","categories":[{"name":"write","slug":"write","permalink":"http://lomo.space/categories/write/"}],"tags":[{"name":"git","slug":"git","permalink":"http://lomo.space/tags/git/"}]},{"title":"Nginx+Apache+DiscuzX","slug":"Nginx-Apache-DiscuzX","date":"2017-03-04T11:41:24.000Z","updated":"2022-01-14T11:40:22.872Z","comments":true,"path":"2017/03/04/Nginx-Apache-DiscuzX/","link":"","permalink":"http://lomo.space/2017/03/04/Nginx-Apache-DiscuzX/","excerpt":"","text":"Nginx反向代理PHP应用缘由 在Linux上搭建基于PHP应用discuzX, 由于之前使用的是LAMP+Nginx, Nginx做前端与后端Apache服务的中间层，所以现在搭建的这个PHP应用，使用http:&#x2F;&#x2F;&#x2F;www.xxxxx.com/xxplatform/discuz 去访问时，只有首页可以正常。 当使用http:&#x2F;&#x2F;&#x2F;www.xxxxx.com:8080/xxplatform/discuz , 去访问站点的资源时就正常。 so, 这就是问题，然后解决。 解决方案在Nginx配置文件xxx.conf文件中加入以下配置： 1234location ~ /xxplatform/discuz &#123; proxy_pass http://IP:8080; proxy_set_header Host $host; #必须！&#125; 重启Nginx, nginx -s reload, 刷新服务器查看即可。 proxy_set_header，必须要设置，否则会发现页面中js&#x2F;img&#x2F;csss等很多相对路径的资源的host还是代理之前的。 proxy_set_header, 自定义http消息中的头，然后传送给后端真实的服务器(这里即解释PHP程序的Apache)。 通过这种方式设置后，后端程序获取客户端的地址就永远是Nginx层所在服务器的地址了。 例如： 12$ip = getenv(&quot;REMOTE_ADDR&quot;);echo $ip; 以本环境为例，通过Nginx代理隐藏了Apache的8080端口后，访问：http://domainxxx.com:8080/testip.php, 获取到的IP是来访者的真实IP，这种访问时未经过Nginx层。 http://domainxxx.com/testip.php, 经过Nginx代理后，隐藏了端口，访问经过了Nginx，http发生了变化，此时获取的客户IP是Nginx所在IP。 这段PHP获取来访者用户真实IP地址，在Apache层前未使用Nginx时，可以获得，但是使用Nginx后就获取的是Nginx服务层所在地址。那么如何解决呢？ 后续~~","categories":[{"name":"study","slug":"study","permalink":"http://lomo.space/categories/study/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"http://lomo.space/tags/nginx/"},{"name":"discuzX","slug":"discuzX","permalink":"http://lomo.space/tags/discuzX/"}]},{"title":"get search params","slug":"get-search-params","date":"2017-03-02T09:00:42.000Z","updated":"2022-01-14T11:40:22.877Z","comments":true,"path":"2017/03/02/get-search-params/","link":"","permalink":"http://lomo.space/2017/03/02/get-search-params/","excerpt":"","text":"JS获取URL参数根据key获取对应的value 根据参数key获取其value 1234567891011function getUrlParameter(sParam) &#123; var sPageURL = window.location.search.substring(1); var sURLVariables = sPageURL.split(&#x27;&amp;&#x27;); for (var i = 0; i &lt; sURLVariables.length; i++) &#123; var sParameterName = sURLVariables[i].split(&#x27;=&#x27;); if (sParameterName[0] == sParam) &#123; return decodeURI(sParameterName[1]); &#125; &#125;&#125; e.g. https://www.baidu.com/s?ie=utf-8&amp;f=8&amp;rsv_bp=0&amp;rsv_idx=1&amp;tn=baidu&amp;wd=sfd&amp;rsv_pq=ad648b7a000235a3&amp;rsv_t=7ee4tKobFS9V4lkzlgILOqnqe%2FlzjpSDpgRqQz%2BwScYL5pedH%2F8K431swGM&amp;rqlang=cn&amp;rsv_enter=1&amp;rsv_sug3=4&amp;rsv_sug1=3&amp;rsv_sug7=100&amp;rsv_sug2=0&amp;inputT=470&amp;rsv_sug4=670 getUrlParameter(‘rsv_t’);&#x2F;&#x2F;7ee4tKobFS9V4lkzlgILOqnqe%2FlzjpSDpgRqQz%2BwScYL5pedH%2F8K431swGM getUrlParameter(‘tn’);&#x2F;&#x2F;baidu 序列化URL所有参数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455angular.module(&#x27;utilsModule&#x27;, []).factory(&#x27;utilsService&#x27;, function () &#123; return &#123; isEmptyObject: function(obj) &#123; for (var t in obj) return !1; return !0; &#125;, GetRequestParams: function() &#123; var url = location.search; var theRequest = &#123;&#125;; if (url.indexOf(&quot;?&quot;) != -1) &#123; var str = url.substr(1); strs = str.split(&quot;&amp;&quot;); for (var i = 0; i &lt; strs.length; i++) &#123; theRequest[strs[i].split(&quot;=&quot;)[0]] = (strs[i].split(&quot;=&quot;)[1]); &#125; &#125; console.log(this); if (!this.isEmptyObject(theRequest)) &#123; return theRequest; &#125; else &#123; return false; &#125; &#125;, //用于序列化URL参数，向后端以form形式传递参数 reqParamSerialize: function(obj) &#123; var query = &#x27;&#x27;, name, value, fullSubName, subName, subValue, innerObj, i; for (name in obj) &#123; value = obj[name]; if (value instanceof Array) &#123; for (i = 0; i &lt; value.length; ++i) &#123; subValue = value[i]; fullSubName = name + &#x27;[&#x27; + i + &#x27;]&#x27;; innerObj = &#123;&#125;; innerObj[fullSubName] = subValue; query += param(innerObj) + &#x27;&amp;&#x27;; &#125; &#125; else if (value instanceof Object) &#123; for (subName in value) &#123; subValue = value[subName]; fullSubName = name + &#x27;[&#x27; + subName + &#x27;]&#x27;; innerObj = &#123;&#125;; innerObj[fullSubName] = subValue; query += param(innerObj) + &#x27;&amp;&#x27;; &#125; &#125; else if (value !== undefined &amp;&amp; value !== null) query += encodeURIComponent(name) + &#x27;=&#x27; + encodeURIComponent(value) + &#x27;&amp;&#x27;; &#125; return query.length ? query.substr(0, query.length - 1) : query; &#125; &#125;;&#125;); 此方法定义为一个service，使用时，在对应的模块中注入即可。 如： 1234567angular.module(&#x27;myApp&#x27;, [&#x27;utilsModule&#x27;]).controller(&#x27;myCtrl&#x27;, function($scope, utilsService)&#123; if(utilsService.GetRequestParams()) &#123; //todo ... &#125;&#125;);","categories":[{"name":"program","slug":"program","permalink":"http://lomo.space/categories/program/"}],"tags":[{"name":"js","slug":"js","permalink":"http://lomo.space/tags/js/"}]},{"title":"use tree command list project contents","slug":"use-tree-command-list-project-contents","date":"2017-03-02T02:52:00.000Z","updated":"2022-01-14T11:40:22.888Z","comments":true,"path":"2017/03/02/use-tree-command-list-project-contents/","link":"","permalink":"http://lomo.space/2017/03/02/use-tree-command-list-project-contents/","excerpt":"","text":"OSX使用tree命令列出项目(文件夹树结构)alias方式alias tree=&quot;find . -print | sed -e &#39;s;[^/]*/;|____;g;s;____|; |;g&#39;&quot; 此种方式会遍历目录下的所有文件及其文件夹📂下的文件。 第三方tree命令brew install tree 安装完成后在对应的项目目录或文件夹目录下使用tree的 -L参数指定遍历层级 将tree命令遍历的层级结构导出到readme.md文件中： 12#README.md文件处于输入命令时同级目录下tree -L 2 &gt;README.md 示例： tree -L 2列出当前目录及其下一级目录 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104# &gt;tree -L 2├── 403.html├── 404.html├── 500.html├── AppMessagePush│ ├── App\\ Push.xlsx│ ├── README.md│ ├── apns-dist.pem│ ├── appMsgPush.html│ ├── ck_1019.pem│ ├── resources│ └── send2.php├── AppPerformance│ ├── README.md│ ├── assets│ ├── backup│ ├── data│ ├── demo.html│ ├── index.html│ ├── page-403.html│ ├── page-404.html│ └── page-500.html├── IdCard│ ├── README.md│ ├── assets│ └── index.html├── JDBAPI│ ├── 404.html│ ├── API-xx.json│ ├── API.json│ ├── README.md│ ├── admin-apiCheck.html│ ├── admin-commonParams.html│ ├── admin-form.html│ ├── admin-index.html│ ├── admin-table.html│ ├── adminPanel│ ├── assets│ └── login.html├── ProcessQualityReport│ ├── README.md│ ├── Temp│ ├── app│ ├── bower.json│ ├── bower_components│ ├── build│ ├── data│ ├── gulpfile.js│ ├── node_modules│ ├── package.json│ └── reportTemplates├── ProcessQualityReport_demo│ ├── app│ ├── bower.json│ ├── bower_components│ ├── dist│ ├── gulpfile.js│ ├── node_modules│ ├── package.json│ └── test├── QRCode│ ├── index.html│ └── resources├── api│ ├── appMessagePush│ ├── jenkins│ ├── messageTips│ ├── oAuth│ ├── phpNotice│ ├── processQualityReport│ └── versionNotice├── assets│ ├── css│ ├── image│ └── js├── favicon.ico├── index.html├── messageTips│ ├── README.md│ ├── index.html│ └── resources├── metro│ ├── README.md│ ├── animation│ ├── css│ ├── download.html│ ├── image│ ├── img│ └── js├── oAuth│ ├── README.md│ ├── assets│ ├── index.html│ ├── register.html│ └── test├── robots.txt└── versionNotice ├── index.html ├── node ├── resources ├── simple.json └── simpleTwo.json53 directories, 48 files tree -L 1 123456789101112131415161718192021├── 403.html├── 404.html├── 500.html├── AppMessagePush├── AppPerformance├── IdCard├── JDBAPI├── ProcessQualityReport├── ProcessQualityReport_demo├── QRCode├── api├── assets├── favicon.ico├── index.html├── messageTips├── metro├── oAuth├── robots.txt└── versionNotice13 directories, 6 files","categories":[{"name":"study","slug":"study","permalink":"http://lomo.space/categories/study/"}],"tags":[{"name":"tree","slug":"tree","permalink":"http://lomo.space/tags/tree/"},{"name":"osx","slug":"osx","permalink":"http://lomo.space/tags/osx/"}]},{"title":"add donate and declare for Hexo Blog","slug":"add-donate-and-declare-for-Hexo-Blog","date":"2017-02-19T11:32:04.000Z","updated":"2022-01-14T11:40:22.872Z","comments":true,"path":"2017/02/19/add-donate-and-declare-for-Hexo-Blog/","link":"","permalink":"http://lomo.space/2017/02/19/add-donate-and-declare-for-Hexo-Blog/","excerpt":"","text":"博客增加打赏和版权署名打赏功能 保存支付宝和微信收款二维码图片至themes/使用的主题名/source/img目录下 创建打赏功能模板文件donate.ejs 在themes/主题名/layout/_partial/post 目录下， 注：post目录下的.ejs文件均为博客文章内容的模板文件 donate.ejs 12345678910111213141516171819202122232425262728293031&lt;div class =&quot;post-donate&quot;&gt; &lt;div id=&quot;donate_board&quot; class=&quot;donate_bar center&quot;&gt; &lt;a id=&quot;btn_donate&quot; class=&quot;btn_donate&quot; href=&quot;javascript:;&quot; title=&quot;打赏下Lomo呗&quot;&gt;&lt;/a&gt; &lt;span class=&quot;donate_txt&quot;&gt; ↑&lt;br&gt; &lt;%=theme.donate_message%&gt; &lt;/span&gt; &lt;br&gt; &lt;/div&gt; &lt;div id=&quot;donate_guide&quot; class=&quot;donate_bar center hidden&quot; &gt; &lt;!-- 支付宝打赏图案 --&gt; &lt;img src=&quot;/img/zhifubao.jpg&quot; alt=&quot;支付宝打赏&quot; title=&quot;支付宝扫一扫打赏Lomo&quot;&gt; &lt;!-- 微信打赏图案 --&gt; &lt;img src=&quot;/img/weixin.jpg&quot; alt=&quot;微信打赏&quot; title=&quot;微信扫一扫打赏Lomo&quot;&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; document.getElementById(&#x27;btn_donate&#x27;).onclick = function()&#123; $(&#x27;#donate_board&#x27;).addClass(&#x27;hidden&#x27;); $(&#x27;#donate_guide&#x27;).removeClass(&#x27;hidden&#x27;); &#125; &lt;!-- 鼠标离开打赏区域后自动隐藏二维码 --&gt; var x = document.getElementById(&quot;donate_guide&quot;); x.addEventListener(&quot;mouseleave&quot;, function()&#123; $(&#x27;#donate_board&#x27;).removeClass(&#x27;hidden&#x27;); $(&#x27;#donate_guide&#x27;).addClass(&#x27;hidden&#x27;); &#125;); &lt;/script&gt;&lt;/div&gt; 打赏的主要功能模板文件创建完成. 接下来，创建样式文件. 注：博客主题的全部样式文件存于 /themes/xxxName/source/css/_partial 目录下, 在该目录下创建donate.styl文件，内容容下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950.donate_bar &#123; text-align: center; margin-top: 5%&#125;.donate_bar a.btn_donate &#123; display: inline-block; width: 82px; height: 82px; margin-left: auto; margin-right: auto; background: url(http://img.t.sinajs.cn/t5/style/images/apps_PRF/e_media/btn_reward.gif)no-repeat; -webkit-transition: background 0s; -moz-transition: background 0s; -o-transition: background 0s; -ms-transition: background 0s; transition: background 0s&#125;.donate_bar a.btn_donate:hover &#123; background-position: 0 -82px&#125;.donate_bar .donate_txt &#123; display: block; color: #9d9d9d; font: 14px/2 &quot;Microsoft Yahei&quot;&#125;.donate_bar.hidden&#123; display: none&#125;.post-donate&#123; margin-top: 40px;&#125;#donate_guide&#123; height: 210px; width: 420px; margin: 0 auto;&#125;#donate_guide img&#123; height: 200px; height: 200px;&#125;#donate_guide&gt;img:nth-child(2)&#123; margin-left:35px;&#125; 打赏模板的样式设置完毕，接着，在样式主文件style.styl中引入对该新样式文件的引用： 1@import &#x27;_partial/donate.styl&#x27; 主题配置文件_config.yml文件中设定对该功能模块的控制： /themes/_config.yml文件： 1234#是否开启打赏功能donate: true#打赏文案donate_message: 有收获, 还不错? 求鼓励,求支持! 关于打赏功能的模板文件、样式文件、配置文件, 已全部创建OK，最后一步，在博客文章主题中引入即可。 /thems/xxName/layout/_partial/post 目录下的article.ejs文件的&lt;article标签中: 123&lt;% if (!index &amp;&amp; theme.donate)&#123; %&gt; &lt;%- partial(&#x27;donate&#x27;) %&gt; &lt;% &#125; %&gt; Done. —&gt; Console， 运行gulp 测试查看页面的底部即可看到该功能. 文章版权署名 themes/xxName/layout/_partial/post/目录下创建模板文件declare.ejs，如下： 12345678910&lt;pre&gt; &lt;code&gt; &lt;b&gt; 版权声明&lt;/b&gt;: 本文由&lt;b&gt;&lt;a href=&quot;&lt;%= config.root %&gt;about&quot; target=&quot;_blank&quot; title=&quot;&lt;%= config.author %&gt;&quot;&gt;&lt;%= config.author %&gt;&lt;/a&gt;&lt;/b&gt;创作和发表,采用&lt;b&gt;署名(BY)&lt;/b&gt;-&lt;b&gt;非商业性使用(NC)&lt;/b&gt;-&lt;b&gt;相同方式共享(SA)&lt;/b&gt;国际许可协议进行许可, 转载请注明作者及出处,本文作者为&lt;b&gt;&lt;a href=&quot;&lt;%= config.root %&gt;about&quot; target=&quot;_blank&quot; title=&quot;&lt;%= config.author %&gt;&quot;&gt;&lt;%= config.author %&gt;&lt;/a&gt;&lt;/b&gt;,本文标题为&lt;b&gt;&lt;a href=&quot;&lt;%- config.root %&gt;&lt;%- item.path %&gt;&quot; target=&quot;_blank&quot; title=&quot;&lt;%= item.title %&gt;&quot;&gt;&lt;%= item.title %&gt;&lt;/a&gt;.&lt;/b&gt; &lt;/b&gt; &lt;/code&gt;&lt;/pre&gt; 主题配置文件中_config.yml设定功能控制 1show_declare: true article.ejs文件中引入： 123&lt;% if (theme.show_declare) &#123; %&gt; &lt;%- partial(&#x27;declare&#x27;) %&gt; &lt;% &#125; %&gt; Done. Hexo博客二次开发总结基于Hexo的Blog二次开发，主要是针对博客功能、文章周边的一些开发，比如：可以嵌入的评论、高亮、微博秀、tag等这类使用前纯端技术的功能. 其整个框架，/themes/xxName/layout目录下的都是模板文件，包括页面、页头header、页底footer、小挂件widget… /themes/xxName/source目录下都是资源文件，如：img、css(.styl)、字体font、js库–jQuery等等，一般都是修改这其中的文件或增加文件于其中.","categories":[{"name":"write","slug":"write","permalink":"http://lomo.space/categories/write/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://lomo.space/tags/Hexo/"},{"name":"donate","slug":"donate","permalink":"http://lomo.space/tags/donate/"}]},{"title":"java references type sort","slug":"java-references-type-sort","date":"2017-02-17T08:41:58.000Z","updated":"2022-01-14T11:40:22.881Z","comments":true,"path":"2017/02/17/java-references-type-sort/","link":"","permalink":"http://lomo.space/2017/02/17/java-references-type-sort/","excerpt":"","text":"Java Arrays学习笔记八种基本数据类型: int 、short、float、double、long、byte、boolean、char 除了其中的boolean类型外，对于其它几种定义的Arrays都可以使用自带的.sort()方法进行排序(默认为升序排序). 基本排序.sort()方法E.g.1 123456789101112131415161718192021222324252627282930313233343536package javaClassExercise.arrays;import org.junit.Test;import java.util.Arrays;/** * Created by lomo. */public class arraySortStudy &#123; @Test public void intDataSort() &#123; int[] data = &#123;1,0,99,10,33,67,88,91,9,7,45,12&#125;; Arrays.sort(data); for (int i : data) &#123; System.out.println(i); &#125; &#125; //0 1 7 9 10 12 33 45 67 88 91 99 @Test public void charDataSort() &#123; char[] data = &#123;&#x27;A&#x27;, &#x27;g&#x27;, &#x27;c&#x27;, &#x27;D&#x27;, &#x27;C&#x27;, &#x27;f&#x27;, &#x27;F&#x27;, &#x27;Y&#x27;&#125;; Arrays.sort(data); for (char s : data) &#123; System.out.println(s); &#125; &#125; // A C D F Y c f g&#125; 引用类型一、 referenceTypeSort.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package javaClassExercise.referencesSort;import org.junit.Test;/** * Created by lomo. */public class referenceTypeSort &#123; @Test public void test() &#123; User user = new User(&quot;lomo&quot;, &quot;male&quot;, 25); System.out.println(user.getName() + &quot; Is &quot; +user.getGender()); //lomo Is male &#125;&#125;//User 类class User &#123; private String name; private String gender; private int age; //cmd+n 生成带参的构造函数, new时必须给参数, new完后就可以使用获得对应属性 public User(String name, String gender, int age) &#123; this.name = name; this.gender = gender; this.age = age; &#125; public void setName() &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setGender() &#123; this.gender = gender; &#125; public String getGender() &#123; return gender; &#125; public void setAge() &#123; this.age = age; &#125; public int getAge() &#123; return age; &#125;&#125; 二、 UserComparator类 实现Comparator接口 UserComparator.java 123456789101112131415161718package javaClassExercise.referencesSort;import java.util.Comparator;/** * Created by lomo. *///User类的排序public class UserComparator implements Comparator&lt;User&gt; &#123; @Override public int compare(User o1, User o2) &#123; return o1.getAge() - o2.getAge(); &#125;&#125; 三、 referencesTypeSortTest类 测试 + 测试结果 referencesTypeSortTest.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package javaClassExercise.referencesSort;import org.junit.Test;import java.util.Arrays;/** * Created by lomo on. */public class referencesTypeSortTest &#123; public static void main(String[] args) &#123;// User users = new User(&quot;lomo2&quot;, &quot;female&quot;, 33);// System.out.println(users.getAge()); //33 User[] users = new User[]&#123; new User(&quot;lomo&quot;, &quot;male&quot;, 22), new User(&quot;lomo2&quot;, &quot;female&quot;, 20), new User(&quot;cd&quot;, &quot;gender&quot;, 18)&#125;; Arrays.sort(users, new UserComparator()); for (User user : users) &#123; System.out.println(&quot;姓名：&quot; + user.getName() + &quot; 性别：&quot; + user.getGender() + &quot; 年龄：&quot; + user.getAge()); &#125; /** 输出： 姓名：cd 性别：gender 年龄：18 姓名：lomo2 性别：female 年龄：20 姓名：lomo 性别：male 年龄：22 */ &#125; @Test public void testReferenceTypeSort() &#123; User[] users = new User[]&#123;new User(&quot;name&quot;, &quot;male&quot;, 22), new User(&quot;name2&quot;, &quot;female&quot;, 18)&#125;; Arrays.sort(users, new UserComparator()); for (User user : users) &#123; System.out.println(user.getGender()); &#125; //输出： /** * female male */ for (User user : users) &#123; System.out.println(user.getName()); &#125; //输出: /** * name2 name */ &#125;&#125; Summary 通过对Test测试，发现Arrays.sort排序好像是以其中的年龄进行升序排序，其实不，是因为：UserComparator类的排序方法声明就是以User类中的Age字段进行排序UserComparator类，其实现的是接口：Comparator，该接口中的方法compare声明如下：int compare(T o1, T o2); [接口中的方法默认为：public abstract修饰！]","categories":[{"name":"study","slug":"study","permalink":"http://lomo.space/categories/study/"}],"tags":[{"name":"java","slug":"java","permalink":"http://lomo.space/tags/java/"}]},{"title":"CentOS upgrade PHP TO 7.0","slug":"CentOS-upgrade-PHP-TO-7-0","date":"2017-02-10T03:39:06.000Z","updated":"2022-01-14T11:40:22.869Z","comments":true,"path":"2017/02/10/CentOS-upgrade-PHP-TO-7-0/","link":"","permalink":"http://lomo.space/2017/02/10/CentOS-upgrade-PHP-TO-7-0/","excerpt":"","text":"记录CentOS6.5升级PHP7.0检查系统版本123cat /etc/centos-release# CentOS release 6.5 (Final) 卸载旧版本1234567891011121314yum list installed |grep php php56w.x86_64 5.6.30-1.w6 @webtatic php56w-cli.x86_64 5.6.30-1.w6 @webtatic php56w-common.x86_64 5.6.30-1.w6 @webtatic php56w-gd.x86_64 5.6.30-1.w6 @webtatic php56w-ldap.x86_64 5.6.30-1.w6 @webtatic php56w-mbstring.x86_64 5.6.30-1.w6 @webtatic php56w-mysql.x86_64 5.6.30-1.w6 @webtatic php56w-odbc.x86_64 5.6.30-1.w6 @webtatic php56w-pdo.x86_64 5.6.30-1.w6 @webtatic php56w-soap.x86_64 5.6.30-1.w6 @webtatic php56w-xml.x86_64 5.6.30-1.w6 @webtatic php56w-xmlrpc.x86_64 5.6.30-1.w6 @webtatic 卸载： 1yum remove php56w.x86_64 php56w-cli.x86_64 php56w-common.x86_64 php56w-gd.x86_64 php56w-ldap.x86_64 php56w-mbstring.x86_64 php56w-mysql.x86_64 php56w-odbc.x86_64 php56w-pdo.x86_64 php56w-soap.x86_64 php56w-xml.x86_64 php56w-xmlrpc.x86_64 更新源1234567# CentOS/RHEL 7.x:rpm -Uvh https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpmrpm -Uvh https://mirror.webtatic.com/yum/el7/webtatic-release.rpm#CentOS/RHEL 6.x:rpm -Uvh https://mirror.webtatic.com/yum/el6/latest.rpm 安装1yum install php70w 其它模块[optional] 1yum install php70w-bcmath php70w-dba php70w-devel php70w-embedded php70w-enchant php70w-fpm php70w-gd php70w-imap php70w-interbase php70w-intl php70w-ldap php70w-mbstring php70w-mcrypt php70w-mysql php70w-mysqlnd php70w-odbc php70w-opcache php70w-pdo php70w-pdo_dblib php70w-pear php70w-pecl-apcu php70w-pecl-imagick php70w-pecl-xdebug php70w-pgsql php70w-phpdbg php70w-process php70w-pspell php70w-recode php70w-snmp php70w-soap php70w-tidy php70w-xml php70w-xmlrpc 一次性安装可能有冲突报错，根据所需模块，逐个安装即可。 12345yum install php70w-bcmath #支持大整数计算模块yum install php70w-imapyum install php70w-fpmyum install php70w-ldapyum install php70w-mbstring php70w-mcrypt","categories":[{"name":"write","slug":"write","permalink":"http://lomo.space/categories/write/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://lomo.space/tags/PHP/"}]},{"title":"导航栏多级下拉菜单hover显示","slug":"导航栏多级下拉菜单hover显示","date":"2017-01-27T16:50:46.000Z","updated":"2022-01-14T11:40:22.889Z","comments":true,"path":"2017/01/28/导航栏多级下拉菜单hover显示/","link":"","permalink":"http://lomo.space/2017/01/28/%E5%AF%BC%E8%88%AA%E6%A0%8F%E5%A4%9A%E7%BA%A7%E4%B8%8B%E6%8B%89%E8%8F%9C%E5%8D%95hover%E6%98%BE%E7%A4%BA/","excerpt":"","text":"导航栏多级下拉菜单hover展示 基于Bootstrap的dropdown-menu类实现的下拉菜单默认情况下需要鼠标点击才可以展开显示，显然不符合大部分需求，我们需要的是鼠标悬浮在对应的导航一级或二级或三级标题时，可以自动展示对应的子菜单。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;nav class=&quot;navbar-collapse panel-collapse&quot; id=&quot;navbar-main&quot;&gt; &lt;ul class=&quot;nav navbar-nav navbar-right&quot;&gt; &lt;li class=&quot;dropdown show-on-hover&quot;&gt; &lt;a class=&quot;dropdown-toggle&quot; data-toggle=&quot;dropdown&quot; href=&quot;index.html#&quot;&gt;自助编辑&lt;i class=&quot;fa fa-edit fa-fw&quot;&gt;&lt;/i&gt;&lt;/a&gt; &lt;ul class=&quot;dropdown-menu&quot;&gt; &lt;li class=&quot;dropdown-submenu show-on-hover&quot;&gt; &lt;a class=&quot;dropdown-toggle&quot; data-toggle=&quot;dropdown&quot; href=&quot;destination-parent.html&quot;&gt;Africa&lt;/a&gt; &lt;ul class=&quot;dropdown-menu&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Algeria&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Cape Verde&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li class=&quot;dropdown-submenu show-on-hover&quot;&gt; &lt;a class=&quot;dropdown-toggle&quot; data-toggle=&quot;dropdown&quot; href=&quot;destination-parent.html&quot;&gt;Asia&lt;/a&gt; &lt;ul class=&quot;dropdown-menu&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Bhutan&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Cambodia&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Vietnam&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li class=&quot;divider&quot;&gt;&lt;/li&gt; &lt;li class=&quot;dropdown-submenu show-on-hovered&quot;&gt; &lt;a class=&quot;dropdown-toggle&quot; data-toggle=&quot;dropdown&quot; href=&quot;destination-parent.html&quot;&gt;Canada&lt;/a&gt; &lt;ul class=&quot;dropdown-menu&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Alberta&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Vancouver&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li class=&quot;dropdown-submenu show-on-hover&quot;&gt; &lt;a class=&quot;dropdown-toggle&quot; data-toggle=&quot;dropdown&quot; href=&quot;destination-parent.html&quot;&gt;Central America &lt;/a&gt; &lt;ul class=&quot;dropdown-menu&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Honduras&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Nicaragua&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Panama&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li class=&quot;divider&quot;&gt;&lt;/li&gt; &lt;li class=&quot;dropdown-submenu show-on-hover&quot;&gt; &lt;a class=&quot;dropdown-toggle&quot; data-toggle=&quot;dropdown&quot; href=&quot;destination-parent.html&quot;&gt;Europe&lt;/a&gt; &lt;ul class=&quot;dropdown-menu&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Spain&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Ukraine&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;United Kingdom&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li class=&quot;dropdown-submenu show-on-hover&quot;&gt; &lt;a class=&quot;dropdown-toggle&quot; data-toggle=&quot;dropdown&quot; href=&quot;destination-parent.html&quot;&gt;United States&lt;/a&gt; &lt;ul class=&quot;dropdown-menu&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;New York&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Nevada&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Texas&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li class=&quot;dropdown show-on-hover&quot;&gt; &lt;a class=&quot;dropdown-toggle&quot; data-toggle=&quot;dropdown&quot; href=&quot;index.html#&quot;&gt;内容补充&lt;/a&gt; &lt;ul class=&quot;dropdown-menu&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Adventure &lt;i class=&quot;fa fa-pencil-square fa-fw&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Beaches&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Culture &amp;amp; History&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;权限申请&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Others&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/nav&gt; 默认需要点击才可以展开下拉菜单： JS实现通过本来就引入的库jQuery实现 1234567891011121314151617181920212223242526// ========================================================================= // 展开或收敛导航栏一级下拉菜单按钮 // ========================================================================= //自动展开 $(&#x27;.nav .dropdown&#x27;).mouseenter(function() &#123; console.log(&quot;一级菜单展开了&quot;); $(this).addClass(&#x27;open&#x27;); &#125;); //自动关闭 $(&#x27;.nav .dropdown&#x27;).mouseleave(function() &#123; console.log(&quot;一级菜单离开了&quot;); $(this).removeClass(&#x27;open&#x27;); &#125;); // ========================================================================= // 展开或收敛导航栏二级下拉菜单按钮 // ========================================================================= $(&#x27;.nav .dropdown .dropdown-submenu&#x27;).mouseenter(function() &#123; console.log(&quot;二级菜单dropdown-submenu展开了&quot;); $(this).addClass(&#x27;open&#x27;); &#125;); //自动关闭 $(&#x27;.nav .dropdown .dropdown-submenu&#x27;).mouseleave(function() &#123; console.log(&quot;二级菜单dropdown-submenu离开了&quot;); $(this).removeClass(&#x27;open&#x27;); &#125;); CSS实现1234567891011.navbar .nav&gt;li .dropdown-menu &#123; margin: 0;&#125;.nav.navbar-nav.navbar-right&gt;li:hover&gt;.dropdown-menu &#123; display: block;&#125;.nav.navbar-nav.navbar-right ul.dropdown-menu&gt;li.dropdown-submenu .dropdown-toggle:hover+.dropdown-menu &#123; display: inline-table;&#125;","categories":[{"name":"program","slug":"program","permalink":"http://lomo.space/categories/program/"}],"tags":[{"name":"js","slug":"js","permalink":"http://lomo.space/tags/js/"},{"name":"css","slug":"css","permalink":"http://lomo.space/tags/css/"}]},{"title":"java serialize yaml file","slug":"java-serialize-yaml-file","date":"2017-01-21T15:51:41.000Z","updated":"2022-01-14T11:40:22.881Z","comments":true,"path":"2017/01/21/java-serialize-yaml-file/","link":"","permalink":"http://lomo.space/2017/01/21/java-serialize-yaml-file/","excerpt":"","text":"Java处理yaml文件 yaml文件格式如下: 123--- !dataBean.pc.overduequery.OverdueBeanid: &#x27;default&#x27;mobileNumber: &#x27;15711101521&#x27; DataBean类： DataBean类用来set和get数据，并对外提供public级别访问权限以使可以读写数据 1234567891011121314151617181920212223242526272829303132333435363738394041package dataBean.pc.overduequery;import dataBean.IDataBean;public class OverdueBean implements IDataBean &#123; private String id; private String idCardNo; private String mobileNumber; @Override public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; public String getIdCardNo() &#123; return idCardNo; &#125; public void setIdCardNo(String idCardNo) &#123; this.idCardNo = idCardNo; &#125; public String getMobileNumber() &#123; return mobileNumber; &#125; public void setMobileNumber(String mobileNumber) &#123; this.mobileNumber = mobileNumber; &#125;&#125; 解析 DataFactory.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package dataTool;import dataBean.IDataBean;import dataBean.pc.overduequery.OverdueBean;import org.ho.yaml.Yaml;import java.io.FileNotFoundException;import java.io.InputStream;import java.util.ArrayList;import java.util.List;public class DataFactory &#123; // yaml file&#x27;s path should be same with bean&#x27;s path public static &lt;T&gt; T GetData(Class&lt;T&gt; objectClass) throws FileNotFoundException &#123; String objectClassName = objectClass.getName(); if (null != objectClassName) &#123; objectClassName = objectClassName.replace(&quot;.&quot;, &quot;/&quot;).replace(&quot;dataBean&quot;, &quot;yaml&quot;); &#125; String path = objectClassName + &quot;.yaml&quot;; InputStream inStream = ClassLoader.getSystemResourceAsStream(path); T tObject = Yaml.loadType(inStream, objectClass); return tObject; &#125; public static &lt;IDataBean&gt; List GetDataList(Class&lt;IDataBean&gt; objectClass) &#123; String objectClassName = objectClass.getName(); if (null != objectClassName) &#123; objectClassName = objectClassName.replace(&quot;.&quot;, &quot;/&quot;).replace(&quot;dataBean&quot;, &quot;yaml&quot;); &#125; String path = objectClassName + &quot;.yaml&quot;; InputStream inStream = ClassLoader.getSystemResourceAsStream(path); List&lt;IDataBean&gt; objList = new ArrayList&lt;IDataBean&gt;(); for (Object obj : Yaml.loadStream(inStream)) &#123; objList.add((IDataBean) obj); &#125; return objList; &#125; /** * * @param objectClass * you want to get the bean&#x27;s class object. * @param id * selector for id * @return * @throws Exception */ public static &lt;T extends IDataBean&gt; T getObject(Class&lt;T&gt; objectClass, String id) throws Exception &#123; List&lt;IDataBean&gt; DataList = DataFactory.GetDataList(objectClass); for (IDataBean dataBean : DataList) &#123; if (dataBean.getId().equals(id)) return (T) dataBean; &#125; throw new Exception(&quot;No data by use id in this yaml file!!!!&quot;); &#125; //Test public static void main(String[] args) throws Exception &#123; OverdueBean overdueBean = new OverdueBean(); overdueBean = DataFactory.getObject(OverdueBean.class, &quot;default&quot;); System.out.println(overdueBean.getMobileNumber()); //输出：15711101521 &#125;&#125; yaml文件路径要与其对应的Bean类文件路径一致.","categories":[{"name":"study","slug":"study","permalink":"http://lomo.space/categories/study/"}],"tags":[{"name":"java","slug":"java","permalink":"http://lomo.space/tags/java/"},{"name":"yaml","slug":"yaml","permalink":"http://lomo.space/tags/yaml/"}]},{"title":"Import Maven Project From Eclipse To Idea","slug":"Import-Maven-Project-From-Eclipse-To-Idea","date":"2017-01-14T04:19:24.000Z","updated":"2022-01-14T11:40:22.869Z","comments":true,"path":"2017/01/14/Import-Maven-Project-From-Eclipse-To-Idea/","link":"","permalink":"http://lomo.space/2017/01/14/Import-Maven-Project-From-Eclipse-To-Idea/","excerpt":"","text":"Eclipse Maven项目迁移至IntelliJ IDEA 操作系统： Mac OSX 前置工作 – 安装IDEA通过Brew安装IDEA(one way) 下载安装(通过Brew安装) 1brew cask install intellij-idea 如果未安装Brew管理工具，则： 1ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; &lt; /dev/null 2&gt; /dev/null ; brew install caskroom/cask/brew-cask 2&gt; /dev/null .dmg安装IDEA(another way) 被GitHub DCMA了…. IDEA官网： https://www.jetbrains.com/idea/ Maven工程迁移上述IDEA安装完毕后，即可放心地开始Maven工程迁移至IDEA. 操作步骤： 将eclipse的多个maven项目copy至一个新目录中 打开IntelliJ IDEA编译器，点击菜单 File-&gt;Open, 全选 刚刚的WorkSpace目录几个文件夹 打开后, IDEA并没有自动识别Maven项目，这时候，需要手动在IDEA右侧的Maven Projects栏（如果没显示Maven Projects栏，则依次在IDEA工具栏View -&gt; Tool Windows -&gt; Maven Projects中打开）中添加项目的pom.xml文件，这样IDEA就能识别. 如图： 按照图中红色框框中标示的 绿色+ 加号，一次点击加入工程的pom.xml 即可，IDEA会在后台根据pom自动更新依赖. 后续 如果中央仓库更新后，本地git fetch origin/master, 然后 git merge origin/master后，idea显示某些包飘红，或提示 ‘can not resolve symbol’, 点击idea右侧 Maven Porject，然后点击Reimport All Maven Project 逆时针按钮即可。","categories":[{"name":"study","slug":"study","permalink":"http://lomo.space/categories/study/"}],"tags":[{"name":"java","slug":"java","permalink":"http://lomo.space/tags/java/"},{"name":"maven","slug":"maven","permalink":"http://lomo.space/tags/maven/"},{"name":"idea","slug":"idea","permalink":"http://lomo.space/tags/idea/"}]},{"title":"angular study note","slug":"angular-study-note","date":"2016-12-21T11:55:19.000Z","updated":"2022-01-14T11:40:22.874Z","comments":true,"path":"2016/12/21/angular-study-note/","link":"","permalink":"http://lomo.space/2016/12/21/angular-study-note/","excerpt":"","text":"AngularJS学习笔记第一个示例 1&lt;html ng-app&gt;&lt;/html&gt; 当网页加载完毕，AngularJS 自动开启！！！ ng-app告诉AngularJS来处理引导整个页面应用，一旦使用了ng-app指令在&lt;html&gt;&lt;/html&gt;中，则表示该页面应用属于Angular应用，整个页面控制将交由Angular来控制, 也可以在局部使用。【该标签定义了AngularJS的作用域！】ng-app指令同时标记了AngularJS脚本的作用域！ng-model 指令把元素值（比如输入域的值）绑定到应用程序（控制器的属性）ng-bind 指令把应用程序数据绑定到 HTML 视图 AngularJS 应用解析AngularJS应用程序三大组成部分： 1.模板&#x2F;视图 View：HTML、CSS； AngularJS编译器是完全可扩展 -&gt; 可以给HTML添加新的元素、属性标记，作为AngularJS编译器的指令. 2.控制器Controller 应用程序逻辑、行为：使用JS定义的控制器&#x2F;函数；添加修改属性； AngularJS应用不需要对DOM添加或注册额外的事件监听去操作DOM，它们都被内置在AngularJS中了。 3.模型&#x2F;Model 模型： 视图中的数据；AngularJS通过作用域来保持数据模型与视图界面UI的双向同步 phonecat 学习git checkout -f step-编号number npm start 启动服务 https://docs.angularjs.org/tutorial 基本定义AngularJS 模块（Module） 定义了 AngularJS 应用； AngularJS 控制器（Controller） 用于控制 AngularJS 应用； ng-app指令定义了应用，通常为angular.module()的第一个参数，指定是哪个模块； ng-controller 定义了控制器。 Angular表达式 大括号 当使用expression表达式来输出数据时，为了防止加载过程中页面显示表达式问题，推荐使用ng-bind或ng-cloak 例如： 12&lt;!-- 不推荐写法！！！--&gt;&lt;h3 class=&quot;entry-title&quot;&gt;&#123;&#123;x.title&#125;&#125;&lt;/h3&gt; 改为： 1&lt;h3 class=&quot;entry-title&quot; ng-cloak&gt;&#123;&#123;x.title&#125;&#125;&lt;/h3&gt; 或 123&lt;h3 class=&quot;entry-title&quot; ng-bind=&quot;x.title&quot;&gt;&lt;/h3&gt;&lt;p class=&quot;entry-excerpt&quot; ng-bind=&quot;x.description&quot;&gt;&lt;/p&gt; Angular表达式可以如何使用？类似于 JavaScript 表达式，AngularJS 表达式可以包含字母、操作符、变量； 与 JavaScript 表达式不同，AngularJS 表达式可以写在 HTML 中； 与 JavaScript 表达式不同，AngularJS 表达式支持过滤器； Angular表达式哪些不可用？与 JavaScript 表达式不同，AngularJS 表达式不支持条件判断，循环及异常； Angular指令指令的基本定义angular的指令是用来扩展HTML、为应用添加新功能，还可以自定义指令。 扩展的HTML属性，指令统一格式：前缀为ng- 常见指令、自定义指令及其作用①ng-app 指令：初始化一个AngularJS应用；同时相当于定义了AngularJS应用程序的根元素 ng-app=&quot;xx&quot; 指令：初始化一个名为xx的AngularJS应用； ②ng-init=&quot;xx&quot; 指令，初始化应用程序数据；为应用提供了初始数据 – 初始值. ③ng-show=&quot;xxx表达式&quot; , xxx表达式返回为true时，ng所在的标签则会显示，否则隐藏； ④ng-model=&quot;&quot; 指令，把元素值绑定到应用中(比如输入框中输入的值); AngularJS中的数据双向绑定就是通过该指令实现该指令一般应于有输入功能的元素上 – 表单、输入框、textarea等. 例如： 12&lt;p&gt;姓名：&lt;input type=&quot;text&quot; ng-model=&quot;firstName&quot;&gt;&lt;/p&gt;&lt;p&gt;你输入的为： &#123;&#123; firstName &#125;&#125;&lt;/p&gt; ng-model指令除了可以绑定HTML元素到应用程序，还可以做一些以下工作: 提供应用程序数据类型校验(emial, number, required) 提供应用程序数据状态 (invalid, dirty, error, touched) 为HTML元素提供CSS 类 绑定HTML元素到HTML表单 ⑤ng-model与ng-bind区别: 12345&lt;input ng-model=&quot;expression&quot;&gt;&lt;span ng-bind=&quot;expression&quot;&gt;&lt;/span&gt;&lt;!-- ng-bind另一种写法 --&gt;&lt;span class=&quot;ng-bind: expression&quot;&gt;&lt;/span&gt; ng-bind 是从ng的$scope作用域 &#x3D;&gt; view层的单向数据绑定. 相当于直接在标签内使用表达式&#123;&#123;expression&#125;&#125; ng-model 是从ng作用域$scope &lt;&#x3D;&gt; view层的双向数据绑定. ⑥ng-repeat 指令，克隆、复制元素 ⑦自定义指令 使用.directive 函数添加自定义指令. 调用自定义指令，HTML元素上必须要添加自定义指令名!!! 自定义指令定义规则： 1&gt; 使用驼峰法命名指令 2&gt; HTML中的自定义指令单词之间使用 必须 使用”-“ 分割开来链接 自定义指令调用方式： 1&gt; 通过元素名的方式调用 1&lt;my-directive&gt;&lt;/my-directive&gt; 如： 1234567var app = angular.module(&quot;myApp&quot;, []);//自定义指令myDirectiveapp.directive(&quot;myDirective&quot;, function()&#123; return &#123; template: &quot;&lt;p&gt;自定义啊!&lt;/p&gt;&quot; &#125;;&#125;); &#x3D;&gt;&gt; 完整示例 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;script src=&quot;http://cdn.static.runoob.com/libs/angular.js/1.4.6/angular.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt;&lt;body ng-app=&quot;myApp&quot;&gt;&lt;!-- 指令调用, 通过元素名的方式调用 --&gt;&lt;my-directive&gt;&lt;/my-directive&gt;&lt;script&gt;var app = angular.module(&quot;myApp&quot;, []);app.directive(&quot;myDirective&quot;, function() &#123; return &#123; template: &quot;&lt;p&gt;自定义啊!&lt;/p&gt;&quot; &#125;;&#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 运行后，开发者模式查看Elements： 1234567891011121314&lt;body ng-app=&quot;myApp&quot; class=&quot;ng-scope&quot;&gt;&lt;my-directive&gt;&lt;p&gt;自定义啊!&lt;/p&gt;&lt;/my-directive&gt;&lt;script&gt;var app = angular.module(&quot;myApp&quot;, []);app.directive(&quot;myDirective&quot;, function() &#123; return &#123; template: &quot;&lt;p&gt;自定义啊!&lt;/p&gt;&quot; &#125;;&#125;);&lt;/script&gt;&lt;/body&gt; 2&gt; 通过HTML标签属性的方式调用 1&lt;div my-directive&gt;&lt;/div&gt; 3&gt; 通过类名的方式调用, 通过类名class去调用该指令时, 必须在JS对应的指令中设置restrict值为”C”, 且C必须大写!!! HTML部分 1&lt;div class=&quot;my-directive&quot;&gt;&lt;/div&gt; JS部分 1234567var app = angular.module(&quot;myApp&quot;, []);app.directive(&quot;myDirective&quot;, function() &#123; return &#123; restrict: &quot;C&quot;, //必须要设置！ template: &quot;&lt;p&gt;自定义啊!&lt;/p&gt;&quot; &#125;;&#125;); 4&gt; 通过注释的方式调用, 通过注释方式调用, 必须restrict值为大写M 注释语法和HTML注释语法类似 &lt;!-- directive: 自定义指令名以-分割开链接 --&gt; HTML部分 1&lt;!-- directive: my-directives --&gt; JS部分 1234567app.directive(&quot;myDirectives&quot;, function()&#123; return &#123; restrict: &quot;M&quot;, replace: true, template: &quot;&lt;span&gt;通过注释的方式 调用的&lt;/span&gt;&quot; &#125; &#125;); 上述3&gt;和4&gt;完整示例 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;script src=&quot;http://cdn.static.runoob.com/libs/angular.js/1.4.6/angular.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt;&lt;body ng-app=&quot;myApp&quot;&gt; &lt;div class=&quot;my-directive&quot;&gt;&lt;/div&gt; &lt;!-- directive: my-directives --&gt;&lt;script&gt;var app = angular.module(&quot;myApp&quot;, []);app.directive(&quot;myDirective&quot;, function() &#123; return &#123; restrict: &quot;C&quot;, template: &quot;&lt;p&gt;通过class类名的方式调用的&lt;/p&gt;&quot; &#125;;&#125;); app.directive(&quot;myDirectives&quot;, function()&#123; return &#123; restrict: &quot;M&quot;, replace: true, template: &quot;&lt;span&gt;通过注释的方式 调用的&lt;/span&gt;&quot; &#125; &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 如何选择&#x2F;限制使用、调用指令的方式？在JS中定义相应的指令时，使用restrict字段来限制其调用方式! restrict的值及其含义： ① E作为元素名使用 ② A作为属性使用 ③ C作为类名使用 ④ M作为注释来使用 restrict默认值 EA, 通过元素名和属性名调用 Angular模型ng-model, 该指令用来将输入域的值绑定到angularJS创建的变量中. 即：通过ng-model 指令将输入型的元素(input、select、textarea)和scope中的数据进行绑定. 单向绑定示例: 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;script src=&quot;http://cdn.static.runoob.com/libs/angular.js/1.4.6/angular.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt;&lt;body&gt;&lt;div ng-app=&quot;myApp&quot; ng-controller=&quot;myCtrl&quot;&gt;名字: &lt;input ng-model=&quot;name&quot;&gt;年龄：&lt;input type=&quot;text&quot; ng-model=&quot;age&quot;&gt;&lt;/div&gt;&lt;script&gt;//controller中必须使用$scopeangular.module(&#x27;myApp&#x27;, []).controller(&#x27;myCtrl&#x27;,[&#x27;$scope&#x27;, func]);//将设定的赛到制定的标签中, 也可以请求后台将拿到的数据塞到对应的标签中进而展示、交互function func($scope, $s) &#123; $scope.name = &quot;John Doe1&quot;; $scope.age = 122;&#125;&lt;/script&gt;&lt;p&gt;使用 ng-model 指令来绑定输入域的值到控制器的属性。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 双向绑定 双向绑定，修改输入域的值时，对应的angularJS的属性值也会随之改变 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;script src=&quot;http://cdn.static.runoob.com/libs/angular.js/1.4.6/angular.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt;&lt;body&gt;&lt;div ng-app=&quot;myApp&quot; ng-controller=&quot;myCtrl&quot;&gt;名字: &lt;input ng-model=&quot;name&quot;&gt;&lt;h1&gt;你输入了: &#123;&#123;name&#125;&#125;&lt;/h1&gt;&lt;/div&gt;&lt;script&gt;var app = angular.module(&#x27;myApp&#x27;, []);app.controller(&#x27;myCtrl&#x27;, function($scope) &#123; $scope.name = &quot;lomo&quot;; //设定初始值&#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 双向绑定的使用场景： 使用ng-model简单验证数据有效性(提供数据状态) invalid – 输入是否合法，默认如果无输入值 则为falsedirty – 输入框的默认值是否被改变，改变返回true, 否则返回falsetouched – 点击是否点击，是:返回true, 否则返回false (初次为false,当光标点击输入框后，再离开变为true) 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;script src=&quot;http://cdn.static.runoob.com/libs/angular.js/1.4.6/angular.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt;&lt;body&gt;&lt;form ng-app=&quot;&quot; name=&quot;myForm&quot; ng-init=&quot;myText = &#x27;test@runoob.com&#x27;&quot;&gt;Email: &lt;input type=&quot;email&quot; name=&quot;myAddress&quot; ng-model=&quot;myText&quot; required&gt;&lt;input type=&quot;text&quot; name=&quot;textT&quot; ng-init=&quot;tt=&#x27;init-txt&#x27;&quot; ng-model=&quot;tt&quot; required&gt;&lt;div name=&quot;div&quot; ng-init=&quot;&quot; ng-model=&quot;div1&quot;&gt;Lomo&lt;/div&gt;&lt;p&gt;编辑邮箱地址，查看状态的改变。&lt;/p&gt;&lt;h1&gt;状态&lt;/h1&gt;&lt;p&gt;Valid: &#123;&#123;myForm.myAddress.$valid&#125;&#125; (如果输入的值是合法的则为 true)。&lt;/p&gt;&lt;p&gt;Dirty: &#123;&#123;myForm.myAddress.$dirty&#125;&#125; (如果值改变则为 true)。&lt;/p&gt;&lt;p&gt;Touched: &#123;&#123;myForm.myAddress.$touched&#125;&#125; (如果通过触屏点击则为 true)。&lt;/p&gt; &lt;p&gt;input-valid: &#123;&#123;myForm.textT.$valid&#125;&#125; &lt;/p&gt; &lt;p&gt;div-invalid: &#123;&#123;myForm.div.$dirty&#125;&#125; &lt;/p&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 其中的ng-model 指令必须写入标签中 !!!它能根据表单域的状态自动添加或删除以下类: ng-empty ng-not-empty ng-touched ng-untouched ng-valid ng-invalid ng-dirty ng-pending ng-pristine 通常这些状态值是针对form表单各类输入框组使用。 示例: 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;script src=&quot;http://cdn.static.runoob.com/libs/angular.js/1.4.6/angular.min.js&quot;&gt;&lt;/script&gt; &lt;style&gt;input.ng-invalid &#123; background-color: lightblue;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;form ng-app=&quot;&quot; name=&quot;myForm&quot;&gt; 输入你的名字: &lt;input name=&quot;myName&quot; ng-model=&quot;myText&quot;&gt; &lt;div name=&quot;div&quot; ng-init=&quot;&quot; &gt;Lomo&lt;/div&gt;&lt;/form&gt;&lt;p&gt;编辑文本域，不同状态背景颜色会发送变化。&lt;/p&gt;&lt;p&gt;文本域添加了 required 属性，该值是必须的，如果为空则是不合法的。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; Run之后, 开发者模式查看Elements： 123456&lt;form ng-app=&quot;&quot; name=&quot;myForm&quot; class=&quot;ng-pristine ng-valid ng-scope&quot;&gt; 输入你的名字: &lt;input name=&quot;myName&quot; ng-model=&quot;myText&quot; class=&quot;ng-pristine ng-untouched ng-valid&quot;&gt; &lt;div name=&quot;div&quot; ng-init=&quot;&quot;&gt;Lomo&lt;/div&gt; &lt;div name=&quot;div&quot; ng-init=&quot;&quot; ng-model=&quot;div2&quot; class=&quot;ng-pristine ng-untouched ng-valid&quot;&gt;Lomo&lt;/div&gt;&lt;/form&gt; 观察上述代码, ng-model指令使应用程序初始化完后, 自动为其添加一些对应的class. 默认情况下，在ng-model指令作用下添加三个class类: ng-pristine ng-untouched ng-invalid 修改示例中的Html代码，并给input标签添加required属性, &lt;input name=&quot;myName&quot; ng-model=&quot;myText&quot; required&gt; 再次Run. 然后打开开发者模式查看 123456&lt;form ng-app=&quot;&quot; name=&quot;myForm&quot; class=&quot;ng-pristine ng-scope ng-invalid ng-invalid-required&quot;&gt; 输入你的名字: &lt;input name=&quot;myName&quot; ng-model=&quot;myText&quot; required=&quot;&quot; class=&quot;ng-pristine ng-untouched ng-invalid ng-invalid-required&quot;&gt; &lt;div name=&quot;div&quot; ng-init=&quot;&quot;&gt;Lomo&lt;/div&gt; &lt;div name=&quot;div&quot; ng-init=&quot;&quot; ng-model=&quot;div2&quot; class=&quot;ng-pristine ng-untouched ng-valid&quot;&gt;Lomo&lt;/div&gt;&lt;/form&gt; 观察上述代码, 多了一个required类. 作用域Scope 作用域是在视图HTML和控制器(JS)中间的纽带； Scope是一个JavaScript 模型对象！ 拥有对应的属性和方法, 可以使用在视图和控制器中. Scope使用示例 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;script src=&quot;http://cdn.static.runoob.com/libs/angular.js/1.4.6/angular.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div ng-app=&quot;myApp&quot; ng-controller=&quot;myCtrl&quot;&gt;&lt;h1&gt;&#123;&#123;carname[1].age&#125;&#125;&lt;/h1&gt;&lt;/div&gt;&lt;script&gt;var app = angular.module(&#x27;myApp&#x27;, []);//控制器中添加$scope对象时，视图就可以获得其对应的属性app.controller(&#x27;myCtrl&#x27;, function($scope) &#123; //数组对象carname $scope.carname = [&#123; name: &quot;dc&quot;, age: 11 &#125;,&#123; name: &quot;lo&quot;, age: 12 &#125;];&#125;);&lt;/script&gt;&lt;p&gt;控制器中创建一个属性名 &quot;carname&quot;，对应了视图中使用 &#123;&#123; &#125;&#125; 中的名称。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 示例2: 修改视图的同时, 模型Model和控制器随之的改变 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;script src=&quot;http://cdn.static.runoob.com/libs/angular.js/1.4.6/angular.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div ng-app=&quot;myApp&quot; ng-controller=&quot;myCtrl&quot;&gt; &lt;input ng-model=&quot;name&quot; placeholder=&quot;&quot;&gt; &lt;span&gt;&#123;&#123;name&#125;&#125;&lt;/span&gt; &lt;h2&gt;&#123;&#123;greetings&#125;&#125;&lt;/h2&gt; &lt;button ng-click=&#x27;sayHello()&#x27;&gt;点我&lt;/button&gt; &lt;/div&gt;&lt;script&gt;var app = angular.module(&#x27;myApp&#x27;, []);app.controller(&#x27;myCtrl&#x27;, function($scope) &#123; $scope.name = &quot;&quot;; $scope.sayHello = function() &#123; if($scope.name !== &quot;&quot;) $scope.greetings = &#x27;Hello1 &#x27; + $scope.name + &#x27;!&#x27;; &#125;;&#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Scope作用域$rootScope，每一个AngularJS应用中都有这样第一个根作用域，它可以作用&#x2F;控制在 ng-app 指令包含的所有HTML元素中。即根作用域可以作用于该ng-app下的整个应用. 同时, $rootScope 是各个controller中$scope的桥梁。在$rootScope中定义的值可以再各个controller中使用! 示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;script src=&quot;./lib/angular-1.6.3.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body ng-app=&quot;myApp&quot;&gt; &lt;div ng-controller=&quot;myCtrl&quot;&gt; &lt;h3&gt;姓氏为 &#123;&#123;lastname&#125;&#125; 家族成员:&lt;/h3&gt; &lt;p&gt;第一个控制器&lt;/p&gt; &lt;ul&gt; &lt;li ng-repeat=&quot;x in names&quot;&gt;&#123;&#123;x&#125;&#125; &#123;&#123;lastname&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;!-- 第二个controller --&gt; &lt;div ng-controller=&quot;myCtrl2&quot;&gt; &lt;p&gt;第二个控制器&lt;/p&gt; &lt;ul&gt; &lt;li ng-repeat=&quot;x in names&quot;&gt;&#123;&#123;x&#125;&#125; &#123;&#123;lastname&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;h3&gt;第二个控制器controller：myCtrl2的LastName: &#123;&#123;lastname&#125;&#125;&lt;/h3&gt; &lt;/div&gt; &lt;!--获取rootScope值 --&gt; &lt;p&gt;&#123;&#123;lastname_global&#125;&#125;&lt;/p&gt; &lt;script&gt; var app = angular.module(&#x27;myApp&#x27;, []); app.controller(&#x27;myCtrl&#x27;, function($scope, $rootScope) &#123; $scope.names = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]; $scope.lastname = &quot;scope-lastename&quot;; //&#123;&#123;lastname&#125;&#125;表达式中会优先调用$scope的lastname $rootScope.lastname = &quot;rootScope-Lomo111&quot;; $rootScope.lastname_global = &quot;rootScope-Lomo111&quot;; &#125;); app.controller(&#x27;myCtrl2&#x27;, function($scope, $rootScope) &#123; $scope.names = [&quot;cc&quot;, &quot;dd&quot;, &quot;ee&quot;]; $rootScope.lastname = &quot;rootScope--Lomo222&quot;; //会覆盖上面第一个controller的rootScope //第二个控制器controller：myCtrl2的LastName: Lomo222 $scope.lastname = &quot;scope--Lomo2&quot;; $rootScope.lastname_global = &quot;rootScope-Lomo222&quot;; &#125;); &lt;/script&gt; &lt;p&gt;注意 $rootScope 在循环对象内外都可以访问。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; Run结果： 123456789101112131415161718姓氏为 scope-lastename 家族成员:第一个控制器A scope-lastenameB scope-lastenameC scope-lastename第二个控制器cc scope--Lomo2dd scope--Lomo2ee scope--Lomo2第二个控制器controller：myCtrl2的LastName: scope--Lomo2rootScope-Lomo222注意 $rootScope 在循环对象内外都可以访问。 //说明在此controller里，优先调用本controller中的$scope(而非整个应用的$rootscope) 分析+总结: 根据上述示例：① 在多个controller共存的情况下，在当前控制器里，$rootScope的优先级要低于$Scope优先级[比如，同时定义：$scope.lastname &#x3D; “scope-lastename”; $rootScope.lastname &#x3D; “Lomo111”; 表达式会优先取$scope作用域下的值] ② 若多个控制器中同时定义了$rootScope, 则后定义的$rootScope会覆盖之前的$rootScope的 相同字段值！！！ AngularJS控制器 控制器 – 控制AngularJS应用程序的数据. 控制器也是一个JS对象. 控制器定义使用ng-controller指令定义控制器. 调用AngularJS使用 $scope 对象来调用控制器. 同时, $scope对象是一个应用对象(包含应用的变量属性和函数方法); 控制器的$scope(相当于作用域、控制范围), 用来保存AngularJS Model(模型)的对象。 通常，将controller单写与js文件中. AngularJS过滤器常用过滤器: ①currency，格式化数字为货币格式, 默认为$ ②filter， 从数组项中选出一个子集, 后跟一个冒号和模型名称(test,) ③lowercase，将字符串格式化为小写 ④uppercase，将字符串格式化为答谢 ⑤orderBy，根据某个表达式排列数组, 默认排序以升序排列 ⑥date，格式化日期 ⑦number，保留几位小数位 ⑧limitTo, 截取数字或字符串 过滤器使用使用管道符 | 将过滤器添加到表达式和指令中. 表达式中添加过滤器 将字符转为小写 1234567&lt;p&gt;姓名为 &#123;&#123; lastName | lowercase &#125;&#125;&lt;/p&gt;&#123;&#123; &quot;LOMOO&quot; | lowercase &#125;&#125; // 结果：lomoo&#123;&#123;1490161945000 | date:&quot;yyyy-MM-dd HH:mm:ss&quot;&#125;&#125; //2017-03-22 13:52:25&#123;&#123;14.194000 | number:2&#125;&#125; // 保留两位小数，14.19&#123;&#123; 250.0000 | currency:&quot;RMB ￥&quot; &#125;&#125; //格式化货币单位为人民币，RMB ￥250.00&#123;&#123;&quot;1234567890&quot; | limitTo:-4&#125;&#125; // 从右向左截取7890&#123;&#123;&quot;1234567890&quot; | limitTo:4&#125;&#125; // 从左往右截取 1234 filter 12345// 查找name为iphone的行&#123;&#123; [&#123;&quot;age&quot;: 20,&quot;id&quot;: 10,&quot;name&quot;: &quot;iphone&quot;&#125;,&#123;&quot;age&quot;: 12,&quot;id&quot;: 11,&quot;name&quot;: &quot;sunm xing&quot;&#125;,&#123;&quot;age&quot;: 44,&quot;id&quot;: 12,&quot;name&quot;: &quot;test abc&quot;&#125;] | filter:&#123;&#x27;name&#x27;:&#x27;iphone&#x27;&#125; &#125;&#125; 指令中添加过滤器 按照数组names中的country字段进行生序排序 12345&lt;li ng-repeat=&quot;x in names | orderBy:&#x27;country&#x27;&quot;&gt;&lt;!-- 升序 --&gt;&lt;li ng-repeat=&quot;x in names | orderBy:&#x27;country：true&#x27;&quot;&gt; &lt;!-- 降序排列 --&gt; 过滤输入使用场景，搜索、筛选时. 示例 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;script src=&quot;http://cdn.static.runoob.com/libs/angular.js/1.4.6/angular.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div ng-app=&quot;myApp&quot; ng-controller=&quot;namesCtrl&quot;&gt;&lt;p&gt;输入过滤:&lt;/p&gt;&lt;p&gt;&lt;input type=&quot;text&quot; ng-model=&quot;testText&quot;&gt;&lt;/p&gt;&lt;ul&gt;&lt;!-- 输入过滤/搜索 支持中文 且 不区分大小写--&gt; &lt;li ng-repeat=&quot;x in names | filter:testText | orderBy:&#x27;country&#x27;&quot;&gt; &#123;&#123; (x.name | uppercase) + &#x27;, &#x27; + x.country &#125;&#125; &lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;script &gt; angular.module(&#x27;myApp&#x27;, []).controller(&#x27;namesCtrl&#x27;, function($scope) &#123; $scope.names = [ &#123;name:&#x27;Jani&#x27;,country:&#x27;Norway&#x27;&#125;, &#123;name:&#x27;Hege&#x27;,country:&#x27;Sweden&#x27;&#125;, &#123;name:&#x27;Kai&#x27;,country:&#x27;Denmark&#x27;&#125;, &#123;name:&#x27;lomo&#x27;,country:&#x27;中国&#x27;&#125; ];&#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 自定义过滤器 定义一个字符串反转reverse字符串反转: 1234567//原生JS函数 去反转一个连续的字符串，注意不是一个话！function strReverseOut(str) &#123; var arr = new Array(); arr = str.split(&#x27;&#x27;); //将一个连续的字符串拆分成单个字母存入数组 var temp = arr.reverse(); //数组反转 return temp.join(&quot;&quot;); //将数组再转为字符串&#125; &#x3D;&#x3D;&#x3D;&gt;&gt;&gt; 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;script src=&quot;http://cdn.static.runoob.com/libs/angular.js/1.4.6/angular.min.js&quot;&gt;&lt;/script&gt;&lt;body&gt;&lt;div ng-app=&quot;myApp&quot; ng-controller=&quot;myCtrl&quot;&gt;&lt;!-- ng-model 实现双向绑定，根据输入字符数字实时反转--&gt;&lt;input type=&quot;text&quot; ng-model=&quot;msg&quot;&gt;Output: &#123;&#123; msg | reverse &#125;&#125;&lt;!--输出： Output: dchaomoL --&gt;&lt;/div&gt;&lt;script&gt;var app = angular.module(&#x27;myApp&#x27;, []);app.controller(&#x27;myCtrl&#x27;, function($scope) &#123; $scope.msg = &quot;Lomoahcd&quot;;&#125;);app.filter(&#x27;reverse&#x27;, function() &#123; //可以注入依赖 return function(text) &#123; return text.split(&quot;&quot;).reverse().join(&quot;&quot;); &#125;&#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Angular 服务(Service)使用AngularJS内置的服务(30+个)或自定义服务. 内置Service$location服务，原生JS的window.location 获取当前页面URL 1234var app = angular.module(&#x27;myApp&#x27;, []);app.controller(&#x27;customersCtrl&#x27;, function($scope, $location) &#123; $scope.myUrl = $location.absUrl();&#125;); http请求服务 123456var app = angular.module(&#x27;myApp&#x27;, []);app.controller(&#x27;myCtrl&#x27;, function($scope, $http) &#123; $http.get(&quot;welcome.htm&quot;).then(function (response) &#123; $scope.myWelcome = response.data; &#125;);&#125;); timeout定时服务, 对应原生JS的window.setTimeout 1234567var app = angular.module(&#x27;myApp&#x27;, []);app.controller(&#x27;myCtrl&#x27;, function($scope, $timeout) &#123; $scope.myHeader = &quot;Hello World!&quot;; $timeout(function () &#123; $scope.myHeader = &quot;How are you today?&quot;; &#125;, 2000);&#125;); $interval 服务，原生JS的window.setInterval 实时显示本地时钟 1234567891011121314151617181920var app = angular.module(&#x27;myApp&#x27;, []);app.controller(&#x27;myCtrl&#x27;, function($scope, $interval) &#123; $scope.theTime = new Date().toLocaleTimeString(); //获取当前的本地时刻 $interval(function () &#123; $scope.theTime = new Date().toLocaleTimeString(); //实时显示本地时钟，达到动态时钟显示效果 &#125;, 1000);&#125;);&lt;!-- 不使用 $interval服务的写法--&gt;app.controller(&#x27;myCtrl&#x27;, function($scope) &#123; $scope.theTime = new Date().toLocaleTimeString(); $scope.setTime = function() &#123; // $apply 方法可以修改数据 $scope.$apply(function() &#123; $scope.theTime = new Date().toLocaleTimeString(); &#125;); &#125;; // 使用JS原生的setInterval setInterval($scope.setTime, 1000);&#125;); 自定义Service服务12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;script src=&quot;http://cdn.static.runoob.com/libs/angular.js/1.4.6/angular.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div ng-app=&quot;myApp&quot; ng-controller=&quot;myCtrl&quot;&gt;&lt;p&gt;255 的16进制是:&lt;/p&gt;&lt;h1&gt;&#123;&#123;hex&#125;&#125;&lt;/h1&gt;&lt;/div&gt;&lt;p&gt;自定义服务，用于转换16进制数：&lt;/p&gt;&lt;script&gt;var app = angular.module(&#x27;myApp&#x27;, []);app.service(&#x27;hexafy&#x27;, function() &#123; this.myFunc = function (x) &#123; return x.toString(16); &#125;&#125;);app.controller(&#x27;myCtrl&#x27;, function($scope, hexafy) &#123; $scope.hex = hexafy.myFunc(255);&#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; XMLHttpRequest - $http $http服务用于与后端进行数据交互&#x2F;获取数据然后在UI渲染等. $http服务也是一个JavaScript对象. AngularJS核心服务 $http服务, 可认为相当于JQuery中的Ajax. 基本使用简单的get请求 一般写法: [类似于JQuery中的Ajax写法]12345678$http(&#123; method: &#x27;GET&#x27;, url: &#x27;http://domain.com/path&#x27;&#125;).then(function successCallBack()&#123; //请求成功执行的方法&#125;, function failCallBack()&#123; //请求失败执行的方法&#125; ); 简写法: 常用的GET、POST请求 V1.5版本以下的$http方法success和error方法废弃，直接使用.then 1234$http.get(&#x27;url&#x27;, config).then(successCallBackFn, errorCallBackFn);//data, config与上类似, 都是以字符串或对象形式传递//post请求$http.post(&#x27;url&#x27;, data, config).then(successCallBackFn, errorCallBackFn); 进一步简写: 1234567891011//将请求方式、API、传递的DATA、以及一些请求设置封装到req对象中.var req = &#123; method: &#x27;POST&#x27;, url: &#x27;http://example.com&#x27;, headers: &#123; &#x27;Content-Type&#x27;: undefined &#125;, data: &#123; test: &#x27;test&#x27; &#125;&#125;//V1.5 的.then 方法$http(req).then(function()&#123;...&#125;, function()&#123;...&#125;); 常用请求方法1234567$http.get$http.head$http.post$http.put$http.delete$http.jsonp$http.patch 参考： https://docs.angularjs.org/api/ng/service/$http 下拉框第一种下拉框 使用ng-options指令, 直接写在select标签里 123456789101112&lt;div ng-app=&quot;myApp&quot; ng-controller=&quot;myCtrl&quot;&gt; &lt;select ng-init=&quot;selectedName = names[0]&quot; ng-model=&quot;selectedName&quot; ng-options=&quot;x for x in names&quot;&gt; &lt;/select&gt; &lt;p&gt;选择的是&#123;&#123;selectedName&#125;&#125;&lt;/p&gt;&lt;/div&gt; &lt;script&gt; var app = angular.module(&#x27;myApp&#x27;, []); app.controller(&#x27;myCtrl&#x27;, function($scope) &#123; $scope.names = [&quot;Google&quot;, &quot;Runoob&quot;, &quot;LomoSpace&quot;]; &#125;); &lt;/script&gt; ng-options指令，选择的是一个对象。 当选择的值是对象时，使用ng-options指令就可以进一步获取更多该对象的属性. 运行审查元素: 12345678&lt;div ng-app=&quot;myApp&quot; ng-controller=&quot;myCtrl&quot; class=&quot;ng-scope&quot;&gt; &lt;select ng-init=&quot;selectedName = names[0]&quot; ng-model=&quot;selectedName&quot; ng-options=&quot;x for x in names&quot; class=&quot;ng-pristine ng-untouched ng-valid ng-not-empty&quot;&gt; &lt;option label=&quot;Google&quot; value=&quot;string:Google&quot; selected=&quot;selected&quot;&gt;Google&lt;/option&gt; &lt;option label=&quot;lomo&quot; value=&quot;string:Lomo&quot;&gt;LomoSpace&lt;/option&gt; &lt;option label=&quot;Taobao&quot; value=&quot;string:Taobao&quot;&gt;Taobao&lt;/option&gt; &lt;/select&gt;&lt;/div&gt; 第二种下拉框 使用ng-repeat指令, 直接写在option标签内, 使用ng-repeat指令，循环option标签即可 123&lt;select&gt;&lt;option ng-repeat=&quot;x in names&quot;&gt;&#123;&#123;x&#125;&#125;&lt;/option&gt;&lt;/select&gt; ng-repeat指令，通过数组来循环HTML代码创建下拉列表。 ng-repeat指令，选择的是字符串. 获取select下拉框选中的值 通过在select标签绑定ng-model指令 获取即可. 使用场景通常，使用第一种ng-options的方式。 表格和上面的下拉框方式2相似，也可以使用ng-repeat指令循环创建html达到创建表格的目的. 表达式中常用一些 选择器 : 12345678 &lt;ul&gt; &lt;li&gt;$index：遍历的进度,下标/序号（0...length-1）。 &lt;/li&gt; &lt;li&gt;$first：当元素是遍历的 第一个 时值为true。&lt;/li&gt; &lt;li&gt;$middle：当元素处于 第一个和后元素之间时值为true。 &lt;/li&gt; &lt;li&gt;$last：当元素是遍历的 后一个时值为true。 &lt;/li&gt; &lt;li&gt;$even：当$index值是 偶数 时值为true。[0为偶数] &lt;/li&gt; &lt;li&gt;$odd：当$index值是 奇数 时值为true。 &lt;/li&gt;&lt;/ul&gt; AngularJS 指令之操作HTML DOM属性ng-disabled 指令, 通常该指令的值绑定到具体的ng-model上，如： 12345&lt;div ng-app=&quot;&quot; ng-init=&quot;mySwitch=true&quot;&gt;// ...&lt;input ng-disabled=&quot;mySwitch&quot; value=&quot;点!&quot; &gt;&lt;!--点击下面的复选框后，上面的输入框属性随之改变，默认为禁用(true) 也就是当点击复选框后，ng-model的值从true变为false，使得上面输入框的disabled属性从true变为false--&gt;&lt;input type=&quot;checkbox&quot; ng-model=&quot;mySwitch&quot;/&gt;按钮 ng-show 指令, 用来显示或隐藏 HTML 元素. 123&lt;p ng-show=&quot;true&quot;&gt;可见的。&lt;/p&gt;&lt;p ng-show=&quot;false&quot;&gt;不可见的。&lt;/p&gt; AngularJS 事件点击事件： ng-click 指令; 隐藏元素： ng-hide 指令; 显示元素：ng-show 指令; AngularJS 模块前言AngularJS是纯客户端技术，完全使用JavaScript编写。其大大简化应用开发(尤其单页应用)，将一些常规操作封装，直接调用即可，减少重复性、低级质量的代码。包括：DOM操作、事件监听、输入验证等。 同时，带来了更多其它技术： 数据、业务逻辑、视图分离； 数据与视图的绑定； 通用类服务，如$http 依赖注入 可扩展的HTML … 大部分面向对象应用程序，例如C、C++、Java等程序中，都有一个 主方法用来实例化、组织、启动应用 . 在AngularJS应用里没有这样的主方法，而是使用模块来声明应用如何启动. 模块化特点： 声明式的启动过程，易读、易懂 有助于单元测试，无需加载全部模块 可以以任何先后或者并行的顺序加载(模块的执行本身是延迟的) 概述模块定义了一个应用程序，同时，模块是应用程序中各个不同部分的容器； 同时模块也是应用控制器的容器(controller控制器的操作需要依赖所对应的具体module)； 模块module和控制器controller可以分开写入不同的.js文件,， 然后使用script标签安装顺序引入即可。 1var app = anguler.module(&quot;my-app&quot;, []); 关于module里的中括号[], 其表示该模块所需要的依赖，[]中的参数用来定义模块的依赖关系，若没有依赖，则为空[]；如果有，则写入依赖模块的名字. 通常在JavaScript中要避免使用全局函数，容易被其它脚本文件覆盖。而angularJS中的模块让所有函数、变量的作用域都在自己对应的模块下，避免了此问题。 一般web应用对JS的加载都在body元素最底部，angularJS的加载 通常加载在head标签，因为angular.module的调用只能在angularJS库加载完后才能进行，所以可以将AngularJS库的加载位置放在ng-app所在的标签之前、body标签之中。 模块化–AngularJS表单输入控件集合。 HTML表单通常与HTML控件同在。 123&lt;form novalidate&gt;&lt;/form&gt;//novalidate 属性是在 HTML5 中新增的。禁用了使用浏览器的默认验证. 表单输入验证基本验证方法： 属性 说明 $dirty 表单有填写记录 $valid 字段内容合法的 $invalid 字段内容是非法的 $pristine 表单没有填写记录 123456&lt;p&gt;用户名:&lt;br&gt; &lt;input type=&quot;text&quot; name=&quot;user&quot; ng-model=&quot;user&quot; required&gt; &lt;span style=&quot;color:red&quot; ng-show=&quot;myForm.user.$dirty &amp;&amp; myForm.user.$invalid&quot;&gt; &lt;span ng-show=&quot;myForm.user.$error.required&quot;&gt;用户名是必须的。&lt;/span&gt; &lt;/span&gt;&lt;/p&gt; AngularJS API全局API用来执行常见的JavaScript函数集合。如：比较、迭代、转换对象。 全局API使用angular对象来访问. 通用API函数： API 描述 angular.lowercase() 将字符串转换为小写 angular.uppercase() 转换字符串为大写 angular.isString() 判断给的对象是否为字符串，是 返回true angular.isNumber() 判断给定的对象是否为数字，是 返回true AngularJS Bootstrap在AngularJS中使用Twitter的BootStrap UI框架与其它方式相同，直接引入，调用对应的类即可。 1&lt;link rel=&quot;stylesheet&quot; href=&quot;//maxcdn.bootstrapcdn.com/bootstrap/3.3.4/css/bootstrap.min.css&quot;&gt; HTML包含HTMLAngularJS应用中，可以在HTML中包含HTML文件.(传统的HTML中不能包含HTML文件) 大多数的服务端脚本语言都支持文件包含，如PHP 1&lt;?php require(&quot;xxx.php&quot;); ?&gt; 客户端包含: 通过ng-include指令来包含HTML文件, 该指令除了可以包含HTML文件外，还可以包含AngularJS代码。 如： 123&lt;body ng-app=&quot;&quot;&gt; &lt;div ng-include=&quot;&#x27;lomo.html&#x27;&quot;&gt;&lt;/div&gt;&lt;/body&gt; 1234//lomo.html&lt;h3&gt;head3&lt;/h3&gt;&lt;p&gt;。。。&lt;/p&gt;&lt;div&gt;&lt;span&gt;....&lt;/span&gt;&lt;/div&gt; 默认，ng-include指令不允许包含跨域的文件(包括统一顶级域下的二级三级域)，如果需要包含其他域的文件，需要设置域名访问白名单.某些情况下还要再设置服务器端允许跨域请求。 12345678910111213&lt;body ng-app=&quot;myApp&quot;&gt;&lt;div ng-include=&quot;&#x27;http://c.domain.com/xxx/xx.php&#x27;&quot;&gt;&lt;/div&gt;&lt;script&gt;var app = angular.module(&#x27;myApp&#x27;, [])app.config(function($sceDelegateProvider) &#123; $sceDelegateProvider.resourceUrlWhitelist([ &#x27;http://c.domain.com/xxx/**&#x27; ]);&#125;);&lt;/script&gt; &lt;/body&gt; AngularJS 动画AngularJS使用动画需要引入angular-animate.min.js 库配合CSS使用。 当已定义了ng-app的应用名称时，需要将ngAnimate写入module的依赖模型数组中括号[]里。 1var app = angular.module(&#x27;myApp&#x27;, [&#x27;ngAnimate&#x27;]); ngAnimate的作用：添加、移除class; 监听事件，类似于显示、隐藏HTML元素； AngularJS 添加&#x2F;移除 class 的指令: 12345678ng-showng-hideng-classng-viewng-includeng-repeatng-ifng-switch ng-show 和 ng-hide 指令用于添加或移除 ng-hide class 的值 在动画完成后，HTML 元素的类集合将被移除, 如 ng-hide 指令会添加一下类(在操作的那一瞬间动态加入class值，在动画完成后，再去掉这些class值) ng-animateng-hide-animateng-hide-add (如果元素将被隐藏)ng-hide-remove (如果元素将显示)ng-hide-add-active (如果元素将隐藏)ng-hide-remove-active (如果元素将显示) AngularJS依赖注入基本概念依赖注入(Dependency Injection), 是一种设计模式。 在这种模式里，一个或多个依赖(或服务) 被注入(或者通过引用传递)到一个独立的对象(或客户端)中，然后成为该对象(客户端)的一部分。 这种模式，使得客户端脱离了 对本身行为创建的依赖性。 核心注入组件AngularJS提供了以下组件用来作为注入依赖： value factory service provider constant value注入组件 value是一个简单的JavaScript对象，用来向控制器controller传递值. e.g. 12345678910//模块定义var app = angular.module(&quot;myApp&quot;, []);//创建value对象defaultValue并传递值 &#x27;lomo&#x27;app.value(&quot;defaultValue&quot;, &quot;lomo&quot;);//将 defaultValue 注入到控制器app.controller(&quot;myCtrl&quot;, function($scope, xxService, defaultValue)&#123; //...&#125;); factory注入组件 factory是一个函数，用来返回值。 e.g. 1234567891011121314151617181920var app = angular.module(&quot;myApp&quot;, []);app.factory(&quot;calcService&quot;, function()&#123; var factory = &#123;&#125;; factory.calc = function(a, b)&#123; return a*b; &#125;; return factory;&#125;);//注入factory 的calcService方法, 利用factory方法获得另一个service方法cal2app.service(&quot;myService&quot;, function(calcService)&#123; this.cal2 = function(x)&#123; return calcService.calc(x, x); &#125;;&#125;);app.controller(&quot;myCtrl&quot;, function($scope, &quot;myService&quot;)&#123; //...&#125;); provider注入组件 通过provider创建一个service、factory，provider中提供了一个factory方法get(), 用来返回value&#x2F;service&#x2F;factory。 e.g. 123456789101112131415var app = angular.module(&quot;myApp&quot;, []);app.config(function($provide)&#123; $provide.provider(&quot;calcService&quot;, function()&#123; this.$get = function()&#123; var factory = &#123;&#125;; factory.calc = function(x, y) &#123; return x*y; &#125; return factory; &#125;; &#125;);&#125;);//... constant注入组件 constant(常量)用来在配置阶段传递数值，注意这个常量在配置阶段是不可用的。 1app.constant(&quot;Config Param&quot;, &quot;Constant Value&quot;); 完整示例: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Injection Test&lt;/title&gt; &lt;script src=&quot;./lib/angular-1.6.3.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;h4&gt;Injection Test&lt;/h4&gt; &lt;div ng-app=&quot;myApp&quot; ng-controller=&quot;myCtrl&quot;&gt; &lt;span&gt;输入数字: &lt;/span&gt;&lt;input type=&quot;number&quot; ng-model=&quot;number&quot;&gt; &lt;button ng-click=&quot;getValue()&quot; value=&quot;计算&quot;&gt;计算&lt;/button&gt; &lt;div&gt; &lt;p&gt;default 计算结果: &#123;&#123;result1&#125;&#125;&lt;/p&gt; &lt;p&gt;input 输入为：&#123;&#123;number&#125;&#125;， 计算结果: &#123;&#123;result&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; //定义模块 var app = angular.module(&quot;myApp&quot;, []); //创建factory的CalcuatorFactory app.factory(&quot;CalcuatorFactory&quot;, function() &#123; var calcuatorFactory = &#123;&#125;; calcuatorFactory.calcFactory = function(a, b) &#123; return a * b; &#125; return calcuatorFactory; &#125;); //配置 facotry对象方法 app.config(function($provide) &#123; $provide.provider(&quot;CalcuatorFactory&quot;, function() &#123; this.$get = function() &#123; var factorya = &#123;&#125;; factorya.calcFactory = function(a, b) &#123; //config注入组件里的factory对象的属性calcFactory必须和通过provider传入的对象CalcuatorFactory的属性名相同。 return a * b; &#125;; return factorya; &#125;; &#125;); &#125;); //设定初始值 app.value(&quot;defaultValue&quot;, 10); //自定义service服务：calculatorService app.service(&quot;calculatorService&quot;, function(CalcuatorFactory) &#123; this.calcService = function(x) &#123; return CalcuatorFactory.calcFactory(x, x); &#125;; &#125;); app.controller(&quot;myCtrl&quot;, function($scope, calculatorService, defaultValue) &#123; $scope.number = defaultValue; $scope.result1 = calculatorService.calcService($scope.number); $scope.getValue = function() &#123; //console.log(123); //console.debug($scope.number); $scope.result = calculatorService.calcService($scope.number); &#125;; &#125;); //依赖注入的顺序? //创建factory注入的service，然后将factory的service注入到config默认配置中，初始值设定，自定义service对象服务，最后在controller直接调用自定义的service即可。 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; AngularJS 路由通过路由机制达到根据不同的URL来浏览不同的内容、页面。 在单页web应用中，angularJS通过 #+标记符 来标记实现达到不同页面。 1234http://domain.com/#onehttp://domain.com/#lmoahttp://domain.com/#threehttp://domain.com/#lomo 点击请求时，向服务器请求的都是#之前的，#之后的内容会被浏览器会忽略掉。所以我们就需要在客户端实现 # 号后面内容的功能实现。 AngularJS 路由机制 就是通过 # + 标记 帮助我们区分不同的逻辑页面并将不同的页面绑定到对应的控制器上。 示例: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Route Test&lt;/title&gt; &lt;script src=&quot;http://cdn.static.runoob.com/libs/angular.js/1.4.6/angular.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://apps.bdimg.com/libs/angular-route/1.3.13/angular-route.js&quot;&gt;&lt;/script&gt; &lt;!-- 版本问题 &lt;script src=&quot;./lib/angular-1.6.3.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;//cdn.bootcss.com/angular.js/1.6.3/angular-route.min.js&quot;&gt;&lt;/script&gt; --&gt;&lt;/head&gt;&lt;body ng-app=&quot;myApp&quot;&gt; &lt;div&gt; &lt;h3&gt;Route T&lt;/h3&gt; &lt;ul&gt; &lt;li&gt; &lt;a href=&quot;#/&quot;&gt;HOME&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#/first&quot;&gt;第一页&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#/lomo&quot;&gt;LOMO页&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#/lomo1&quot;&gt;lomo1页&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#/lomo122&quot;&gt;lomo123-other页&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;div ng-view&gt;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; angular.module(&quot;myApp&quot;, [&#x27;ngRoute&#x27;]).config([&#x27;$routeProvider&#x27;, function($routeProvider) &#123; $routeProvider.when(&#x27;/&#x27;, &#123; template: &quot;这是首页 -- HOME Page 呀哈!&quot; &#125;).when(&#x27;/first&#x27;, &#123; template: &#x27;这是第一个页面！&#x27; &#125;).when(&#x27;/lomo&#x27;, &#123; template: &#x27;这是LOMO页面！&#x27; &#125;).when(&#x27;/lomo1&#x27;, &#123; template: &#x27;这是lomo1 页面！&#x27; &#125;).otherwise(&#123; redirectTo: &#x27;/&#x27; &#125;); &#125;]); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 通常不适用自带的ngRouter，因为它只支持一个页面只允许一个视图ng-view，而使用ui-router,参考：http://www.jianshu.com/p/35c0acdea86c","categories":[{"name":"study","slug":"study","permalink":"http://lomo.space/categories/study/"}],"tags":[{"name":"js","slug":"js","permalink":"http://lomo.space/tags/js/"},{"name":"angularjs","slug":"angularjs","permalink":"http://lomo.space/tags/angularjs/"}]},{"title":"CentOS 6.5 安装FTP","slug":"centos-install-ftp","date":"2016-12-21T04:33:02.000Z","updated":"2022-01-14T11:40:22.875Z","comments":true,"path":"2016/12/21/centos-install-ftp/","link":"","permalink":"http://lomo.space/2016/12/21/centos-install-ftp/","excerpt":"","text":"记录下在CentOS 6.5上安装FTP的过程及其注意事项. Install FTP123456789$ yum -y install ftp vsftpd #yum安装ftp vsftpd$ rpm -qa|grep ftp #检查是否安装成功$ chkconfig vsftpd on #设其为开机启动$ rpm -qc vsftpd #查看配置文件所在路径$ vi /etc/sysconfig/iptables #修改防火墙## -A INPUT -p tcp -m state --state NEW -m tcp --dport 21 -j ACCEPT## 添加该记录到iptables文件.## esc -&gt; wq -&gt; enter回车保存退出.$ service vsftpd restart #更新FTP服务 匿名用户处理禁止其登陆. vi /etc/vsftpd/vsftpd.conf (INSERT)anonymous_enable=YES 改为 anonymous_enable=NO 保存退出. 添加远程登录用户例如： 在root组中加入一个htmler账户用来ftp到&#x2F;var&#x2F;www&#x2F;html并给它添加密码 1234-&gt;useradd -g root -M -d /var/www/html -s /sbin/nologin lomo-&gt;passwd lomo-&gt;输入密码 重启服务，service vsftpd restart, 即可远程访问FTP资源.URL like： ftp://lomo.space 或 ftp://127.0.0.1 常用命令123启动vsftpd: service vsftpd start停止vsftpd: service vsftpd stop重启vsftpd: service vsftpd restart 常见问题 上传文件：553 Could not create file？ 解决方案： getsebool -a|grep ftp 查看： ftpd_disable_trans ftp_home_dir allow_ftpd_full_access 是否为on, 不是则修改为on. 其它修改： setsebool allow_ftpd_full_access 1 setsebool allow_ftpd_use_cifs 1 setsebool allow_ftpd_use_nfs 1 setsebool ftp_home_dir 1 setsebool httpd_enable_ftp_server 1 setsebool tftp_anon_write 1 最后： service vsftpd restart查看修改是否生效： getsebool -a|grep ftp若还是Fail,则vi /etc/vsftpd/vsftpd.conf 添加：local_root=/data kill -9 +进程ID，杀死进程，重启服务. getsebool: SELinux is disabled ？vi /etc/selinux/configSELINUX=1reboot Reference: http://www.111cn.net/sys/linux/45542.htm","categories":[{"name":"study","slug":"study","permalink":"http://lomo.space/categories/study/"}],"tags":[{"name":"CentOS","slug":"CentOS","permalink":"http://lomo.space/tags/CentOS/"},{"name":"FTP","slug":"FTP","permalink":"http://lomo.space/tags/FTP/"}]},{"title":"understand java reflect by one example","slug":"understand-java-reflect-by-one-example","date":"2016-12-20T15:16:46.000Z","updated":"2022-01-14T11:40:22.887Z","comments":true,"path":"2016/12/20/understand-java-reflect-by-one-example/","link":"","permalink":"http://lomo.space/2016/12/20/understand-java-reflect-by-one-example/","excerpt":"","text":"简析Java反射 通过一个简单的实例，来理解Java反射。 前言-类型类(关于getClass&#x2F;.class)在Java中，一切都是对象，就像JavaScript一样，一切都是对象。所以我们所使用的对象都直接、或间接地继承自Object类。 Object类中包含一个名为getClass的方法，利用这个方法可以获得一个实例(对象)的类型类。 类型类：就是指 代表一个类型的类，一切皆是对象，所以类型也是对象、不例外，Java中使用这种称为类型类的东东来表示一个类型。 而所有的类型类都是Class类的实例! 可看后面实例部分里的Demo2 e.g.1 12345678//假设A类已声明A a = new A();if(a.getClass() == A.class) &#123; System.out.println(&quot;OK!&quot;);&#125;else &#123; System.out.println(&quot;Not OK !&quot;);&#125;//输出：OK! 分析，对象a是类A的一个实例，A是一个已声明的类，使用.getClass() 返回的正是A的 类型类，Java中表示一个特定类型的 类型类 可以使用类型.class方式获得a.getClass()返回的是A的类型类也就是A.class， 所以输出上述结果。 查看.getClass()方法源码，看到如下，调用的是一个native方法。 1public final native Class&lt;?&gt; getClass(); 再假设，如果A类是B类的子类，又有如下示例2 e.g.2 1234567A a = new A();if(a.getClass == B.class)&#123; System.out.println(&quot;OK!&quot;);&#125;else &#123; System.out.println(&quot;NOT OK!&quot;);&#125;//输出：NOT OK! 分析可知，类型类 是一一对应的，父类的类型类和继承自父类的子类的类型类是不同的！！！ 如果知道一个实例对象，那么可以通过.getClass来获得该对象的类型类，如果知道一个类型，那么就可以使用.class来获得该类型的类型类。 获取 类型类 后，可以调用其中的一些方法获得类型的信息。如： 方法名 返回类型 描述 getName() String 获得该类型的全名称 getSuperClass() Class 获得该类型的直接父类，如没有则返回null getInterfaces() Class[] 获得该类型实现的所有接口 isArray boolean 判断是否为数组 isEnum() boolean 判断类型是否为枚举类型 isInterface() boolean 判断是否为接口 isPrimitive() boolean 判断该类型是否是基本类型 -&gt; int, boolean, double，float类 isAssignableFrom(Class cls) boolean 判断这个类型是否是福类型cls的父类或父接口 getComponentType() Class 如果该类型是一个数组，那么返回该数组的组件类型 asSubclass(Class cla) Class ? 定义Java反射机制: 简言之，就是能够动态获取信息、以及能否动态调用对象的方法。 传统的编程要求程序必须在编译阶段决定使用的类型，如C。 它是在程序运行状态中，对于任意一个类，都能知道这个类的所有属性和方法；对于任意一个对象，都能调用它的任意一个方法； 实例① 接口类ActionInterface 接口类定义了一个动作方法，具体实现由继承实现该接口类的子类去实现。 123interface ActionInterface&#123; public void walk(int m);&#125; ② Person类 – 父类 1234567891011121314151617181920212223242526272829303132333435/** * * Person类包含2个构造器，一个无参构造器，一个含参构造器 * */class Person&#123; private int age; private String name; //无参构造器 public Person()&#123; &#125; //含参构造器 public Person(int age, String name)&#123; this.age = age; this.name = name; &#125; /* 提供对外访问Person类中私有变量 age、name属性的方法 */ public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; ③ SuperMan类 – 子类 SuperMan了继承自Person类 12345678910111213141516171819202122232425/** * SuperMan子类继承自Person类 同时实现接口ActionInterface */class SuperMan extends Person implements ActionInterface&#123; private boolean BlueBriefs; public void fly() &#123; System.out.println(&quot;超人会飞耶～～&quot;); &#125; public boolean isBlueBriefs() &#123; return BlueBriefs; &#125; public void setBlueBriefs(boolean blueBriefs) &#123; BlueBriefs = blueBriefs; &#125; @Override public void walk(int m) &#123; System.out.println(&quot;超人会走耶～～走了&quot; + m + &quot;米就走不动了！&quot;); &#125;&#125; 简单分析下，SuperMan属于子类，其继承自Person类，Person类中显式地声明了无参构造器和含参构造器，当创建子类对象时，对构造器的一些初始化调用(关于构造器可查看: http://lomo.space/2016/04/14/Java-Constructor/) 测试类Main : 测试类种 简单写了8个方法分别说明Java反射中的一些知识和使用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249public class Main &#123; /** * 为了看清楚Java反射部分代码，所有异常都最后抛出来给虚拟机处理！ * @param args * @throws ClassNotFoundException * @throws InstantiationException * @throws IllegalAccessException * @throws InvocationTargetException * @throws IllegalArgumentException * @throws NoSuchFieldException * @throws SecurityException * @throws NoSuchMethodException */ public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException, SecurityException, NoSuchFieldException, NoSuchMethodException &#123; //Demo1. 通过Java反射机制得到类的包名和类名// Demo1();// System.out.println(&quot;===============================================&quot;);//// //Demo2. 验证所有的类都是Class类的实例对象// Demo2();// System.out.println(&quot;===============================================&quot;); //Demo3. 通过Java反射机制，用Class 创建类对象[这也就是反射存在的意义所在]，无参构造// Demo3();// System.out.println(&quot;===============================================&quot;); //Demo4: 通过Java反射机制得到一个类的构造函数，并实现构造带参实例对象// Demo4();// System.out.println(&quot;===============================================&quot;); //Demo5: 通过Java反射机制操作成员变量, set 和 get// Demo5();// System.out.println(&quot;===============================================&quot;); //Demo6: 通过Java反射机制得到类的一些属性： 继承的接口，父类，函数信息，成员信息，类型等// Demo6();// System.out.println(&quot;===============================================&quot;); //Demo7: 通过Java反射机制调用类中方法 Demo7(); System.out.println(&quot;===============================================&quot;);// //Demo8: 通过Java反射机制获得类加载器// Demo8();// System.out.println(&quot;===============================================&quot;); &#125; /** * Demo1: 通过Java反射机制得到类的包名和类名 */ public static void Demo1() &#123; Person person = new Person(); System.out.println(&quot;Demo1: 包名: &quot; + person.getClass().getPackage().getName() + &quot;，&quot; + &quot;完整类名: &quot; + person.getClass().getName()); //System.out.println(String.class); // 获取String的类型类，输出：class java.lang.String //System.out.println(Person.class.getName()); //javaClassExercise.fanshe.Person &#125; /** * Demo2: 验证所有的类都是Class类的实例对象 * @throws ClassNotFoundException */ public static void Demo2() throws ClassNotFoundException &#123; //定义两个类型都未知的Class , 设置初值为null, 看看如何给它们赋值成Person类 Class&lt;?&gt; class1 = null; Class&lt;?&gt; class2 = null; //Class&lt;?&gt; class3 = null; //写法1, 可能抛出 ClassNotFoundException [多用这个写法] class1 = Class.forName(&quot;javaClassExercise.fanshe.Person&quot;); System.out.println(&quot;Demo2:(写法1-.forName) 包名: &quot; + class1.getPackage().getName() + &quot;，&quot; + &quot;完整类名: &quot; + class1.getName()); //写法2 class2 = Person.class; System.out.println(&quot;Demo2:(写法2-.class) 包名: &quot; + class2.getPackage().getName() + &quot;，&quot; + &quot;完整类名: &quot; + class2.getName()); //System.out.println(class1 == class2); // true &#125; /** * Demo3: 通过Java反射机制，用Class 创建类对象[这也就是反射存在的意义所在] * @throws ClassNotFoundException * @throws IllegalAccessException * @throws InstantiationException */ public static void Demo3() throws ClassNotFoundException, InstantiationException, IllegalAccessException &#123; Class&lt;?&gt; class1 = null; class1 = Class.forName(&quot;javaClassExercise.fanshe.Person&quot;); //由于这里不能带参数，所以你要实例化的这个类Person，一定要有无参构造函数哈～ Person person = (Person) class1.newInstance(); person.setAge(25); person.setName(&quot;Lomoa&quot;); System.out.println(&quot;Demo3: &quot; + &quot;Name：&quot; + person.getName() + &quot; , Age: &quot; + person.getAge()); &#125; /** * Demo4: 通过Java反射机制得到一个类的构造函数，并实现创建带参实例对象 * @throws ClassNotFoundException * @throws InvocationTargetException * @throws IllegalAccessException * @throws InstantiationException * @throws IllegalArgumentException */ public static void Demo4() throws ClassNotFoundException, IllegalArgumentException, InstantiationException, IllegalAccessException, InvocationTargetException &#123; Class&lt;?&gt; class1 = null; Person person1 = null; Person person2 = null; class1 = Class.forName(&quot;javaClassExercise.fanshe.Person&quot;); //得到一系列构造函数集合 Constructor&lt;?&gt;[] constructors = class1.getConstructors(); person1 = (Person) constructors[0].newInstance(); person1.setAge(20); person1.setName(&quot;lomoch&quot;); person2 = (Person) constructors[1].newInstance(23,&quot;chenD&quot;); System.out.println(&quot;Demo4: &quot; + person1.getName() + &quot; : &quot; + person1.getAge() + &quot; , &quot; + person2.getName() + &quot; : &quot; + person2.getAge() ); &#125; /** * Demo5: 通过Java反射机制操作成员变量, set 和 get * * @throws IllegalAccessException * @throws IllegalArgumentException * @throws NoSuchFieldException * @throws SecurityException * @throws InstantiationException * @throws ClassNotFoundException */ public static void Demo5() throws IllegalArgumentException, IllegalAccessException, SecurityException, NoSuchFieldException, InstantiationException, ClassNotFoundException &#123; Class&lt;?&gt; class1 = null; class1 = Class.forName(&quot;javaClassExercise.fanshe.Person&quot;); Object obj = class1.newInstance(); Field personNameField = class1.getDeclaredField(&quot;name&quot;); personNameField.setAccessible(true); personNameField.set(obj, &quot;Lomoa&quot;); System.out.println(&quot;Demo5: 修改属性之后得到属性变量的值：&quot; + personNameField.get(obj)); &#125; /** * Demo6: 通过Java反射机制得到类的一些属性： 继承的接口，父类，函数信息，成员信息，类型等 * @throws ClassNotFoundException */ public static void Demo6() throws ClassNotFoundException &#123; Class&lt;?&gt; class1 = null; class1 = Class.forName(&quot;javaClassExercise.fanshe.SuperMan&quot;); //getSuperclass取得父类名称 Class&lt;?&gt; superClass = class1.getSuperclass(); System.out.println(&quot;Demo6: SuperMan类的父类名: &quot; + superClass.getName()); System.out.println(&quot;===============================================&quot;); Field[] fields = class1.getDeclaredFields(); for (int i = 0; i &lt; fields.length; i++) &#123; System.out.println(&quot;类中的成员作用域: &quot; + fields[i]); &#125; System.out.println(&quot;===============================================&quot;); //getDeclaredMethods取得类方法 Method[] methods = class1.getDeclaredMethods(); for (int i = 0; i &lt; methods.length; i++) &#123; System.out.println(&quot;Demo6,取得SuperMan类的&quot; + &quot;第&quot; + i + &quot;个&quot; + &quot;方法：&quot;); System.out.print(&quot;函数名：&quot; + methods[i].getName()); System.out.print(&quot;函数返回类型：&quot; + methods[i].getReturnType()); System.out.print(&quot;函数访问修饰符：&quot; + Modifier.toString(methods[i].getModifiers())); System.out.println(&quot;函数代码写法： &quot; + methods[i]); &#125; System.out.println(&quot;===============================================&quot;); //取得类实现的接口,因为接口类也属于Class,所以得到接口中的方法也是一样的方法得到哈 Class&lt;?&gt; interfaces[] = class1.getInterfaces(); for (int i = 0; i &lt; interfaces.length; i++) &#123; System.out.println(&quot;实现的接口类名: &quot; + interfaces[i].getName() ); &#125; &#125; /** * Demo7: 通过Java反射机制调用类方法 * @throws ClassNotFoundException * @throws NoSuchMethodException * @throws SecurityException * @throws InvocationTargetException * @throws IllegalAccessException * @throws IllegalArgumentException * @throws InstantiationException */ public static void Demo7() throws ClassNotFoundException, SecurityException, NoSuchMethodException, IllegalArgumentException, IllegalAccessException, InvocationTargetException, InstantiationException &#123; Class&lt;?&gt; class1 = null; class1 = Class.forName(&quot;javaClassExercise.fanshe.SuperMan&quot;); System.out.println(&quot;Demo7: \\n调用无参方法fly()：&quot;); Method method = class1.getMethod(&quot;fly&quot;); method.invoke(class1.newInstance()); System.out.println(&quot;调用有参方法walk(int m)：&quot;); Method method1 = class1.getMethod(&quot;walk&quot;,int.class); method1.invoke(class1.newInstance(),99); &#125; /** * Demo8: 通过Java反射机制得到类加载器信息 * * 在java中有三种类类加载器。[这段资料网上截取] 1）Bootstrap ClassLoader 此加载器采用c++编写，一般开发中很少见。 2）Extension ClassLoader 用来进行扩展类的加载，一般对应的是jre\\lib\\ext目录中的类 3）AppClassLoader 加载classpath指定的类，是最常用的加载器。同时也是java中默认的加载器。 * * @throws ClassNotFoundException */ public static void Demo8() throws ClassNotFoundException &#123; Class&lt;?&gt; class1 = null; class1 = Class.forName(&quot;javaClassExercise.fanshe.SuperMan&quot;); String nameString = class1.getClassLoader().getClass().getName(); System.out.println(&quot;Demo8: 类加载器类名: &quot; + nameString); &#125;&#125; 运行Demo1(); 输出: Demo1: 包名: javaClassExercise.fanshe，完整类名: javaClassExercise.fanshe.Person Demo1()方法 123456public static void Demo1() &#123; Person person = new Person(); System.out.println(&quot;Demo1: 包名: &quot; + person.getClass().getPackage().getName() + &quot;，&quot; + &quot;完整类名: &quot; + person.getClass().getName()); &#125; 在Demo1中，以new关键字的方式创建了Person对象person, 通过该对象person的getClass()方法获得该person对象的Class，在通过此Class获得包名和类名。 Demo2()方法 通过forName方法获得类型类； 1234567891011121314151617public static void Demo2() throws ClassNotFoundException &#123; //定义两个类型都未知的Class , 设置初值为null, 看看如何给它们赋值成Person类 Class&lt;?&gt; class1 = null; Class&lt;?&gt; class2 = null; //写法1, 可能抛出 ClassNotFoundException [多用这个写法] class1 = Class.forName(&quot;javaClassExercise.fanshe.Person&quot;); System.out.println(&quot;Demo2:(写法1) 包名: &quot; + class1.getPackage().getName() + &quot;，&quot; + &quot;完整类名: &quot; + class1.getName()); //写法2 class2 = Person.class; System.out.println(&quot;Demo2:(写法2) 包名: &quot; + class2.getPackage().getName() + &quot;，&quot; + &quot;完整类名: &quot; + class2.getName()); System.out.println(class1 == class2); // true &#125; 分析，forName()方法是Class类中的静态方法，作用是返回一个类(要求JVM查找并加载制定的类); Demo3()方法 通过反射 创建类对象。 12345678910public static void Demo3() throws ClassNotFoundException, InstantiationException, IllegalAccessException &#123; Class&lt;?&gt; class1 = null; class1 = Class.forName(&quot;javaClassExercise.fanshe.Person&quot;); //由于这里不能带参数，所以要实例化的这个类Person，一定要显式地声明无参构造函数，如果只声明含参构造器那么默认的无参构造器就被覆盖,只有显式地声明才可以～ Person person = (Person) class1.newInstance(); person.setAge(25); person.setName(&quot;Lomoa&quot;); System.out.println(&quot;Demo3: &quot; + person.getName() + &quot; : &quot; + person.getAge()); &#125; newInstance()方法是Class类中的一个泛型方法。 Person person &#x3D; (Person) class1.newInstance(); &#x2F;&#x2F;newInstance返回的是一个对象，用缺省构造函数创建一个该类的对象，并将新创建的这个对象强转为Person类的类型； 如果只定义了含参构造器呢？参考博文，通过反射创建类实例的2种方式 – Java Create Object By Reflect. 或看Demo4(). Demo5() 操作成员属性示例 主要利用了反射相关类里的Field类。更多反射相关类，点此查看：http://lomo.space/2016/08/14/java-reflect/ Filed类提供了接口&#x2F;类的属性信息操作方法 Class类的getDeclaredField方法返回一个Field类型对象。 1234567Class&lt;?&gt; class1 = null;class1 = Class.forName(&quot;javaClassExercise.fanshe.Person&quot;);Object obj = class1.newInstance(); //创建类对象objField personNameField = class1.getDeclaredField(&quot;name&quot;); //获取的是String类型属性, set时也要传入String类型值，如果是age为int型，下面的set就应传入int型personNameField.setAccessible(true); // 关闭JDK安全检查，提升反射速度personNameField.set(obj, &quot;Lomoa&quot;); //使用Field类的set方法给对象obj添加属性值&quot;Lomoa&quot;（上一步getDeclaredField获取的是String-&gt;name属性） 由于Person类中声明的两个私有属性 private int age; 和 private String name;, 所以personNameField.setAccessible(true);必须设置为true 如果Person类添加一个public属性如： Person类 123//...public String gender;//.... Main测试类 12345678910111213public static void Demo5() throws IllegalArgumentException, IllegalAccessException, SecurityException, NoSuchFieldException, InstantiationException, ClassNotFoundException &#123; Class&lt;?&gt; class1 = null; class1 = Class.forName(&quot;javaClassExercise.fanshe.Person&quot;); Object obj = class1.newInstance(); Field personNameField = class1.getDeclaredField(&quot;gender&quot;); // public级别的 personNameField.setAccessible(false); // 可以为FALSE，为true也可以，但是设置为true最好。 personNameField.set(obj, &quot;Lomoa&quot;); System.out.println(&quot;Demo5: 修改属性之后得到属性变量的值：&quot; + personNameField.get(obj)); &#125; 然后此项设置为false，也可以通过编译成功执行。 所以得到的Field类型对象后，就可以对该类型的对象personNameField进行操作set操作设置属性值，通过get(obj)获取属性值。 Demo6 获得类的属性 1234567891011121314151617181920212223242526272829303132333435363738public static void Demo6() throws ClassNotFoundException &#123; Class&lt;?&gt; class1 = null; class1 = Class.forName(&quot;javaClassExercise.fanshe.SuperMan&quot;); //getSuperclass 取得父类名称 Class&lt;?&gt; superClass = class1.getSuperclass(); System.out.println(&quot;Demo6: SuperMan类的父类名: &quot; + superClass.getName()); System.out.println(&quot;===============================================&quot;); Field[] fields = class1.getDeclaredFields(); for (int i = 0; i &lt; fields.length; i++) &#123; System.out.println(&quot;类中的成员作用域: &quot; + fields[i]); &#125; System.out.println(&quot;===============================================&quot;); //getDeclaredMethods 取得类方法 Method[] methods = class1.getDeclaredMethods(); for (int i = 0; i &lt; methods.length; i++) &#123; System.out.println(&quot;Demo6,取得SuperMan类的&quot; + &quot;第&quot; + i + &quot;个&quot; + &quot;方法：&quot;); System.out.print(&quot;函数名：&quot; + methods[i].getName()); System.out.print(&quot;函数返回类型：&quot; + methods[i].getReturnType()); System.out.print(&quot;函数访问修饰符：&quot; + Modifier.toString(methods[i].getModifiers())); System.out.println(&quot;函数代码写法： &quot; + methods[i]); &#125; System.out.println(&quot;===============================================&quot;); //取得类实现的接口,因为接口类也属于Class,所以得到接口中的方法也是一样的方法得到哈 Class&lt;?&gt; interfaces[] = class1.getInterfaces(); for (int i = 0; i &lt; interfaces.length; i++) &#123; System.out.println(&quot;实现的接口类名: &quot; + interfaces[i].getName() ); &#125; &#125; 输出： 123456789101112131415Demo6: SuperMan类的父类名: javaClassExercise.fanshe.Person===============================================类中的成员作用域: private boolean javaClassExercise.fanshe.SuperMan.BlueBriefs===============================================Demo6,取得SuperMan类的第0个方法：函数名：isBlueBriefs函数返回类型：boolean函数访问修饰符：public函数代码写法： public boolean javaClassExercise.fanshe.SuperMan.isBlueBriefs()Demo6,取得SuperMan类的第1个方法：函数名：setBlueBriefs函数返回类型：void函数访问修饰符：public函数代码写法： public void javaClassExercise.fanshe.SuperMan.setBlueBriefs(boolean)Demo6,取得SuperMan类的第2个方法：函数名：fly函数返回类型：void函数访问修饰符：public函数代码写法： public void javaClassExercise.fanshe.SuperMan.fly()Demo6,取得SuperMan类的第3个方法：函数名：walk函数返回类型：void函数访问修饰符：public函数代码写法： public void javaClassExercise.fanshe.SuperMan.walk(int)===============================================实现的接口类名: javaClassExercise.fanshe.ActionInterface=============================================== Demo7 通过反射调用类方法 12345678910111213public static void Demo7() throws ClassNotFoundException, SecurityException, NoSuchMethodException, IllegalArgumentException, IllegalAccessException, InvocationTargetException, InstantiationException &#123; Class&lt;?&gt; class1 = null; class1 = Class.forName(&quot;javaClassExercise.fanshe.SuperMan&quot;); System.out.println(&quot;Demo7: \\n调用无参方法fly()：&quot;); Method method = class1.getMethod(&quot;fly&quot;); method.invoke(class1.newInstance()); System.out.println(&quot;调用有参方法walk(int m)：&quot;); Method method1 = class1.getMethod(&quot;walk&quot;,int.class); method1.invoke(class1.newInstance(),99); &#125; getMethod()源码： 123456789public Method getMethod(String name, Class&lt;?&gt;... parameterTypes) throws NoSuchMethodException, SecurityException &#123; checkMemberAccess(Member.PUBLIC, Reflection.getCallerClass(), true); Method method = getMethod0(name, parameterTypes); if (method == null) &#123; throw new NoSuchMethodException(getName() + &quot;.&quot; + name + argumentTypesToString(parameterTypes)); &#125; return method; &#125; Method类的invoke()方法？ invoke()方法属于Method类中的方法, 该方法返回类型为Object类型。所以使用invoke方法调用的就是Method类代表的方法 参考：http://www.cnblogs.com/onlywujun/p/3519037.html 那么为什么要使用反射？ 反射可以使得在不知道类的内部结构情况下，根据配置的字符串去调用一个类的方法。很多框架代码都是这样去实现的。但是一般的编程，是不需要这样做的，因为类都是自己写的，怎么调用，怎么生成都是清楚的。","categories":[{"name":"program","slug":"program","permalink":"http://lomo.space/categories/program/"}],"tags":[{"name":"java","slug":"java","permalink":"http://lomo.space/tags/java/"},{"name":"reflect","slug":"reflect","permalink":"http://lomo.space/tags/reflect/"}]},{"title":"vertival-align兼容问题","slug":"vertival-align兼容问题","date":"2016-12-06T09:24:22.000Z","updated":"2022-01-14T11:40:22.888Z","comments":true,"path":"2016/12/06/vertival-align兼容问题/","link":"","permalink":"http://lomo.space/2016/12/06/vertival-align%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98/","excerpt":"","text":"vertical-align兼容性12345&lt;div style=&quot;display:inline-line;&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;a-upload&quot;&gt; &lt;input type=&quot;file&quot; id=&quot;uploadFile&quot; value=&quot;&quot; name=&quot;file&quot; multiple=&quot;multiple&quot; class=&quot;file&quot; /&gt;选择文件 &lt;/a&gt;&lt;/div&gt; 选择文件后，后面展示的文件名并未对齐(在自定义这个选择文件Button后), 想到使用vertical-align:middle;属性, 测试发现，Chrome、Firefox、Safari三大浏览器表现情况各不一致. 12345678910111213141516171819202122232425262728293031323334353637.a-upload &#123; vertical-align: middle; margin-top: 10px; margin-left: 32px; padding: 5px 10px; height: 20px; line-height: 20px; position: relative; cursor: pointer; color: #888; background: #fafafa; border: 1px solid #ddd; border-radius: 4px; overflow: hidden; display: inline-block; *display: inline; *zoom: 1; text-decoration: none;&#125;.a-upload input &#123; position: absolute; font-size: 100px; right: 0; top: 0; opacity: 0; cursor: pointer&#125;.a-upload:hover &#123; color: #444; background: #eee; border-color: #ccc; /* font: bold 12px/20px arial, sans-serif; */&#125; 正确使用: 1234567span.showFileName &#123; vertical-align: middle; /* */ vertical-align: -webkit-baseline-middle; /* Chorme/Safari */ vertical-align: -moz-middle-with-baseline; /* Firefox */ margin-left: 10px; margin-top: 2px;&#125; vertical-align: -webkit-baseline-middle; 在 Safari和Chrome 中均ok，vertical-align: -moz-middle-with-baseline;针对火狐。 效果图： 1234567891011#开发&amp;测试环境OS Sierra 10.12#Safari版本 10.0 (12602.1.50.0.10)#Firefox56.0.2 (64 位)#Chrome62.0.3202.94（正式版本） （64 位） 条件所限，IE未经测试!","categories":[{"name":"study","slug":"study","permalink":"http://lomo.space/categories/study/"}],"tags":[{"name":"css","slug":"css","permalink":"http://lomo.space/tags/css/"}]},{"title":"Java Class and Object","slug":"Java-Class-and-Object","date":"2016-11-11T14:25:18.000Z","updated":"2022-01-14T11:40:22.870Z","comments":true,"path":"2016/11/11/Java-Class-and-Object/","link":"","permalink":"http://lomo.space/2016/11/11/Java-Class-and-Object/","excerpt":"","text":"Java类和对象[学习笔记]简介类, 是抽象的; 将对象的属性和方法封装在一起就组成了类。 对象, 是具体的; 在面向对象编程中，主要思想：一切皆为对象！以对象为单位进行coding 提出问题 为什么Java中的main函数必须是static静态的？ 为什么main方法中必须带有参数而且是不定参数String[] value形式？ 这是自己学习以来经常会在脑海里出现的问题，现在进行系统学习后，简单进行总结，答案在最后。 类的创建和初始化创建1234567class 类名 &#123; //构造函数 public 类名() &#123; //do sth... &#125;&#125; 默认地，如果一个类没有显式地申明构造函数，则在编译执行过程中会自动创建一个构造函数! 而构造方法是一个类被初始化过程中必须执行的方法！！ 类的创建规则： 一个.java文件中可以有多个类，但是 至多 只能有一个public类 一般情况，该类里放置main方法，作为程序入口! 可以有0个public的类, 那么.java文件的名可以与其中任何一个类名字相同即可 如果有public类，则.java文件名字必须与该public类名相同！！！ 关于编译: 编译时，会为每个.java文件创建一个对应的.class文件 初始化 一般，通过类的构造器来创建对象, 构造器即：构造函数，是一个与类同名的方法；在new时对其传递一些参数完成初始化. 1类名 变量名 = new 类名(&quot;参数&quot;); E.g. 123456789101112131415161718192021222324252627282930313233public class classTest &#123; String name; int age; double height; double weight; String interest; boolean sex; public classTest(String name, int age, double height, double weight, String interest, boolean sex) &#123; this.name = name; this.age = age; this.height = height; this.weight = weight; this.interest = interest; this.sex = sex; //还有其它很多公有属性 &#125; public static void main(String[] args) &#123; classTest test = new classTest(&quot;Lomo&quot;, 25, 165.00, 110.0, &quot;read&quot;, true); String male; if(test.sex) &#123; male = &quot;男&quot;; &#125;else &#123; male = &quot;女&quot;; &#125; System.out.print(&quot;Name: &quot; + test.name + &quot;，Age: &quot; + test.age + &quot;，Height: &quot; + test.height + &quot;，Weight: &quot;+ test.weight + &quot;，Interest&quot; + test.interest + &quot;，Sex: &quot; + male); &#125;&#125;// 运行输出: Name: Lomo，Age: 25，Height: 165.0，Weight: 110.0，Interestread，Sex: 男 【总结】 初始化&#x2F;实例化一个类 这个new 的过程: 编译器会首先检查类中是否有显式地申明构造函数，若有，则new的时候会直接调用该定义的构造器&#x2F;构造函数; 若没有显式地申明构造函数，则编译器会自动为该类增加一个无参数的空构造方法：类名(){}; 构造方法和变量的初始化顺序: 类在被初始化new的过程中, 构造方法和变量的初始化顺序? 结论： 无论类中的(类)变量申明在方法&#x2F;构造方法前面或者后面，变量都会优先于一般方法&#x2F;构造方法 执行！！！ 无论类变量在类中相对于方法的位置是在方法前或后，只要在方法的外部，就一定会先初始化变量！！！ E.g.1Person.java 12345678910111213141516171819202122232425262728293031public class Person &#123; public String t = &quot;lomo&quot;; //构造器/构造函数 public Person(int id) &#123; System.out.println(&quot;Person: &quot; + id); &#125; public static void main(String[] args) &#123; Build b = new Build(); &#125;&#125;class Build&#123; Person p1 = new Person(1); public Build() &#123; System.out.println(&quot;这是Build类的构造函数！&quot;); Person p2 = new Person(2); &#125; Person p3 = new Person(3);&#125;// 输出： // Person: 1 // Person: 3 // 这是Build类的构造函数！ // Person: 2 分析运行时，找到main方法，从main方法作为入口开始执行程序，在main方法中new了一个Build类对象b, 再看Build类, Build类中有两个变量p1, p3 和 一个Build类的显式声明的无参数的构造函数, 根据开头的结论：类变量初始化优先于构造函数初始化, 所以在main函数中new一个Build类实例时，会先初始化Build类的类变量p1, p3， 所以依次输出 Person: 1, Person: 3, 然后执行构造器的初始化, 打印了构造方法Build的结果 这是Build类的构造函数！, Build构造函数中第二行语句又new了一个Person类的实例，所以此时又按照刚才所述，同理先初始化类变量，此时Person类中无类变量，所以根据给new时给传入的参数2 执行Person类的构造方法，输出Person: 2. 分析完毕!!! 【实际使用】过程中，构造函数：通常 构造函数是为了在new创建类实例(对象)时就可以直接获取该类的一些属性. static与非static区别首先，对E.g.1改造： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class Person &#123; //构造器、构造函数 public Person(int id) &#123; System.out.println(&quot;Person: &quot; + id); //Lomo lomo = new Lomo(&quot;LOMO&quot;); &#125; /** * static 静态代码块 */ static &#123; System.out.println(&quot;这是static静态代码块！&quot;); &#125; /** * 非静态块 */ &#123; System.out.println(&quot;这是非静态代码块！&quot;); &#125; // 主函数、程序执行入口 public static void main(String[] args) &#123; Build b = new Build(); &#125;&#125;class Build &#123; Person p1 = new Person(1); public Build() &#123; System.out.println(&quot;这是Build类！&quot;); Person p2 = new Person(2); &#125; Person p3 = new Person(3);&#125;// 运行，输出：//这是Person类中的static静态代码块！//这是Person类中的非静态代码块！//Person: 1//这是Person类中的非静态代码块！//Person: 3//这是Build类！//这是Person类中的非静态代码块！//Person: 2 分析 Tips: 类中的static静态代码块或静态变量、静态方法，在初始化该类时，无论new多少，都只初始化一次然后保存在内存中，供使用！！！ 从main函数入口开始执行程序代码，被static修饰的变量或方法也属于e.g.1中分析所述的类变量、类方法(且 只被初始化一次)，所以在main函数开始执行时，Person类对应的.class已被装载完毕，等待main函数去执行，Java解释器会提前装载好main函数所在的Person类，而Person类中static声明的代码块就被初始化&#x2F;执行, 打印出这是Person类中的static静态代码块！, 接着执行非静态代码块； 然后执行Build类对象b的初始化, 按照之前所述的原则, 初始化对象b时，调用的是Build类，所以要先对Build类的类变量p1初始化，执行new Person(1); new Person操作又是对Person类初始化，该初始化需要先执行Person类中的非静态代码块，所以先输出 这是Person类中的非静态代码块！, Person类中此时无其它类变量、类方法，所以就会执行Person的构造方法输出Person: 1, 此时可以理解为：主函数main方法中的第一部分执行完毕，即： Person p1 = new Person(1); , 按照之前所述规则，继续执行类变量p3初始化, 同上, 一次输出这是Person类中的非静态代码块！ 和 Person: 3, 此时相当于主函数的第二部分执行完毕; 到此 Build类中的类变量全部初始化完毕; 第三部分: 执行Build类的构造函数, 顺序执行输出 这是Build类！, Person p2 = new Person(2); 再按照之前的规则, 一次输出: 这是Person类中的非静态代码块！, Person: 2。 分析完毕！！！ 【总结】 被声明为static的变量或者方法，或者前面说的块，都属于类变量、类方法. static 静态数据特点(static变量、方法)：初始化只在类的装载过程中只执行一次！！！整个过程中只进行一次初始化，在内存中只开辟一个空间，不论在哪儿调用，值保持一致。一旦被修改，所有引用它的地方都会跟着修改。 一般直接通过类名进行调用。 类变量、类里的方法，外部对象对他们的引用还可以直接使用类名.变量名或类名.方法名 进行引用(在一个类中引用另一个类的变量,则该变量在另一个类中必须定义为private类型, 且范围不能是private修饰的). 非静态块： 每new实例化一个对象时，就会执行一次非静态对象！！！ 对E.g.2 添加一行代码，在main函数中 E.g.3 12345678910111213141516171819202122232425262728Build b = new Build();System.out.println(&quot;第二次new Build 类!&quot;); //为了区分便于查看输出结果Build b2 = new Build(); //见下边的总结6）\u0003//输出结果://这是Person类中的static静态代码块！//这是Person类中的非静态代码块！//Person: 1//这是Person类中的非静态代码块！//Person: 3//这是Build类！//这是Person类中的非静态代码块！//Person: 2// 第二次new Build 类!//这是Person类中的static静态代码块！//这是Person类中的非静态代码块！//Person: 1//这是Person类中的非静态代码块！//Person: 3//这是Build类！//这是Person类中的非静态代码块！//Person: 2 对象创建(new)过程总结 装载.class文件，创建class对象，对由static声明的变量、方法进行初始化 且 只初始化一次！ new实例化时，在堆内存进行空间分配 执行非静态块 执行 所有方法外定义的(类)变量的初始化 执行构造器&#x2F;构造函数(方法) [ 基本可以认为 构造函数是 一个类new过程中最后执行的 ] 针对同一个类，同时new多个该类的对象实例，则每次new的过程都遵循、并按顺序执行 上述原则 问题1、2 答案Q1 Java中main函数为何必须是static修饰符？ 针对上述static分析、总结，现在来解释 开头的问题1： Java中main函数为何必须是static修饰符？ 个人 + 网上各类博客文章 总结： 运行Java应用程序时，需要依赖JVM的运行。 当 Run某个类时，会启动虚拟机去执行该类中的main方法. JVM运行Java应用程序时，首先会去调用main方法, 而不必实例化main函数所在的这个类(不用去new一个对象), 通过类名来调用需要限制为public, 同时JVM规定main函数不能有返回值，因此返回类型为void. 此外，main方法是Java解释器调用，那时候还未产生任何对象，作为程序的入口，必须提前加载好；[main是一个可以被JVM识别的特殊单词，而不是关键字] static修饰的类属性可以直接使用，而无需new一个实例化对象去调用； [可以没有main方法而去执行Java代码] Q2 Java中main函数为何必须使用String[] args形式的不定参数(数组作为参数)？ A: 程序运行时, JVM会首先调用main函数，而main函数传入的是String数组，示例 12345678public class Main &#123; public static void main(String[] args) throws Exception&#123; System.out.println(args); &#125;&#125;// 运行输出：[Ljava.lang.String;@21780f30// 每次运行发现@后的字符串值都不一样! 修改输出 12System.out.println(args.length);// 输出为0，说明传入的实体数组长度为0(实体数组而非null !!!), 相当于传入的是 `new String[0]` 尝试输出数组某个值 1System.out.println(args[0]); 运行，报错 Exception in thread &quot;main&quot; java.lang.ArrayIndexOutOfBoundsException: 0, 越界错误❌. 说明args这个数组中没有元素啊！！！那JVM传递这个实体数组干什么？ 123456public class TestMain &#123; public static void main(String[] args) throws Exception&#123; for(int i=0;i&lt;args.length;i++) System.out.println(args[i]); &#125;&#125; 在终端，进入该.java文件所在目录，然后 javac 编译该文件, 产生一个执行的class文件. 然后，我们使用java命令运行该测试类，并传入参数 1 2 4 如果，该函数在某一个包下，则终端路径需要回退到包目录去执行，类似于 12345javaStudy/src % java javaClassExercise.TestMain 1 2 4#输出: # 1# 2# 4 使用java命令调用虚拟机，并手动传入值，调用方式：java 类名 参数。同时，JVM将类后面的这些数据存入了数组！ main方法里面的args的参数原来是接收的java运行参数。 可简单认为 – 解释: 按照Java规定入口函数必须这样写，就这么记！！而且参数必须为String类实例化的数组. 关于Java main函数相关解析还可参考博文: http://stackoverflow.com/questions/146576/why-is-the-java-main-method-statichttp://www.cnblogs.com/xwdreamer/archive/2012/04/09/2438845.html 附:无main函数运行Java代码 问题： Java程序中, 无main函数作为入口函数, 程序是如何运行的呢？ A: 利用Junit或TestNG 测试框架，以@Test注解在测试方法上的形式 实现无main函数也可以运行Java代码. 参考： http://www.ibm.com/developerworks/cn/java/j-cq08296/ 创建Maven工程： pom.xml添加依赖： 123456789101112&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.testng&lt;/groupId&gt; &lt;artifactId&gt;testng&lt;/artifactId&gt; &lt;version&gt;6.8.21&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.10&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; E.g. 123456789101112131415161718192021222324import org.testng.annotations.Test;/** * Created by lomo */public class noMainMethod &#123; static &#123; System.out.println(&quot;我是测试无main函数类中的第一个静态代码块&quot;);// System.exit(0); &#125; @Test(description = &quot;第一个&quot;, testName = &quot;T1&quot;) public void test() throws Exception &#123; System.out.println(&quot;123chendong&quot;); &#125; @Test(description = &quot;第二个测试例子&quot;, testName = &quot;T2&quot;) public void test2() throws Exception &#123; System.out.println(&quot;test 2&quot;); &#125;&#125; 光标移动至test 或test2 上右键运行即可成功执行并输出对应结果: 1234567我是测试无main函数类中的第一个静态代码块[TestNG] Running: 123Lomo===============================================Default SuiteTotal tests run: 1, Failures: 0, Skips: 0=============================================== 或直接移动光标至类noMainMethod上运行，执行里面的2条Test并输出结果: 12345678我是测试无main函数类中的第一个静态代码块[TestNG] Running: 123Lomotest 2===============================================Default SuiteTotal tests run: 2, Failures: 0, Skips: 0=============================================== TestNG运行原理? 思考🤔: TestNG如何实现Java无main函数运行代码的? 首先简单从@Test 作为入口，找到TestNG的annotations, 或者从测试方法的import包里找到TestNG的annotations包: import org.testng.annotations 可以看到org.testng包里除了annotations包外还有其它包: 断言asserts、log、junit、log4testng、xml…等等的包. 进入annotations包，发现很多编译好的 .class 文件，找到其中之一Test.class, 双击进入 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package org.testng.annotations;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Retention(RetentionPolicy.RUNTIME)@Target(&#123;ElementType.METHOD, ElementType.TYPE, ElementType.CONSTRUCTOR&#125;)public @interface Test &#123; String[] groups() default &#123;&#125;; boolean enabled() default true; /** @deprecated */ @Deprecated String[] parameters() default &#123;&#125;; String[] dependsOnGroups() default &#123;&#125;; String[] dependsOnMethods() default &#123;&#125;; long timeOut() default 0L; long invocationTimeOut() default 0L; int invocationCount() default 1; int threadPoolSize() default 0; int successPercentage() default 100; String dataProvider() default &quot;&quot;; Class&lt;?&gt; dataProviderClass() default Object.class; boolean alwaysRun() default false; String description() default &quot;&quot;; Class[] expectedExceptions() default &#123;&#125;; String expectedExceptionsMessageRegExp() default &quot;.*&quot;; String suiteName() default &quot;&quot;; String testName() default &quot;&quot;; /** @deprecated */ boolean sequential() default false; boolean singleThreaded() default false; Class retryAnalyzer() default Class.class; boolean skipFailedInvocations() default false; boolean ignoreMissingDependencies() default false; int priority() default 0;&#125; 分析 先粗糙地分析下，待学完Java注解Anonation、反射等之后再深入总结下. 根据其import的包是 java.lang.annotation, 就可以断言，TestNG的 @Test模式肯定也是基于Java的注解模式来实现无main函数运行的. 接着简单说说Test方法前3行代码: 123@Retention(RetentionPolicy.RUNTIME)@Target(&#123;ElementType.METHOD, ElementType.TYPE, ElementType.CONSTRUCTOR&#125;)public @interface Test 1)Retention， 保留， 表示在什么级别保留此信息 SOURCE:源码注解，注解仅存在代码中，注解会被编译器丢弃 CLASS:编译时注解，注解会在class文件中保留，但会被JVM丢弃 RUNTIME:运行时注解，VM运行期间也会保留该注解，因此**可以通过反射来获得该注解** 2)Target，表示作用域，可能的ElementType参数包括： CONSTRUCTOR:构造方法声明 FIELD:字段声明 LOCAL_VARIABLE:局部变量声明 METHOD:方法声明 PACKAGE:包声明 PARAMETER:参数声明 TYPE:类，接口或enum声明 Test接口中，提供了很多 @Test 注解使用的属性，@Test标记一个类或方法作为测试的一部分。关于Test接口的详细属性列表参考： http://testng.org/doc/documentation-main.html#annotations 小结: TestNG 实现无main函数执行，是基于Java的注解，深究后续继续学习记录笔记. Done!","categories":[{"name":"study","slug":"study","permalink":"http://lomo.space/categories/study/"}],"tags":[{"name":"java","slug":"java","permalink":"http://lomo.space/tags/java/"}]},{"title":"Linux安装PHP扩展小记","slug":"linux-install-php-extend","date":"2016-11-09T05:07:38.000Z","updated":"2022-01-14T11:40:22.883Z","comments":true,"path":"2016/11/09/linux-install-php-extend/","link":"","permalink":"http://lomo.space/2016/11/09/linux-install-php-extend/","excerpt":"","text":"Linux 安装PHP扩展 手记检查mysql拓展是否安装成功1$ php -i | grep mysql 自动安装.so库并配置php.ini123456789# 如安装mysql拓展 yum search mysql|grep php #我们搜索到拓展名为 php-mysql.x86_64 sudo yum install php-mysql #这样php-mysql拓展便安装好了 # 如果出现拓展版本和php版本冲突问题， 可安装如下任意yum源： sudo yum install atomic-release.noarch sudo yum install webtatic-release.noarch 这些源提供了其他版本的php拓展，同时每个源针对特定拓展都会提供多个版本，你只需安装一个源即可 installphp -v yum search mysql|grep php 如下： 1$ yum install php55w-mysqlnd.x86_64 Done.","categories":[{"name":"study","slug":"study","permalink":"http://lomo.space/categories/study/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://lomo.space/tags/PHP/"},{"name":"Linu","slug":"Linu","permalink":"http://lomo.space/tags/Linu/"},{"name":"扩展","slug":"扩展","permalink":"http://lomo.space/tags/%E6%89%A9%E5%B1%95/"}]},{"title":"centos upgrade mysql to 5.7","slug":"centos-upgrade-mysql-to-5-7","date":"2016-11-09T05:07:20.000Z","updated":"2022-01-14T11:40:22.875Z","comments":true,"path":"2016/11/09/centos-upgrade-mysql-to-5-7/","link":"","permalink":"http://lomo.space/2016/11/09/centos-upgrade-mysql-to-5-7/","excerpt":"","text":"CentOS升级LAMP之MySQL至5.7清理、卸载旧版MySQL12$ yum list installed | grep mysql $ yum -y remove mysql * 添加CentOS的RPM源1234567# wget dev.mysql.com/get/mysql-community-release-el6-5.noarch.rpm# yum localinstall mysql-community-release-el6-5.noarch.rpm# yum repolist all | grep mysql# yum-config-manager --disable mysql55-community# yum-config-manager --disable mysql56-community# yum-config-manager --enable mysql57-community-dmr# yum repolist enabled | grep mysql 检查MySQL源安装是否成功1$ yum repolist enabled | grep &quot;mysql.*-community.*&quot; 安装MySQL1$ yum install mysql-community-server 安装完后会获得一个初始密码，先记下此密码，后边用。 或直接查询安装完成后生成的零时密码： grep &#39;temporary password&#39; /var/log/mysqld.log 或 使用 mysql_secure_installation 进行安全设置 修改&#x2F;充值 root 密码 启动1$ service mysqld start 设置自启动12$ chkconfig --list | grep mysqld ##查看是否自启动$ chkconfig mysqld on ROOT账户相关mysql5.7默认安装了密码安全检查插件（validate_password），默认密码检查策略要求密码必须包含：大小写字母、数字和特殊符号，并且长度不能少于8位。否则会提示ERROR 1819 (HY000): Your password does not satisfy the current policy requirements错误。 密码设定策略1$ show variables like &#x27;%password%&#x27;; 添加远程登录MySQL用户参考上一篇文章，同初次安装时的设定。 修改默认编码MySQL更新升级完后，需要修改默认编码方式。 1$ show variables like &quot;%character%&quot;; 如图： 接着， vi /etc/my.cnf 在[mysqld] 下添加： 12character_set_server=utf8 init_connect=&#x27;SET NAMES utf8&#x27; 然后重启MySQL服务: service mysqld restart 再次查看默认编码，已改为utf-8，如下图：","categories":[{"name":"essay","slug":"essay","permalink":"http://lomo.space/categories/essay/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://lomo.space/tags/MySQL/"},{"name":"CentOS","slug":"CentOS","permalink":"http://lomo.space/tags/CentOS/"},{"name":"upgrade","slug":"upgrade","permalink":"http://lomo.space/tags/upgrade/"}]},{"title":"angular  request","slug":"angular-request","date":"2016-11-07T15:10:30.000Z","updated":"2022-01-14T11:40:22.873Z","comments":true,"path":"2016/11/07/angular-request/","link":"","permalink":"http://lomo.space/2016/11/07/angular-request/","excerpt":"","text":"AngularJS使用$http请求传递数据 $http服务用于与后端进行数据交互&#x2F;获取数据然后在UI渲染等. AngularJS核心服务 $http服务, 可认为相当于JQuery中的Ajax. 用法V1.5版本以下: 12345678910111213141516$http.get(&quot;url&quot;).success(function (res)&#123; //do sth... for success response&#125;).error(function (res)&#123; //do sth... for fail response&#125;);//Orvar config = &#123; url: &quot;url&quot;, headers: &#123;...&#125;, data: &quot;data&quot;&#125;;$http.post(config).success(function s()&#123; //...&#125;).error(function (f)&#123; //...&#125;); V1.5版本以上写法： 1234567891011121314151617181920212223//一般写法://[类似于JQuery中的Ajax写法]$http(&#123; method: &#x27;GET&#x27;, url: &#x27;http://domain.com/path&#x27;&#125;).then(function successCallBack()&#123; //请求成功执行的方法&#125;, function failCallBack()&#123; //请求失败执行的方法&#125; );//或//将请求方式、API、传递的DATA、以及一些请求设置封装到req对象中.var req = &#123; method: &#x27;POST&#x27;, url: &#x27;http://example.com&#x27;, headers: &#123; &#x27;Content-Type&#x27;: undefined &#125;, data: &#123; test: &#x27;test&#x27; &#125;&#125;//V1.5 的.then 方法$http(req).then(function()&#123;...&#125;, function()&#123;...&#125;); 全部http请求1234567$http.get$http.head$http.post$http.put$http.delete$http.jsonp$http.patch 参考： https://docs.angularjs.org/api/ng/service/$http formData问题 默认情况下使用post请求向后端传递数据 12345678910111213141516171819&lt;script&gt; var app = angular.module(&quot;httpDemo&quot;, []); app.controller(&quot;httpDemoController&quot;, function($scope, $http) &#123; $scope.data = &#123; name: &quot;lomoa&quot;, age: 22, sex: &quot;male&quot; &#125;; $http(&#123; method: &quot;POST&quot;, data: $scope.data, url: &quot;./data.json&quot; &#125;).then(function successFn(response) &#123; $scope.names = response.data.sites; &#125;, function failFn(response) &#123; //do nothing here if fail &#125;); &#125;);&lt;/script&gt; Charles抓包查看Http请求传递的数据格式为JSON Text，如下图所示： > 思考🤔： 这样以来的话，如果后端接口未改变，那么前端使用AngularJS的$http服务请求API传递数据就会出现问题，导致后端接受不到JSON数据. 例如, 后端PHP开发的Restful API, 部分代码如下: 123456789101112131415161718if (isset($_POST[&#x27;login&#x27;])) &#123; $login = $_POST[&#x27;login&#x27;]; $email = $_POST[&#x27;email&#x27;]; $password = $_POST[&#x27;password&#x27;]; $addr = getEnv(&quot;REMOTE_ADDR&quot;); $result = mysqli_query($conn, &quot;SELECT * FROM users WHERE email = &#x27;&quot; . $email. &quot;&#x27; and password = &#x27;&quot; . md5($password) . &quot;&#x27;&quot;); if ($row = mysqli_fetch_assoc($result)) &#123; $u = new \\generateUUID\\Uuid($addr); $uuid = $u -&gt; uuid(); //..... //.... &#125;&#125;// 这样的话，$_POST就接受不到来自前端传过来的非formData形式的数据 此时在AngularJS应用中，需要将传输的JSON数据格式转为Formdata格式(否则，就修改后端接口? 呵呵🙄) 针对此问题，有2种解决方案(个人已知!) 方案1: 使用jQuery的$.param序列化函数. 对$http请求中的 $scope.data 直接使用 $.param 函数序列化data对象即可. 12345678910111213141516171819app.controller(&#x27;httpDemoController&#x27;, function($scope, $http) &#123; $scope.data = &#123; name: &#x27;lomo&#x27;, age: 25, sex: &#x27;male&#x27;, height: &#x27;1980&#x27; &#125;, $http(&#123; method: &#x27;POST&#x27;, data: $.param($scope.data), headers : &#123; &#x27;Content-Type&#x27;: &#x27;application/x-www-form-urlencoded&#x27; &#125;, url: &#x27;./data.json&#x27; &#125;).then(function successCallback(response) &#123; $scope.names = response.data.sites; &#125;, function errorCallback(response) &#123; // 请求失败执行代码 &#125;); &#125;); 此种方法需要引入jQuery类库，依据情况决定是否有必要为了使用这个函数而引入该库(通常不会!), 如果项目其它多处也需要使用jQuery的其它功能，那么就可以，方便使用。 此外，还需要在请求中设置headers, headers : &#123; &#39;Content-Type&#39;: &#39;application/x-www-form-urlencoded&#39; &#125; 这样，嗯。就是酱紫😯。 方案2: 手动序列化data对象. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;script&gt; var app = angular.module(&quot;httpDemo&quot;, []); app.service(&#x27;params&#x27;, function() &#123; this.jsonToString = function(obj) &#123; var query = &#x27;&#x27;, name, value, fullSubName, subName, subValue, innerObj, i; for (name in obj) &#123; value = obj[name]; if (value instanceof Array) &#123; for (i = 0; i &lt; value.length; ++i) &#123; subValue = value[i]; fullSubName = name + &#x27;[&#x27; + i + &#x27;]&#x27;; innerObj = &#123;&#125;; innerObj[fullSubName] = subValue; query += param(innerObj) + &#x27;&amp;&#x27;; &#125; &#125; else if (value instanceof Object) &#123; for (subName in value) &#123; subValue = value[subName]; fullSubName = name + &#x27;[&#x27; + subName + &#x27;]&#x27;; innerObj = &#123;&#125;; innerObj[fullSubName] = subValue; query += param(innerObj) + &#x27;&amp;&#x27;; &#125; &#125; else if (value !== undefined &amp;&amp; value !== null) query += encodeURIComponent(name) + &#x27;=&#x27; + encodeURIComponent(value) + &#x27;&amp;&#x27;; &#125; return query.length ? query.substr(0, query.length - 1) : query; &#125; &#125;); app.controller(&quot;httpDemoController&quot;, function($scope, $http, params) &#123; $scope.data = &#123; name: &quot;lomoa&quot;, age: 22, sex: &quot;male&quot; &#125;; $http(&#123; method: &quot;POST&quot;, data: params.jsonToString($scope.data), headers: &#123; &#x27;Content-Type&#x27;: &#x27;application/x-www-form-urlencoded&#x27; &#125;, url: &quot;./data.json&quot; &#125;).then(function successFn(response) &#123; $scope.names = response.data.sites; &#125;, function failFn(response) &#123; //do nothing here if fail &#125;); &#125;); &lt;/script&gt; headers必须要设置，无论是方案1还是方案2 !!! 抓包查看请求传递的参数: > 方案2 完整Demo 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;meta property=&quot;og:site_name&quot; content=&quot;Demo&quot; /&gt; &lt;meta property=&quot;og:type&quot; content=&quot;demo&quot;&gt; &lt;meta property=&quot;og:author&quot; content=&quot;admin@lomo.space&quot;&gt; &lt;meta property=&quot;og:publisher&quot; content=&quot;Wechat@Lomo&quot; /&gt; &lt;meta property=&quot;og:masterEmail&quot; content=&quot;lomo@lomo.space&quot; /&gt; &lt;title&gt;HTTP请求传递参数问题&lt;/title&gt; &lt;script src=&quot;./lib/angular-1.6.3.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;demo&quot; ng-app=&quot;httpDemo&quot; ng-controller=&quot;httpDemoController&quot;&gt; &lt;ul&gt; &lt;li ng-repeat=&quot;x in names&quot;&gt; &#123;&#123;x.Name + &#x27;, &#x27; + x.Country&#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script&gt; var app = angular.module(&quot;httpDemo&quot;, []); app.service(&#x27;params&#x27;, function() &#123; this.jsonToString = function(obj) &#123; var query = &#x27;&#x27;, name, value, fullSubName, subName, subValue, innerObj, i; for (name in obj) &#123; value = obj[name]; if (value instanceof Array) &#123; for (i = 0; i &lt; value.length; ++i) &#123; subValue = value[i]; fullSubName = name + &#x27;[&#x27; + i + &#x27;]&#x27;; innerObj = &#123;&#125;; innerObj[fullSubName] = subValue; query += param(innerObj) + &#x27;&amp;&#x27;; &#125; &#125; else if (value instanceof Object) &#123; for (subName in value) &#123; subValue = value[subName]; fullSubName = name + &#x27;[&#x27; + subName + &#x27;]&#x27;; innerObj = &#123;&#125;; innerObj[fullSubName] = subValue; query += param(innerObj) + &#x27;&amp;&#x27;; &#125; &#125; else if (value !== undefined &amp;&amp; value !== null) query += encodeURIComponent(name) + &#x27;=&#x27; + encodeURIComponent(value) + &#x27;&amp;&#x27;; &#125; return query.length ? query.substr(0, query.length - 1) : query; &#125; &#125;); app.controller(&quot;httpDemoController&quot;, function($scope, $http, params) &#123; $scope.data = &#123; name: &quot;lomoa&quot;, age: 22, sex: &quot;male&quot; &#125;; $http(&#123; method: &quot;POST&quot;, data: params.jsonToString($scope.data), headers: &#123; &#x27;Content-Type&#x27;: &#x27;application/x-www-form-urlencoded&#x27; &#125;, url: &quot;./data.json&quot; &#125;).then(function successFn(response) &#123; $scope.names = response.data.sites; &#125;, function failFn(response) &#123; //do nothing here if fail &#125;); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 其它使用jQuery的高版本(带Promise的) ajax请求，需要将参数以Form(key-&gt;value)形式请求时，需要添加一个参数。默认是json形式 即：platform=1&amp;channelType=22a (抓包或浏览器开发者工具查看到的都是这种形式) 修改为Form Data形式: 添加一个参数 headers, 然后再次请求查看浏览器 XHR即可看到接口请求时携带的 Form Data形式的参数。 123456789101112131415var data = &#123; a: 112, b: 344, c: &quot;xx&quot;&#125;;$.ajax(&#123; url: xx, type: &#x27;POST&#x27;, data: data headers: &#123; &#x27;Content-Type&#x27;: &#x27;application/x-www-form-urlencoded&#x27; &#125;, // .... // ....&#125;);","categories":[{"name":"study","slug":"study","permalink":"http://lomo.space/categories/study/"}],"tags":[{"name":"angularjs","slug":"angularjs","permalink":"http://lomo.space/tags/angularjs/"}]},{"title":"js operate cookie","slug":"js-operate-cookie","date":"2016-10-29T16:36:08.000Z","updated":"2022-01-14T11:40:22.882Z","comments":true,"path":"2016/10/30/js-operate-cookie/","link":"","permalink":"http://lomo.space/2016/10/30/js-operate-cookie/","excerpt":"","text":"JavaScript操作Cookie JavaScript操作cookie 通常都是增删改查和对数据库的常用操作方法类似. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172//define cookieAction to manage all the actions for cookie on client//current Unix timestamp : Math.round(new Date().getTime()/1000)//getTime()返回数值的单位是毫秒//For PRC, using GMT-&gt;UTC not accuratevar cookieAction = &#123; /** * [setCookie create and save cookie] * @param &#123;[type]&#125; c_name [description] * @param &#123;[type]&#125; value [description] * @param &#123;[type]&#125; expiredays [description] */ setCookie: function(c_name, value, expiredays) &#123; var exdate = new Date(); exdate.setDate(exdate.getDate() + expiredays); document.cookie = c_name + &quot;=&quot; + escape(value) + ((expiredays === null) ? &quot;&quot; : &quot;;expires=&quot; + exdate.toString() + &quot;;path=/&quot;); &#125;, /** * [getCookie get the cookie in browser, if it&#x27;s still available] * @param &#123;[type]&#125; c_name [description] * @return &#123;[type]&#125; [description] */ getCookie: function(c_name) &#123; if (document.cookie.length &gt; 0) &#123; c_start = document.cookie.indexOf(c_name + &quot;=&quot;); if (c_start != -1) &#123; c_start = c_start + c_name.length + 1; c_end = document.cookie.indexOf(&quot;;&quot;, c_start); if (c_end == -1) c_end = document.cookie.length; return unescape(document.cookie.substring(c_start, c_end)); &#125; &#125; return &quot;&quot;; &#125;, //how to check cookie is available or if it is expired? //if the cookie exist, there must be could using getCookie Fn to get the value, if it expired, it wouldn&#x27;t get it. /** * [removeCookie description] * @param &#123;[type]&#125; c_name [description] * @return &#123;[type]&#125; [description] */ removeCookie: function(c_name) &#123; cookieAction.setCookie(c_name, &quot;&quot;, -1); // var oDate = new Date(); // oDate.setDate(new Date().getDate() - 1); // document.cookie = c_name + &quot;=123;expires=&quot; + oDate + &quot;;path=/&quot;; &#125;, checkCookie: function(c_name) &#123; var info = cookieAction.getCookie(c_name); if (info == &quot;&quot;) &#123; return false; &#125; else &#123; return info; &#125; &#125;&#125;; 以上对Cookie的常用操作进行了基本封装，添加setCookie、删除removeCookie、检查是否有效&#x2F;存在checkCookie、获取cookie值getCookie， 基本就是这几种方法对cookie的反复操作.","categories":[{"name":"program","slug":"program","permalink":"http://lomo.space/categories/program/"}],"tags":[{"name":"js","slug":"js","permalink":"http://lomo.space/tags/js/"},{"name":"cookie","slug":"cookie","permalink":"http://lomo.space/tags/cookie/"}]},{"title":"centos upgrade php","slug":"centos-upgrade-php","date":"2016-10-25T01:32:14.000Z","updated":"2022-01-14T11:40:22.876Z","comments":true,"path":"2016/10/25/centos-upgrade-php/","link":"","permalink":"http://lomo.space/2016/10/25/centos-upgrade-php/","excerpt":"","text":"CentOS 升级PHP卸载、删除旧依赖 查看系统版本，方便后边选择对应的包 `lsb_release -a` 停止服务 `service httpd stop` 卸载安装包 `看图⬇` ![img](http://oluzh4sa6.bkt.clouddn.com/GitHubPages/article/uninstall-old-php.png) 删除依赖 ![img](http://oluzh4sa6.bkt.clouddn.com/GitHubPages/article/rpm-dependencies.png) 删除一些其它相关包 ![img](http://oluzh4sa6.bkt.clouddn.com/GitHubPages/article/delete-others.png) 更新安装源12345678Centos 5.X： rpm -Uvh http://mirror.webtatic.com/yum/el5/latest.rpmCentOs 6.x rpm -Uvh http://mirror.webtatic.com/yum/el6/latest.rpmCentOs 7.X rpm -Uvh https://mirror.webtatic.com/yum/el7/epel-release.rpm rpm -Uvh https://mirror.webtatic.com/yum/el7/webtatic-release.rpm 安装制定版本PHP123456##5.5版本PHP yum install php55w.x86_64 php55w-cli.x86_64 php55w-common.x86_64 php55w-gd.x86_64 php55w-ldap.x86_64 php55w-mbstring.x86_64 php55w-mcrypt.x86_64 php55w-mysql.x86_64 php55w-pdo.x86_64##5.6版本PHP yum install php56w.x86_64 php56w-cli.x86_64 php56w-common.x86_64 php56w-gd.x86_64 php56w-ldap.x86_64 php56w-mbstring.x86_64 php56w-mcrypt.x86_64 php56w-mysql.x86_64 php56w-pdo.x86_64##7.0版本PHP yum install php70w.x86_64 php70w-cli.x86_64 php70w-common.x86_64 php70w-gd.x86_64 php70w-ldap.x86_64 php70w-mbstring.x86_64 php70w-mcrypt.x86_64 php70w-mysql.x86_64 php70w-pdo.x86_64 安装FPM1234## 选择对应版本即可 yum install php55w-fpm yum install php56w-fpm yum install php70w-fpm","categories":[{"name":"read","slug":"read","permalink":"http://lomo.space/categories/read/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://lomo.space/tags/PHP/"},{"name":"CentOS","slug":"CentOS","permalink":"http://lomo.space/tags/CentOS/"}]},{"title":"angularjs img","slug":"angularjs-img","date":"2016-10-19T11:58:05.000Z","updated":"2022-01-14T11:40:22.874Z","comments":true,"path":"2016/10/19/angularjs-img/","link":"","permalink":"http://lomo.space/2016/10/19/angularjs-img/","excerpt":"","text":"AngularJS动态修改img的URL 项目过程中，在首页面的左上角Logo可以达到配置化(或通过配置接口进行显示灯). 主要问题在directive 中相对路径问题. 项目目录结构: 123456789101112131415161718192021222324252627282930313233343536#app 源码目录下├── css│ ├── fishBone.css│ └── imports.css├── favicon.ico├── img│ ├── arrow.png│ ├── jdb_blue_logo.png│ ├── jdb_logo.png│ ├── line-first.png│ ├── line-point.png│ ├── loading.gif│ └── title.png├── index.html├── js│ ├── controllers│ ├── directives│ ├── filters│ ├── main.js│ ├── modules│ ├── require.js│ └── services├── lib│ ├── angular│ ├── bootstrap│ ├── fishBone.js│ ├── font-awesome-4.7.0│ ├── jquery│ └── layui└── views ├── autoPublishFishBone.html ├── autoPublishFooter.html ├── autoPublishNavigationBar.html └── autoPublishVersion.html15 directories, 18 files 在app目录下，需要的jdb_blue_logo.png 与index.html其相对路径为img/jdb_blue_logo.png。 1234567891011121314151617181920#js目录├── controllers│ └── index.controller.js├── directives│ ├── indexFishBone.directive.js│ ├── indexFooter.directive.js│ ├── indexNavigationBar.directive.js│ └── indexVersion.directive.js├── filters│ └── fishBone.filter.js├── main.js├── modules│ └── fishBone.module.js├── require.js└── services ├── api.service.js ├── fishBone.service.js └── utils.service.js5 directories, 12 files views/autoPublishNavigationBar 12345&lt;!-- img部分代码 --&gt;&lt;a class=&quot;nav ar-brand&quot; href=&quot;./&quot;&gt; &lt;img title=&quot;logo&quot; ng-src=&quot;&#123;&#123;logoSrc&#125;&#125;&quot;&gt; &lt;span class=&quot;sub-title&quot;&gt;XXLogoName&lt;/span&gt;&lt;/a&gt; 对应的directive 12345678910111213141516171819202122232425262728293031323334353637jdbAutoPublisherApps.directive(&#x27;jdbAutoPublishNavBar&#x27;, function() &#123; return &#123; restrict: &#x27;EAC&#x27;, replace: true, // scope: &#123;&#125;, //与$scope隔离 templateUrl: &#x27;././views/autoPublishNavigationBar.html&#x27;, //路径啊！！！ link: function(scope, elem, attr) &#123; scope.logoSrc = &quot;img/jdb_blue_logo.png&quot;; &#125; // compile: function(tElement, tAttrs, transclude) &#123; // return &#123; // pre: function(scope, iElement, iAttrs, controller) &#123; // // console.log(&quot;pre&quot;); // // scope.Circle = &#123;&#125;; // // scope.colorArr = [&#x27;#F89782&#x27;, &#x27;#1A84CE&#x27;, &#x27;#F7A259&#x27;, &#x27;#43A6DA&#x27;, &#x27;#F9BF3B&#x27;, &#x27;#88C7CC&#x27;, &#x27;#EF6D5F&#x27;, &#x27;#60A96E&#x27;, &#x27;#F03852&#x27;, &#x27;#3A9284&#x27;]; // console.log(&#x27;pre-compile -- directive.&#x27;); // // console.log(scope.fishData); // &#125;, // post: function(scope, iElement, iAttrs, controller) &#123; // // console.log(&quot;post&quot;); // // console.log(scope.colorArr); // console.log(&#x27;post-compile -- directive.&#x27;); // &#125; // &#125;; // &#125;, // controller: function($scope) &#123; // // console.log(&quot;1.directive -- controller&quot;); // &#125;, // link: function($scope) &#123; // console.log(&quot;2.directive -- link&quot;); //不执行！ // &#125;, // compile: function($scope) &#123; // // console.log(&quot;3.directive -- compile&quot;); // &#125; &#125;;&#125;); 注意directive最终会被引用到首页，所有,此处logoSrc的地址为相对index.html而言的路径.","categories":[{"name":"study","slug":"study","permalink":"http://lomo.space/categories/study/"}],"tags":[{"name":"angularjs","slug":"angularjs","permalink":"http://lomo.space/tags/angularjs/"}]},{"title":"ssh login without password","slug":"ssh-login-without-password","date":"2016-10-18T09:13:51.000Z","updated":"2022-01-14T11:40:22.887Z","comments":true,"path":"2016/10/18/ssh-login-without-password/","link":"","permalink":"http://lomo.space/2016/10/18/ssh-login-without-password/","excerpt":"","text":"SSH远程免密码登录Linux主机A为本地主机(即用于控制其他主机的机器) ; B为远程主机(即被控制的机器Server), 假如ip为100.73.21.32 ; A和B的系统都是Linux。 A机器在A机器(本地机器)上： First, $ ssh-keygen -t rsa 连续三次回车,即在本地生成了公钥和私钥,不设置密码; Second, $ ssh root@你的Linux主机IP地址 &quot;mkdir .ssh&quot; ##输入密码 Third, scp ~/.ssh/id_rsa.pub root@你的Linux主机IP地址:.ssh/id_rsa.pub ##输入密码 在B机器(远端Linux)上: 在B机器touch /root/.ssh/authorized_keys cat /root/.ssh/id_rsa.pub &gt;&gt; /root/.ssh/authorized_keys 将id_rsa.pub的内容追加到authorized_keys 中; A机器返回A机器终端： ssh root@远端机器IP 成功登陆！ 也可以在本地机器加入alias，如： alias clientTools=&quot;ssh root@IP地址","categories":[{"name":"program","slug":"program","permalink":"http://lomo.space/categories/program/"}],"tags":[{"name":"SSH","slug":"SSH","permalink":"http://lomo.space/tags/SSH/"},{"name":"Login","slug":"Login","permalink":"http://lomo.space/tags/Login/"}]},{"title":"Java Create Object By Reflect","slug":"Java-Create-Object-By-Reflect","date":"2016-10-14T10:40:41.000Z","updated":"2022-01-14T11:40:22.870Z","comments":true,"path":"2016/10/14/Java-Create-Object-By-Reflect/","link":"","permalink":"http://lomo.space/2016/10/14/Java-Create-Object-By-Reflect/","excerpt":"","text":"通过反射创建类实例通常有2种方式，使用Class类的newInstance方法，或使用Constructor类的newInstance方法。 但是，Class类的newInstance方法通常只能适用于无参构造器的类。Constructor类的newInstance方法既可用于无参构造器，也可用于有参构造器. 推荐使用后者 直接看示例。 demo.java demo类：一个显式的无参构造器, 2个含参的构造器, public、protected、private级别的方法各一个, 另一个public级别的重载 12345678910111213141516171819202122232425262728293031323334package javaClassExercise.newObjectStyle;/** * Created by lomo. */public class demo &#123; private demo() &#123; System.out.println(&quot;demo&#x27;s constructor is called.&quot;); &#125; private demo(int a, int b) &#123; System.out.println(a+b); &#125; private demo(String s, Integer i) &#123; System.out.println(s + i); &#125; public void printSth() &#123; System.out.println(&quot;demo Class printSth...&quot;); &#125; public void printSth(String s) &#123; System.out.println(s); &#125; private void printa() &#123; System.out.println(&quot;private method called&quot;); &#125; protected void printa(Integer a) &#123; System.out.println(a); &#125;&#125; demoTest.java 将Class.NewInstance() 和 Constructor.newInstance() 两种创建新实例的方式进行了简单的“面向过程式”的封装[之所以说是面向过程，是因为这2个简单封装的方法，严格来讲未达到是封装的标准，里面很多参数都是写的固定的!!!] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778package javaClassExercise.newObjectStyle;import java.lang.reflect.Constructor;/** * Created by lomo. * * 推荐使用 通过Constructor.newInstance()创建新的类实例 */public class demoTest &#123; public static void main(String[] args) &#123; demoTest demoTest = new demoTest(); System.out.println(&quot;通过Class.NewInstance()调用私有构造函数:&quot;); demoTest.newInstanceByClassNewInstance(); //失败, 如果无参构造器为public的就可以调用. System.out.println(&quot;通过Constructor.NewInstance()调用私有构造函数:&quot;); demoTest.newInstanceByConstructorNewInstance(); // 同时调用demo类的无参和有参构造器 //输出： // demo&#x27;s constructor is called. // 9 &#125; /*通过Class.NewInstance()创建新的类示例*/ public void newInstanceByClassNewInstance() &#123; try &#123; /* 当前包名为javaClassExercise.newObjectStyle，必须使用全路径 */ demo demo = (demo)Class.forName(&quot;javaClassExercise.newObjectStyle.demo&quot;).newInstance(); &#125;catch (Exception e) &#123; System.out.println(&quot;通过Class.NewInstance()调用私有构造函数【失败】&quot;); //e.printStackTrace(); &#125; &#125; /*通过Constructor.newInstance()创建新的类示例*/ public void newInstanceByConstructorNewInstance() &#123; try &#123; Class c = Class.forName(&quot;javaClassExercise.newObjectStyle.demo&quot;); Constructor c0 = c.getDeclaredConstructor(); // 获得构造器对象 c0.setAccessible(true); // 关闭JDK安全检查，提升反射速度 //调用私有、无参构造函数 demo demo0 = (demo)c0.newInstance(); demo0.printSth(&quot;lomo&quot;); demo0.printa(6666); // protected级别的可以直接调用 //printa 这个private级别的方法无法被直接调用 /* Method[] c2 = c.getDeclaredMethods(); for(int i = 0; i &lt; c2.length; i++) &#123; //System.out.println(&quot;函数名：&quot; + c2[i].getName()); //获得除构造器以外的所有函数名，包括private //System.out.println(&quot;函数名：&quot; + c2[i].getReturnType()); //获得除构造器以外的所有函数的返回类型，包括private //System.out.println(&quot;函数名：&quot; + c2[i]); // 获得所有方法(除构造器)的方法体不包括&#123;&#125; System.out.println(&quot;函数名：&quot; + Modifier.toString(c2[i].getModifiers())); // 获得所有函数的访问权限 &#125; */ /* 调用参数、私有构造函数*/ //传入参数 Constructor c1 = c.getDeclaredConstructor(new Class[] &#123;int.class, int.class&#125;); c1.setAccessible(true); demo demo1 = (demo)c1.newInstance(new Object[]&#123;4,5&#125;); demo1.printSth(); &#125;catch (Exception e) &#123; System.out.println(&quot;通过Constructor.NewInstance()调用私有构造函数【失败】&quot;); //e.printStackTrace(); &#125; &#125;&#125; 运行输出结果： 12345678通过Class.NewInstance()调用私有构造函数:通过Class.NewInstance()调用私有构造函数【失败】通过Constructor.NewInstance()调用私有构造函数:demo&#x27;s constructor is called.lomo66669demo Class printSth... 通过Class.newInstance() 方式创建新实例失败，因为demo类构造函数为私有，如果demo类无显式声明的构造函数，或显式声明无参构造器，则可以使用这种方式创建新实例。 修改demo类的无参构造器为public，就可以在demoTest中通过上述方式创建新实例。 123public demo() &#123; System.out.println(&quot;demo&#x27;s constructor is called.&quot;); &#125; 123# 运行第一种创建实例的方式 输出：通过Class.NewInstance()调用私有构造函数:demo&#x27;s constructor is called. 通过Constructor.newInstance() 方式创建新实例，无论demo类的构造器是否private、无论是否有误参数 都可以。 反射机制的使用：工厂模式中，Factory类中使用反射机制，添加新类时，就不需要需改工厂类。 关于setAccessible， 点此查看","categories":[{"name":"program","slug":"program","permalink":"http://lomo.space/categories/program/"}],"tags":[{"name":"java","slug":"java","permalink":"http://lomo.space/tags/java/"},{"name":"reflect","slug":"reflect","permalink":"http://lomo.space/tags/reflect/"}]},{"title":"MacOXS Install JDK 1.7-1.8","slug":"MacOXS-Install-JDK-1-7-1-8","date":"2016-10-14T02:01:37.000Z","updated":"2022-01-14T11:40:22.871Z","comments":true,"path":"2016/10/14/MacOXS-Install-JDK-1-7-1-8/","link":"","permalink":"http://lomo.space/2016/10/14/MacOXS-Install-JDK-1-7-1-8/","excerpt":"","text":"Mac OSX同时安装JDK 1.7&#x2F;1.8准备工作 JDK 1.7按照常规安装完毕。 环境变量配置 ~/.bash_profile 配置如下： 1234567891011121314151617JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.7.0_79.jdk/Contents/HomePATH=$JAVA_HOME/bin:$PATHMAVEN_HOME=/Users/lomo/env/apache-maven-3.3.9PATH=$MAVEN_HOME/bin:$PATHexport ANDROID_HOME=/Users/lomo/Documents/IntelliJ/sdk/android-sdk-macosxexport PATH=$&#123;PATH&#125;:/Users/lomo/Documents/IntelliJ/sdk/android-sdk-macosx/toolsexport PATH=$&#123;PATH&#125;:/Users/lomo/Documents/IntelliJ/sdk/android-sdk-macosx/platform-toolsexport HOMEBREW_CASK_OPTS=&quot;--caskroom=/opt/homebrew-cask/Caskroom&quot;alias mysql=/usr/local/mysql/bin/mysqlalias mysqladmin=/usr/local/mysql/bin/mysqladminPATH=/Applications/MongoDB.app/Contents/Resources/Vendor/mongodb:$PATH export MAVEN_HOMEexport JAVA_HOMEexport PATHexport TRAVIS=1 下载安装JDK 1.8 http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html 下载后双击安装1.8即可。 安装完后，在/Library/Java/JavaVirtualMachines 可以看到多出来的JDK 1.8版的目录文件夹. 配置多版本JDK环境变量123456789101112131415161718export JAVA_7_HOME=/Library/Java/JavaVirtualMachines/jdk1.7.0_79.jdk/Contents/Homeexport JAVA_8_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_121.jdk/Contents/HomeMAVEN_HOME=/Users/lomo/env/apache-maven-3.3.9PATH=$MAVEN_HOME/bin:$PATHexport ANDROID_HOME=/Users/lomo/Documents/SDK/sdk/android-sdk-macosxexport PATH=$&#123;PATH&#125;:/Users/lomo/Documents/SDK/sdk/android-sdk-macosx/toolsexport PATH=$&#123;PATH&#125;:/Users/lomo/Documents/SDK/sdk/android-sdk-macosx/platform-toolsexport HOMEBREW_CASK_OPTS=&quot;--caskroom=/opt/homebrew-cask/Caskroom&quot;alias mysql=/usr/local/mysql/bin/mysqlalias mysqladmin=/usr/local/mysql/bin/mysqladminalias jdk7=&#x27;export JAVA_HOME=$JAVA_7_HOME&#x27; # 使用alias轻松切换JDK版本alias jdk8=&#x27;export JAVA_HOME=$JAVA_8_HOME&#x27;PATH=/Applications/MongoDB.app/Contents/Resources/Vendor/mongodb:$PATH export MAVEN_HOMEexport PATHexport TRAVIS=1 export JAVA_HOME=$JAVA_7_HOME 默认还是使用JDK1.7版本 配置完毕！ 测试终端输入alias，即可切换系统环境的默认JDK版本。如图： IDE配置Eclipse 或 Intellij Idea的JDK 需要手动配置对应的Project的JDK，默认新建的是使用之前默认的JDK1.7，所以可以手动切换一下。 如下： [Step1: [Step2:","categories":[{"name":"write","slug":"write","permalink":"http://lomo.space/categories/write/"}],"tags":[{"name":"Mac","slug":"Mac","permalink":"http://lomo.space/tags/Mac/"},{"name":"JDK","slug":"JDK","permalink":"http://lomo.space/tags/JDK/"}]},{"title":"java reflect","slug":"java-reflect","date":"2016-10-13T16:05:20.000Z","updated":"2022-01-14T11:40:22.881Z","comments":true,"path":"2016/10/14/java-reflect/","link":"","permalink":"http://lomo.space/2016/10/14/java-reflect/","excerpt":"","text":"Java反射学习笔记基本概念 在Java应用程序运行中，对于任意一个类，都能知道这个类的所有属性和方法；对于任意一个对象，都能调用它的任意一个方法和属性。这种动态获取信息和动态调用对象的方法的功能, 称为反射. 反射的核心就是提供了一种在 应用程序运行时去操作这个类的成员属性、成员方法 的方法. Reflection(反射), 在Java中，是指我们可以在运行时去加载、探知、使用编译期间未知的classes，就是说，Java程序可以加载一个运行时才得知名称的class，获得其构造，并生成对象实体. 反射的功能Java反射机制主要提供了以下功能： ①运行时判断一个对象所属的类； （通过一个对象获得该对象的完整的包名和类名） ②运行时构造一个类的对象； ③运行时判断任意一个类所具有的属性、方法； ④运行时调用任意一个对象的方法； ⑤生成动态代理 反射示例示例1 – 运行时判断一个对象所属的类&#x2F;获得该对象的完整的包名和类名 12345678910111213public class TestReflect &#123; public static void main(String... arg) &#123; TestReflect testReflect = new TestReflect(); System.out.println(testReflect.getClass()); // class javaClassExercise.fanshe.TestReflect System.out.println(testReflect.getClass().getName()); // javaClassExercise.fanshe.TestReflect (包名+类名) System.out.println(testReflect.getClass().getSimpleName()); // TestReflect, 直接获取类名 System.out.println(testReflect.getClass().getPackage()); // package javaClassExercise.fanshe, 直接获取包名 System.out.println(testReflect.getClass().getSuperclass()); // class java.lang.Object System.out.println(testReflect.getClass().getClass()); // class java.lang.Class &#125;&#125; 通过反射创建对象见另一篇 文章 反射的意义为什么存在反射？ 一般地，自定义的类，知道其内部信息：属性、方法，或需要使用的类import进来或在同一个包内，使用时直接new一个该类的对象； 反射是不知道类的具体内部情况，可能存在无参构造器也可能是含参构造器，那么我们如何获得该类的对象呢？new? new的时候构造器如何处理呢？如果是含参数的构造器，那么参数类型呢？参数个数呢？ 所以，Java的提供了反射机制来避免、解决此问题，借用反射机制不用去考虑某个类(通常是框架中的而非自己写的)来获取这个类的实例对象。 关于 无参、含参构造器的类，利用反射创建其实例，参考博文 – 通过反射创建类实例对象：http://lomo.space/2016/10/14/Java-Create-Object-By-Reflect/ 反射相关的类反射中可能用来的类： 分别是：Field、Constructor、Method、Class、Object； Field类：提供有关类或接口的属性的信息，以及对它的动态访问权限。反射的字段可能是一个类（静态）属性或实例属性，简单的理解可以把它看成一个封装反射类的属性的类。 Constructor类：提供关于类的单个构造方法的信息以及对它的访问权限。 这个类和Field类不同，Field类封装了反射类的属性，而Constructor类则封装了反射类的构造方法。 Method类：提供关于类或接口上单独某个方法的信息。所反映的 方法可能是类方法或实例方法（包括抽象方法）。 这个类不难理解，它是用来封装反射类方法的一个类。 Class类：类的实例表示正在运行的 Java 应用程序中的类和接口。枚举是一种类，注释是一种接口。每个数组属于被映射为 Class 对象的一个类，所有具有相同元素类型和维数的数组都共享该 Class 对象。 Object类：每个类都使用 Object 作为超类。所有对象（包括数组）都实现这个类的方法。","categories":[{"name":"program","slug":"program","permalink":"http://lomo.space/categories/program/"}],"tags":[{"name":"java","slug":"java","permalink":"http://lomo.space/tags/java/"},{"name":"reflect","slug":"reflect","permalink":"http://lomo.space/tags/reflect/"}]},{"title":"Nginx Reverse Proxy","slug":"Nginx-Reverse-Proxy","date":"2016-10-12T16:00:40.000Z","updated":"2022-01-14T11:40:22.872Z","comments":true,"path":"2016/10/13/Nginx-Reverse-Proxy/","link":"","permalink":"http://lomo.space/2016/10/13/Nginx-Reverse-Proxy/","excerpt":"","text":"Nginx反向代理使用小记 只有一台服务器，这台服务器上部署了LAMP服务环境，占用了默认的80端口，而且本服务器有域名映射到本机，可以方便地使用域名访问资源. 除了上述的服务外 Q1. 本服务器部署了go语言开发的服务，占用了3000端口，每次访问都需要domain:3000来访问，觉得很别扭，希望可以省略掉端口号!(假设该服务器domain为:lomo.space), 期望可以以lomo.space&#x2F;go这种URL去访问。 Q2. 在另一个虚拟主机上部署了Java web应用， 需要使用和这台主机同样的域名去访问此应用服务期望可以以lomo.space&#x2F;another来访问这个Java应用，而不是IP地址的形式访问。 Q: 如何解决这2个需求、问题？ A: Nginx 简介Nginx是一个俄罗斯人开发的高性能、轻量级的HTTP服务器、反向代理(Reverse Proxy)服务器、电子邮件代理服务器. Nginx最初是俄罗斯人为Rambler.ru站点开发的服务器, 那么第一呢？哈哈，第一当然是Yandex.ru(已合并第二大mail.ru)。 Nginx特点：内存占用少、并发能力强, 还开源！ 所以很多大公司的web服务器都是基于Nginx二次开发，比如淘宝的Tengine. 其它更多介绍请看维基百科. 安装mac安装Mac上安装，在本地测试Nginx相关服务功能。 1brew install nginx 安装成功后的信息类似如下： 12345678910111213 Docroot is: /usr/local/var/www The default port has been set in /usr/local/etc/nginx/nginx.conf to 8080 so that nginx can run without sudo. nginx will load all files in /usr/local/etc/nginx/servers/. To have launchd start nginx now and restart at login: brew services start nginx Or, if you don&#x27;t want/need a background service you can just run: nginx ==&gt; Summary🍺 /usr/local/Cellar/nginx/1.10.3: 8 files, 980.9KB 根据这些提示信息就可以得出相关信息，比如安装路径，配置文件等。 ①Nginx服务安装路径： /usr/local/Cellar/nginx/1.10.3 ②配置文件路径： /usr/local/etc/nginx/nginx.conf ③服务器默认资源文件等路径: /usr/local/var/www ④Nginx 日志log存放路径： /usr/local/var/log/nginx 配置测试安装完后，就可以直接启动， nginx直接启动即可。 本地访问 http://localhost:8080/ 即可看到相关提示信息。 修改配置文件： /usr/local/etc/nginx/nginx.conf 将监听端口改为8081 重启：nginx -s reload 重新加载配置文件即可. 测试， http://localhost:8081/, 查看效果。 默认，OSX系统通过brew安装的Nginx，所有配置文件未分类，为了便于管理，在/usr/local/etc/nginx 单独创建一个conf.d文件夹用来管理所有server配置文件。 12345cd /usr/local/etc/nginxmkdir conf.dcd conf.dtouch default.conf # 在此文件中将/usr/local/etc/nginx目录下nginx.conf里的默认server配置剪切到default.conf文件中 修改/usr/local/etc/nginx/nginx.conf文件： 12include /usr/local/etc/nginx/conf.d/*.conf;#表示默认加载conf.d文件夹下的所有配置文件. nginx -s reload， 重新打开localhost:8080即可看到一样ok ! 在之前新建的conf.d文件夹下创建一个test.conf文件，并测试一个请求转发功能。 1234567891011server&#123; listen 8081; server_name localhost; location / &#123; proxy_pass https://www.baidu.com/; &#125;&#125;# 使用请求转发，使得访问localhost:8081时(也就是在本机上访问这个域名，实际可页面显示的是proxy_pass域名里的页面，其所有功能不受影响)#http://localhost:8081 本机访问 localhost:8081发现，可以直接访问百度首页！！！😁 Linux安装以CentOS 6.5上安装为例。 yum安装/etc/yum.repos.d 目录下，创建 nginx.repo 文件； 在此repo文件写入一下内容： 12345[nginx]name=nginx repobaseurl=http://nginx.org/packages/centos/$releasever/$basearch/gpgcheck=0enabled=1 安装 yum install nginx -y 安装完后，nginx -v 显示版本号即Ok。 显示已安装的版本是：nginx&#x2F;1.10.2 源码安装参考网上示例即可. 配置测试安装后，相关配置配件位于： 12/etc/nginx/config.d #文件夹下[主配置文件]/etc/nginx/default.d #[用户配置文件] Nginx 启动路径:/etc/init.d/nginx start 由于Linux上安装的Nginx默认监听的是80端口，而本机器之前已经部署了LAMP服务环境，80端口已被占用。 修改配置文件：vim /etc/nginx/conf.d/default.conf 将端口改为81测试，重启提示错误，报错信息类似如下：nginx: [emerg] socket() [::]:81 failed (97: Address family not supported by protocol 将server下的第二行listen [::]:81， 重新启动，显示[OK]，即可访问http://domain:81，看到Nginx欢迎页面. 如图示: > 而本服务器是虚拟机，只有一个IP地址，无法使用IP来共存80端口。 解决问题Q1&amp;Q2解决方案: 将Apache监听的默认80端口该为8080端口，所有应用服务前都加一层服务器Nginx，用Nginx来监听80端口，使用Nginx做转发和代理。 即：将Apache默认的80端口改为8080，使用Nginx 去监听默认的80端口，将所有静态资源html&#x2F;css&#x2F;js 的http请求全部打倒Nginx，使用Nginx去做转发静态资源请求到Apache的8080。 step1: vi /etc/httpd/conf/httpd.conf 修改Apache配置监听端口。 step2: 修改Nginx配置。 完整配置文件如下： 123456789101112131415161718192021server&#123; listen 80; server_name lomo.space; #静态资源html/css/js location / &#123; proxy_pass http://lomo.space:8080; &#125; #php应用 location ~ \\.php$ &#123; proxy_pass http://lomo.space:8080; &#125; #java应用 location /another/ &#123; proxy_pass http://anotherIP:端口/xxx/xx/xxxx.jsp; &#125; #go应用 location /go/ &#123; proxy_pass http://lomo.space:3000/; &#125; &#125; 此时，直接访问 lomo.space，查看发现Http返回信息的server变为了Nginx. 当通过浏览器或curl该URL时，Nginx通过proxy_pass 打到apache的8080上。 自定义Error Page使用Apache自定义: vim /etc/httpd/conf/httpd.conf 找到ErrorDocument 关键词，然后根据提示信息配置即可。 完毕。","categories":[{"name":"study","slug":"study","permalink":"http://lomo.space/categories/study/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"http://lomo.space/tags/nginx/"}]},{"title":"sublime 3 on mac","slug":"sublime-3-on-mac","date":"2016-10-01T16:44:12.000Z","updated":"2022-01-14T11:40:22.887Z","comments":true,"path":"2016/10/02/sublime-3-on-mac/","link":"","permalink":"http://lomo.space/2016/10/02/sublime-3-on-mac/","excerpt":"","text":"Sublime3 插件主题Theme - Hero 文件图标： A File Icon 1234567891011121314&#123; &quot;color_scheme&quot;: &quot;Packages/Theme - Hero/Hero Dark.tmTheme&quot;, &quot;font_size&quot;: 13, &quot;ignored_packages&quot;: [ &quot;Vintage&quot; ], &quot;indent_guide_options&quot;: [ &quot;draw_normal&quot;, &quot;draw_active&quot; ], &quot;theme&quot;: &quot;Hero Dark.sublime-theme&quot;&#125; 插件Emmet,快速编写html&#x2F;css的方法; html5,支持hmtl5规范的插件包; Alignment,自动对齐代码，包括PHP、CSS、JavaScript语言; ColorPicker,拾色器;","categories":[{"name":"essay","slug":"essay","permalink":"http://lomo.space/categories/essay/"}],"tags":[{"name":"sublime","slug":"sublime","permalink":"http://lomo.space/tags/sublime/"}]},{"title":"read book of javascript-promise","slug":"read-book-of-javascript-promise","date":"2016-09-29T16:14:37.000Z","updated":"2022-01-14T11:40:22.886Z","comments":true,"path":"2016/09/30/read-book-of-javascript-promise/","link":"","permalink":"http://lomo.space/2016/09/30/read-book-of-javascript-promise/","excerpt":"","text":"JavaScript-Promise笔记创建Promise对象第一种创建方法： new Promise(fn) 返回一个Promise对象 在fn中指定异步等待处理：① 处理结果ok，调用resolve(value) ② 处理结果错误的话，调用reject(error Object) 1234567new Promise(function(resolve, reject)&#123; if(...) &#123; resolve(...); &#125;else &#123; reject(...); &#125;&#125;); 那么，返回的Promise对象如何进行下一步操作？ 用法： promise.then().catch(), then函数内为正常逻辑处理流程， catch函数内针对reject或其它异常处理。 第二种创建方法： Promise.resolve(value) &lt;&#x3D;&gt; new Promise(fn), promise.resolve()返回的也是一个Promise对象，所以也可以对其返回值进行链式调用,then, catch …. 关于then方法.then() 中指定的方法调用是异步进行的。 e.g. 1234567891011//test.jslet promise = new Promise(function(resolve)&#123; console.log(111); resolve(2);&#125;);promise.then(function(value)&#123; console.log(value);&#125;);console.log(&#x27;33333&#x27;); 运行test.js后发现结果为111，33333，2 分析： JavaScript代码会按照文件的从上到下的顺序执行，所以最开始, 执行输出为111，然后执行resolve(2), 这时，Promise对象状态已是确定状态，即：fulfilled被置为2. 接着执行promise.then()的代码，它注册了里面的回调函数，由于promise.then执行的时候promise对象已经是确定状态，理论上来讲，这个回调函数应该是同步被执行的，但是实际上是没有的！这时因为promise.then注册回调函数的时候，Promise对象不管其对象是否已经是确定状态，Promise都会以异步的方式调用回调函数，这是Promise设计上的规定！！！ Promise规范：异步函数只能被异步调用！ 因为Promise保证了每次调用都是异步进行的，所以不需要使用setTimeout来实现异步调用。 每次调用then都会返回一个新创建的promise对象，不管是then还是catch方法调用，都返回了一个新的promise对象。","categories":[{"name":"study","slug":"study","permalink":"http://lomo.space/categories/study/"}],"tags":[{"name":"js","slug":"js","permalink":"http://lomo.space/tags/js/"}]},{"title":"LAMP开发环境搭建[手记]","slug":"centos-install-LAMP-develop-env","date":"2016-09-21T07:05:46.000Z","updated":"2022-01-14T11:40:22.875Z","comments":true,"path":"2016/09/21/centos-install-LAMP-develop-env/","link":"","permalink":"http://lomo.space/2016/09/21/centos-install-LAMP-develop-env/","excerpt":"","text":"LAMP开发环境硬件：VPS 系统环境：CentOS 6.5 Apache安装1$ yum install httpd httpd-devel 控制台有提示y&#x2F;n时，输入y回车等待安装完成即可。 启动ApApache/etc/init.d/httpd start如果此时提示错误，像下图所示： 【解决方案： vi /etc/httpd/conf/httpd.conf 去掉 #注释，把domain改为localhost. (默认：www.example.com) 将Apache设置为开机启动：chkconfig httpd on MySQL安装1$ yum install mysql mysql-server mysql-devel 启动MySQL：/etc/init.d/mysqld start 设置密码mysql use mysql UPDATE user SET Password=PASSWORD(&#39;root&#39;) WHERE user=&#39;root&#39;; 以上方法设置MySQL的密码可能无效(本地机器远程连接此VPS的数据库时) 方案2： 登录此远程机器，执行MySQL安全配置：mysql_secure_installation 如图： 接着按照控制台提示输入root密码； 其它选项修改见以下截图配置，包括：匿名登录、是否允许从远端以root账户登录该数据库等。 创建远程登录账户12$ CREATE USER &#x27;用户名&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;密码&#x27;;$ GRANT ALL PRIVILEGES ON *.* TO &#x27;用户名&#x27;@&#x27;%&#x27;; 完成创建，即可远程以非root账户登录该数据库，访问其全县范围内的资源。 PHP安装1$ yum install php php-mysql php-common php-gd php-mbstring php-mcrypt php-devel php-xml Apache配置：配置Apache使其支持解析PHP类文件 vi /etc/httpd/conf/httpd.conf 如下图： 重启Apache： /etc/init.d/httpd restart web&#x2F;php默认文件目录修改vi /etc/httpd/conf/httpd.conf 默认存放目录为：/var/www/html , 将httpd.conf文件中的该目录修改为自己需要的目录即可。 给自己创建的文件目录加权：chmod -R 755 路径 重启Apache。 在自定义的目录下，创建PHP测试文件，以此来测试Apache是否可以正确加载并解释PHP。 cd 自定义目录 touch phpinfo.php vim phpinfo.php &lt;?php phpinfo(); ?&gt; 后记LAMP 常见安装路径 Apache12345如果采用RPM包安装，安装路径应在 /etc/httpd目录下apache配置文件:/etc/httpd/conf/httpd.confApache模块路径：/usr/sbin/apachectlweb目录:/var/www/html如果采用源代码安装，一般默认安装在/usr/local/apache2目录下 PHP123456如果采用RPM包安装，安装路径应在 /etc/目录下php的配置文件:/etc/php.ini如果采用源代码安装，一般默认安装在/usr/local/lib目录下php配置文件: /usr/local/lib/php.ini或/usr/local/php/etc/php.ini MySQL123456如果采用RPM包安装，安装路径应在/usr/share/mysql目录下mysqldump文件位置：/usr/bin/mysqldumpmysqli配置文件:/etc/my.cnf或/usr/share/mysql/my.cnfmysql数据目录在/var/lib/mysql目录下如果采用源代码安装，一般默认安装在/usr/local/mysql目录下","categories":[{"name":"write","slug":"write","permalink":"http://lomo.space/categories/write/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://lomo.space/tags/PHP/"},{"name":"Linux","slug":"Linux","permalink":"http://lomo.space/tags/Linux/"},{"name":"centOS","slug":"centOS","permalink":"http://lomo.space/tags/centOS/"},{"name":"LAMP","slug":"LAMP","permalink":"http://lomo.space/tags/LAMP/"},{"name":"MySQL","slug":"MySQL","permalink":"http://lomo.space/tags/MySQL/"},{"name":"Apache","slug":"Apache","permalink":"http://lomo.space/tags/Apache/"}]},{"title":"nginx日志按照每天进行拆分写入","slug":"nginx日志按照每天进行拆分写入","date":"2016-09-21T03:59:36.000Z","updated":"2022-01-14T11:40:22.884Z","comments":true,"path":"2016/09/21/nginx日志按照每天进行拆分写入/","link":"","permalink":"http://lomo.space/2016/09/21/nginx%E6%97%A5%E5%BF%97%E6%8C%89%E7%85%A7%E6%AF%8F%E5%A4%A9%E8%BF%9B%E8%A1%8C%E6%8B%86%E5%88%86%E5%86%99%E5%85%A5/","excerpt":"","text":"Nginx日志拆分系统环境：CentOS 6.5 123456789nginx -v #nginx version: nginx/1.10.2which nginx#/usr/sbin/nginxlocate nginx.pid#/var/run/nginx.pid 辅助工具-crontab crontab命令常见于Unix和Linux的操作系统之中，用于设置周期性被执行的指令 Install 12yum -y install vixie-cronyum -y install crontabs vixie-cron 软件包是 cron 的主程序；crontabs 软件包是用来安装、卸装、或列举用来驱动 cron 守护进程的表格的程序。 常用命令： 12345service crond start #启动服务service crond stop #关闭服务service crond restart #重启服务service crond reload #重新载入配置service crond status #查看crontab服务状态 添加进程为系统服务： 1chkconfig --level 345 crond on 常用命令： 1234567891011proj-21-032:~ # crontab -hcrontab: invalid option -- &#x27;h&#x27;crontab: usage error: unrecognized optionusage: crontab [-u user] file crontab [-u user] [ -e | -l | -r ] (default operation is replace, per 1003.2) -e (edit user&#x27;s crontab) -l (list user&#x27;s crontab) -r (delete user&#x27;s crontab) -i (prompt before deleting user&#x27;s crontab) -s (selinux context) crontab -e 进入编辑模式； 准备Nginx日期拆分脚本123456789101112#假定拆分脚本文件及其存放位置：/etc/init.d/nginx_log.sh#!/bin/bash# 设置日志文件存放目录logs_path=&quot;/var/log/nginx/&quot;# 设置pid文件pid_path=&quot;/var/run/nginx.pid&quot;# 重命名日志文件mv $&#123;logs_path&#125;access.log $&#123;logs_path&#125;access_$(date -d &quot;yesterday&quot; +&quot;%Y%m%d&quot;).log# 向nginx主进程发信号重新打开日志kill -USR1 `cat $&#123;pid_path&#125;` pid_path 通过locate 命令查找，很多版本、安装方式不一致导致位置可能不太一样！ kill -USR1 cat ${pid_path} 命令是为了mv完成后向nginx发出信号重新打开日志文件并创建一个新的access.log文件用于记录本日的日志… 当时间达到今晚24点后又被mv了，如此循环备份。 将该脚本加入定时任务管理crontab中。 123456789101112crontab -e#进入edit界面配置脚本任务*/5 * * * * /usr/sbin/ntpdate 100.65.0.1 &gt;&gt; /dev/null 2&gt;&amp;1*/2 * * * * /bin/bash /etc/titanagent/agent_update_exception.sh &gt;&gt; /var/log/titanagent/check.o.log 2&gt;&gt; /var/log/titanagent/check.e.log*/2 * * * * /bin/bash /etc/titanagent/agent_monitor.sh &gt;&gt; /var/log/titanagent/edog.o.log 2&gt;&gt; /var/log/titanagent/edog.e.log1 * * * * /bin/bash /etc/titanagent/agent_update.sh &gt;&gt; /var/log/titanagent/check.o.log 2&gt;&gt; /var/log/titanagent/check.e.log# Nginx日志拆分脚本00 00 * * * /bin/bash /etc/init.d/nginx_log.sh 每天 24点&#x2F;零点整进行日志拆分. crontab其它时间日期指令可参考： http://www.cnblogs.com/longjshz/p/5779215.html","categories":[{"name":"write","slug":"write","permalink":"http://lomo.space/categories/write/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"http://lomo.space/tags/nginx/"}]},{"title":"options request","slug":"options-request","date":"2016-08-24T03:47:26.000Z","updated":"2022-01-14T11:40:22.885Z","comments":true,"path":"2016/08/24/options-request/","link":"","permalink":"http://lomo.space/2016/08/24/options-request/","excerpt":"","text":"跨域与http请求之options跨域&#x2F;跨源 起始 同源策略： Same Origin Policy, 同源策略是一种约定，是浏览器最核心、最新基本的安全功能。Web是构建在同源策略基础之上，而浏览器是针对同源策略的一种实现。【From 百科】 同源策略也是一种同来隔离潜在恶意文件的一种关键的安全机制. 【From MDN】 同源&#x2F;同域： 123•协议相同•端口相同•域名相同 其它的可能存在嵌入跨域资源的 HTML 标签： 标签🏷 示例 说明 script script src&#x3D;”…”&gt; 标签嵌入跨域脚本。语法错误信息只能在同源脚本中捕捉到 link link rel&#x3D;”stylesheet” href&#x3D;”…”&gt; 标签嵌入CSS。由于CSS的松散的语法规则，CSS的跨域需要一个设置正确的Content-Type消息头 img img src&#x3D;”….”&gt; 支持的图片格式包括PNG,JPEG,GIF,BMP,SVG,… video&#x2F;audio video src&#x3D;”….” &#x2F;&gt; 多媒体资源 object&#x2F;embed&#x2F;applet frame&#x2F;iframe frame src&#x3D;”…”&gt; 站点可以使用X-Frame-Options消息头来阻止这种形式的跨域交互 因为 同源策略 的原因，通常情况下，浏览器端进行 Ajax 请求时只能进行同源请求(即：当前域下的Ajax请求只能请求当前域对应的后端接口&#x2F;资源) 跨域特点&#x2F;造成的问题通常跨域会有一下特点： 123456•跨域是浏览器同源策略限制，所以在浏览器之外是没有跨域问题的，所以有时候我们用Charles等抓包工具能够看到返回，但实际上是有跨越问题的;• 表单(form)提交是没有跨域限制的;•跨域导致Cookie、LocalStorage 和 IndexDB 无法读取；DOM无法获得；AJAX无法成功请求等; [存储在浏览器中的数据，如localStorage和IndexedDB，以源进行分割。每个源都拥有自己单独的存储空间，一个源中的Javascript脚本不能对属于其它源的数据进行读写操作]跨域并非浏览器限制了发起跨站请求，而是跨站请求可以正常发起，但是返回结果被浏览器拦截(通常在打开开发者模式下的控制台可以看到 xxx \borigin not allowed ...这类红色error 信息)。当然也有些特例，有些浏览器不允许从HTTPS的域跨域访问HTTP， 跨域解决方案12345678•JSONP•CORS•window.name•document.domain•location.hash•window.postMessage•flash 最常用的就前2中 JSONP 和 CORS 了。 JSONP解决跨域作用： 实现跨域读取数据。 JSONP的全英文：JSON with Padding, 单次padding的中译文：衬垫、衬料；废话；赘语。 在此处直译为 衬垫比较接近其本意，那么就可以译为：一个附加性的、陪衬性的JSON。 一般情况下，我们在自己的项目中引用其他的、第三方的或是CDN上的JS等脚本资源时不会存在跨域(源)问题，可以自由加载并执行不同域名下的脚本。 前端 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;JSONP&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;divCustomers&quot;&gt;&lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; function callbackFunction(result) &#123; var html = &#x27;&lt;ul&gt;&#x27;; for(var i = 0; i &lt; result.length; i++) &#123; html += &#x27;&lt;li&gt;&#x27; + result[i] + &#x27;&lt;/li&gt;&#x27;; &#125; html += &#x27;&lt;/ul&gt;&#x27;; document.getElementById(&#x27;divCustomers&#x27;).innerHTML = html; &#125; &lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;http://www.xxx/xxx/xx/jsonp.php?jsoncallback=callbackFunction&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; http://www.xxx/xxx/xx/jsonp.php?jsoncallback=callbackFunction 返回数据 1callbackFunction([&quot;customername1&quot;,&quot;customername2&quot;]) 在前端页面里首先预定义了一个函数名为： callbackFunction, 当加载脚本\\&lt;script type=&quot;text/javascript&quot; src=&quot;http://www.xxx/xxx/xx/jsonp.php?jsoncallback=callbackFunction&quot;&gt;&lt;/script&gt;完成后，返回的就是如上数据，那么此时我们预定义的这个函数 callbackFunction 就会被调用，同时返回的数据 [&quot;customername1&quot;,&quot;customername2&quot;] 被当做这个函数的参数传入并执行该函数。 浏览器执行 脚本 \\&lt;script type=&quot;text/javascript&quot; src=&quot;http://www.xxx/xxx/xx/jsonp.php?jsoncallback=callbackFunction&quot;&gt;&lt;/script&gt; 时回去请求这个资源并向后台传递了一个参数 jsoncallback 其value为 callbackFunction。 假设后端为PHP 123456789&lt;?php header(&#x27;Content-type: application/json&#x27;); //获取回调函数名 -&gt; callbackFunction $jsoncallback = htmlspecialchars($_REQUEST [&#x27;jsoncallback&#x27;]); //返回给客户端的 json数据 $json_data = &#x27;[&quot;customername1&quot;,&quot;customername2&quot;]&#x27;; //输出jsonp格式的数据 echo $jsoncallback . &quot;(&quot; . json_encode($json_data) . &quot;)&quot;;?&gt; 这样浏览器执行 script 脚本完毕后就可以获取到响应的数据，然后去渲染等. 使用JSONP模式的重要前提： 前后端要 事先约定好 包裹的函数名即callback名称; 且JSON的请求方式只能为 GET 请求; 同时若不对传递的包裹函数变量jsoncallback进行转义的话是很容易造成XSS攻击 CORS解决跨域 CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）；允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。 详细参考： http://www.ruanyifeng.com/blog/2016/04/cors.html restful API通常有 PUT GET POST DELETE HEAD OPTIONS 1234567891011REST中又提出了几种其它类型的请求方式，汇总起来有六种：GET、POST、PUT、DELETE、HEAD、OPTIONS。前四种，正好与CRUD操作对应：GET（查）、POST（增）、PUT（改）、DELETE（删）.GET : 从服务器取出资源（一项或多项）POST：在服务器新建一个资源PUT：在服务器更新资源（客户端提供完整资源数据）DELETE：从服务器删除资源HEAD : 从服务器获取报头信息（不是资源）GET、HEAD和OPTIONS均被认为是安全的方法，而PUT、POST、DELETE等请求都是不安全的（会修改数据). 说说其中的options 请求： 服务器端已支持跨域请求，但是浏览器端进行跨域请求时，会首先发出options请求，服务端会返回相应的response并并告诉浏览器是否允许跨域请求(access-control-allow-origin头为*或者和当前域名一致的话，才会进入第二段的真正请求)，允许，那浏览器就接着进行请求，否则就抛出错误(xxx. Xmlhttprequest not allowed 。。。。)","categories":[{"name":"essay","slug":"essay","permalink":"http://lomo.space/categories/essay/"}],"tags":[{"name":"js","slug":"js","permalink":"http://lomo.space/tags/js/"},{"name":"cors","slug":"cors","permalink":"http://lomo.space/tags/cors/"}]},{"title":"MySQL restore autoincrement id","slug":"MySQL-restore-autoincrement-id","date":"2016-08-03T11:22:40.000Z","updated":"2022-01-14T11:40:22.872Z","comments":true,"path":"2016/08/03/MySQL-restore-autoincrement-id/","link":"","permalink":"http://lomo.space/2016/08/03/MySQL-restore-autoincrement-id/","excerpt":"","text":"MySQL重置表重置的2种方式1. 12#删除tableName表的所有数据delete * from tableName; 2. 12#将jsonT表的数据删除并将自增ID置为初始值。truncate table jsonT; DBCC CHECKIDENT (jsonT,NORESEED, uid); DBCC操作不适用MySQL， MS的SQL Server未验证. 比较truncate 和 delete 都会清空已保存的数据。 truncate 比 delete 速度要快，但truncate删除后不记录mysql日志，不可以恢复数据。","categories":[{"name":"study","slug":"study","permalink":"http://lomo.space/categories/study/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://lomo.space/tags/mysql/"}]},{"title":"mysql char&varchar","slug":"mysql-char-varchar","date":"2016-08-03T03:55:38.000Z","updated":"2022-01-14T11:40:22.884Z","comments":true,"path":"2016/08/03/mysql-char-varchar/","link":"","permalink":"http://lomo.space/2016/08/03/mysql-char-varchar/","excerpt":"","text":"MySQL之CHAR与VARCHAR 无论是char(M)还是varchar(M)，其M均值字符数&#x2F;字长. char(M)类型，每个存储的值都会占据M个字节的空间，如果存入的数据长度小于定义的M字节空间，那么实际存储时也会占M个字节空间。实际数据与预定义长度相比较多出来的字节长度MySQL会在其右边用空格字符补充从而使每个存储的数据所用空间都为M个字节。 varchar(M)类型，该类型的数据列里，每个值只占用其数据实际长度，并不会被MySQL使用空格填充剩余的空间。 参考：http://www.cnblogs.com/Lance--blog/p/5193027.html 另： SQL对大小写不敏感。SQL默认数据列类型都是有符号的，若有符号需要添加 unsigned 关键字。 char(M) , M &lt;&#x3D; 255, char最大范围是255， 存储汉字最长为127个汉字。 varchar(M), M &lt;&#x3D; 65535, 由于记录的限制，最大为65532.因为需要1-2个字节来保存信息(null)。故若允许存储null则varchar最大长度位65532；不允许null则为65533。","categories":[{"name":"study","slug":"study","permalink":"http://lomo.space/categories/study/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://lomo.space/tags/mysql/"}]},{"title":"js-map","slug":"js-map","date":"2016-07-23T08:03:17.000Z","updated":"2022-01-14T11:40:22.882Z","comments":true,"path":"2016/07/23/js-map/","link":"","permalink":"http://lomo.space/2016/07/23/js-map/","excerpt":"","text":"mapmap将原来的数据映射成新数组； 123456789var arr = [1,2,3,4];var arr2 = arr.map(function(item)&#123;return item;&#125;);console.log(arr2);//[1, 2, 3, 4]console.log(typeof arr2); //&quot;object&quot; 声明一个userInfo数组对象： 123456var userInfo = [ &#123;&quot;name&quot;: &quot;lmo&quot;, &quot;email&quot;: &quot;lmo@lmo.space&quot;&#125;, &#123;&quot;name&quot;: &quot;lomo1&quot;, &quot;email&quot;: &quot;lomo1@lomo1.spae&quot;&#125;, &#123;&quot;name&quot;: &quot;lomo&quot;, &quot;email&quot;: &quot;lomo@lomo.space&quot;&#125;, &#123;&quot;name&quot;: &quot;lomo2&quot;, &quot;email&quot;: &quot;lomo2@lomo2.space&quot;&#125;]; 使用map取出特定属性值的集合。 1234567891011var users = userInfo.map(function(item)&#123;return item;&#125;);users.length; // 4var usersName = userInfo.map(function(item)&#123;return item.name;&#125;);console.log(usersName); //[&quot;lmo&quot;, &quot;lomo1&quot;, &quot;lomo&quot;, &quot;lomo2&quot;]var usersEmail = userInfo.map(function(item)&#123;return item.email;&#125;);usersEmail; //object-&gt;[&quot;lmo@lmo.space&quot;, &quot;lomo1@lomo1.spae&quot;, &quot;lomo@lomo.space&quot;, &quot;lomo2@lomo2.space&quot;]console.log(usersEmail.join(&quot;,&quot;));//输出： lmo@lmo.space,lomo1@lomo1.spae,lomo@lomo.space,lomo2@lomo2.space 兼容性–改进: IE6 ~ IE8 Array.prototype.map map方法的根-&gt;Array； 123456789101112131415if(typeof Array.prototype.mar != &quot;function&quot;)&#123; Array.prototype.map = function(fn, context)&#123; var arr = []; if(typeof fn === &quot;function&quot;) &#123; //不能使用let k = 0; for(var k = 0; k &lt; this.length; k ++) &#123; arr.push(fn.call(context, this[k], this)); &#125; &#125; return arr; &#125;;&#125;","categories":[{"name":"study","slug":"study","permalink":"http://lomo.space/categories/study/"}],"tags":[{"name":"js","slug":"js","permalink":"http://lomo.space/tags/js/"}]},{"title":"async await ES7","slug":"async-await-ES7","date":"2016-07-07T02:57:03.000Z","updated":"2022-01-14T11:40:22.874Z","comments":true,"path":"2016/07/07/async-await-ES7/","link":"","permalink":"http://lomo.space/2016/07/07/async-await-ES7/","excerpt":"","text":"ES7之async&#x2F;await 盗个图🙂 概念123ES5 -&gt; ECMAScript ECMAScript第五个版本ES6 -&gt; ECMAScript 2015ES7 -&gt; ECMAScript 2016 so, what ECMAScript? https://en.wikipedia.org/wiki/ECMAScript简言之，定制JavaScript标准的。 It was created to standardize JavaScript, so as to foster multiple independent implementations. 参考： https://www.w3ctech.com/topic/1614 https://huangxuan.me/2015/09/22/js-version/?utm_source=caibaojian.com 浏览器支持各大浏览器支持： async&#x2F;await示例 async 是一个异步函数，await只能用在async函数内. 12await表示等待返回了promise对象后再继续执行；await后面跟的是一个promise对象(其它返回值也可以，但是会立刻执行，无意义) 123456789101112131415//暂停var sleep = function(time) &#123; return new Promise(function(resolve, reject) &#123; setTimeout(function() &#123; resolve(); &#125;, time); &#125;);&#125;;//测试 start函数，顺序执行var start = async function() &#123; console.info(&quot;Start...&quot;); await sleep(3000); //暂停3s console.log(&quot;End...&quot;);&#125;; 在浏览器控制台执行 start();，顺序输出 Start... 以及调用sleep(3000)后返回的promise对象，最后输出的是 End... 为了看清await函数功能，测试如下函数 12345var start2 = function() &#123; console.info(&quot;Start...&quot;); sleep(3000); //无await console.log(&quot;End...&quot;);&#125;; 直接输出：Start... 和 End... async、await获得返回值12345678910111213141516171819202122232425262728293031323334var sleep = function(time) &#123; return new Promise(function(resolve, reject) &#123; setTimeout(function() &#123; if (time &lt; 2000) &#123; reject(&quot;10000&quot;); &#125; else &#123; resolve(&quot;ok&quot;); &#125; &#125;, time); &#125;);&#125;;var test = async function() &#123; let res = await sleep(3000); console.info(res); console.info(&quot;hehe&quot;);&#125;;var test2 = async function() &#123; let res = await sleep(1000); //reject返回了一个错误 console.log(res); //控制太执行显示的是 ”Uncaught (in promise) 10000“ console.info(&quot;hehe&quot;);&#125;;// try catch 捕捉错误var test3 = async function() &#123; try &#123; let res = await sleep(1000); //reject 错误 console.log(res); // 只显示reject返回值，不会提示说是 &quot;Uncaught&quot; console.info(&quot;hehe&quot;); //不会执行 &#125; catch (err) &#123; console.error(err); &#125;&#125;; 引申：当需要顺序执行HTTP请求，需要根据第一个请求的返回然后执行后续的操作时，可以将请求封装一个Promise对象传给下一个处理函数(如这里的test) 1234567891011121314151617181920212223242526272829303132var httpRequest = function(URL) &#123; return new Promise(function(resolve, reject)&#123; var x = $.ajax(&#123; type: &quot;GET&quot;, url: URL, &#125;); /* x.done(function(res)&#123; if(res.error.returnCode == &quot;0&quot;) resole(res.data); reject(res.error.returnCode); &#125;); */ if(x) resolve(x); reject(&quot;10000&quot;); &#125;);&#125;var req = async function() &#123; try &#123; console.log(&quot;开始请求&quot;); //var res = await httpRequest(&quot;http://www.baidu.com&quot;); //因为在浏览器端存在跨域 let res = await httpRequest(&quot;http://localhost/sites/JDBToolsPlatform/api/processQualityReport/reportDataDetail.php?beginDate=2017-06-01&amp;endDate=2017-06-30&quot;); console.log(res); //获得返回的数据 //console.log(typeof res); //返回的json类型：string //console.log(JSON.parse(res).error.returnCode); //获取返回状态码 console.log(&quot;请求结束。。。&quot;); &#125;catch (err) &#123; console.log(err); &#125;&#125;; 异步函数 客户端fetch API, 一种替代 XMLHttpRequest 检索文件的方案. 12345678910async function fetchJson(url) &#123; try &#123; let request = await fetch(url); //fetch函数返回的就是一个Promise对象 let text = await request.text(); return JSON.parse(text); &#125; catch (error) &#123; console.log(`ERROR: $&#123;error.stack&#125;`); &#125;&#125; 12345678var t = fetchJson(&quot;http://localhost/sites/JDBToolsPlatform/api/processQualityReport/reportDataDetail.php?beginDate=2017-06-01&amp;endDate=2017-06-30&quot;);// console.inf(typeof t); // &quot;object&quot; t是一个Promise对象t.then(obj =&gt; console.log(obj)); //输出的json串t.then(obj =&gt; console.log(obj.error)); //error信息t.then(obj =&gt; console.log(obj.data)); //data信息t.then(obj =&gt; function()&#123;alert(obj.error);&#125;()); Reference: https://tutorialzine.com/2017/07/javascript-async-await-explained","categories":[{"name":"study","slug":"study","permalink":"http://lomo.space/categories/study/"}],"tags":[{"name":"js","slug":"js","permalink":"http://lomo.space/tags/js/"},{"name":"ES7","slug":"ES7","permalink":"http://lomo.space/tags/ES7/"}]},{"title":"get real IP by nginx proxy","slug":"get-real-IP-by-nginx-proxy","date":"2016-06-22T02:16:06.000Z","updated":"2022-01-14T11:40:22.877Z","comments":true,"path":"2016/06/22/get-real-IP-by-nginx-proxy/","link":"","permalink":"http://lomo.space/2016/06/22/get-real-IP-by-nginx-proxy/","excerpt":"","text":"Nginx反向代理后如何获取客户端真实IP1234567# 部分location ~ \\.php$ &#123; proxy_pass http://xxxx.x.xxx.xx:8080; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; &#125; 如果只有一层Nginx代理，则添加如上的 proxy_set_header 配置后，使用$_SERVER[&#39;HTTP_X_REAL_IP&#39;] 即可获取客户端真实IP地址。 通过var_dump($_SERVER);查看报头信息，可以看到多了2项目： HTTP_X_REAL_IP 和 HTTP_X_FORWARDED_FOR。 另： PHP内置了web服务器，便于本地开发调试。 要求：PHP version &gt;&#x3D; 5.4本地服务器启动： 1php -S localhost:8000 本地启动后： 123456PHP 7.0.15 Development Server started at Thu Jun 22 10:39:52 2017Listening on http://localhost:8000Document root is /Users/lomoPress Ctrl-C to quit.[Thu Jun 22 10:39:57 2017] ::1:59794 [404]: / - No such file or directory[Thu Jun 22 10:39:58 2017] ::1:59795 [404]: /favicon.ico - No such file or directory","categories":[{"name":"study","slug":"study","permalink":"http://lomo.space/categories/study/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"http://lomo.space/tags/nginx/"}]},{"title":"js-var_let_const","slug":"js-var-let-const","date":"2016-06-21T03:54:39.000Z","updated":"2022-01-14T11:40:22.882Z","comments":true,"path":"2016/06/21/js-var-let-const/","link":"","permalink":"http://lomo.space/2016/06/21/js-var-let-const/","excerpt":"","text":"JavaScript变量声明之var&#x2F;let&#x2F;constconstconst a; 错误❌的声明方式！！！ const声明的变量必须要初始化！ e.g. const a = 1; or const a = &#39;&#39;; varvar定义的变量可以不用初始化（值为undefined）, 且不会报错；var定义的变量其值可以被修改！ letlet 定义的变量拥有作用域，在函数内部定义let级变量，则其不会改变函数外部变量属性和值； 123456789let b = 2;function test()&#123; let b = 222; console.log(&quot;inner value: &quot; + b);&#125;console.log(b); //2test(); //inner value: 222","categories":[{"name":"study","slug":"study","permalink":"http://lomo.space/categories/study/"}],"tags":[{"name":"js","slug":"js","permalink":"http://lomo.space/tags/js/"}]},{"title":"Closure-闭包","slug":"Closure-闭包","date":"2016-06-21T03:50:56.000Z","updated":"2022-01-14T11:40:22.869Z","comments":true,"path":"2016/06/21/Closure-闭包/","link":"","permalink":"http://lomo.space/2016/06/21/Closure-%E9%97%AD%E5%8C%85/","excerpt":"","text":"闭包 总结下闭包相关知识，记录下笔记. JS里的闭包123456789101112131415//闭包函数function Counter() &#123; let k = 0; return function() &#123; return ++k; &#125;;&#125;var counter = new Counter();console.log(couner()); //输出：1console.log(couner()); //再次输出：2console.log(counter();); // ..输出：3// .... 闭包： 保留局部变量不被JavaScript的GC回收♻️ 的代码块(通常是函数),称其为闭包。 var counter = new Counter(); 创建counter对象，第一次console.log(counter());时输出为1，counter()调用了Counter内的匿名函数，该匿名函数对Counter内部的局部变量k进行了引用，局部变量k在counter()调用完毕后(函数执行完毕后) 并未被GC回收，从而产生了闭包。 该闭包的作用保留了局部变量k的值在内存中。 闭包的作用：创造一些函数私有的”持久化变量”。将函数内的局部变量值保存在内存中(函数执行完毕后该变量不被GC回收)。 闭包的创造条件： ①存在内、外两层函数。 ②内层函数对外层函数内的局部变量进行了引用。 闭包用途将函数内局部变量持久化，例如：将ajax返回的值进行持久化，便于在ajax封装的函数外调用返回的值等. 做缓存示例参考：http://taobaofed.org/blog/2017/03/16/javascript-functional-programing/ 闭包弊端由于变量持久化，这些持久化的变量一直存在于对象(除非关闭当前浏览器标签或结束对应进程)，否则会造成内存浪费。所以需要额外的手动清理机制。","categories":[{"name":"study","slug":"study","permalink":"http://lomo.space/categories/study/"}],"tags":[{"name":"js","slug":"js","permalink":"http://lomo.space/tags/js/"}]},{"title":"general git command","slug":"general-git-command","date":"2016-06-17T12:56:38.000Z","updated":"2022-01-14T11:40:22.876Z","comments":true,"path":"2016/06/17/general-git-command/","link":"","permalink":"http://lomo.space/2016/06/17/general-git-command/","excerpt":"","text":"Git常用命令[笔记]准备 – 秘钥 生成秘钥(公钥、私钥) ssh-keygen -t rsa -b 4096 -C &quot;注册的email&quot; copy共钥 pbcopy &lt; ~/.ssh/id_rsa.pub 常用命令①git init (项目目录下初始化) ②git add .(add当前目录所有文件并追踪其变更与否) ③git commit -m “变更描述” ④git push -u origin master (一般地: 远程地址默认 origin 与 分支master，实际开发默认分支为develop ) ⑤git status (查看本地有哪些文件变更: 修改、删除、增加等变化) ⑥git diff xxxx.xx（具体的文件，对比文件内容变化） ⑦git remote add origin git@xxx&#x2F;xxx&#x2F;xxx.git (添加远程仓库地址到本地记录，并简称为origin) ⑧git stash &#x2F;&#x2F;备份当前的工作区的内容 ⑨git stash pop &#x2F;&#x2F;从Git栈中读取最近一次保存的内容，恢复工作区的相关内容 Git基本配置(全局)123456789101112git config --listgit config --global user.name &quot;xxx&quot;git config --global user.email &quot;lomo@lomo.space&quot;# user name 和 email 信息会显示在提交历史的提交者信息上git config --global color.ui truegit config --global color.status autogit config --global color.branch auto 另, 可以在本机根目录下全局配置: 12# 用户级别的配置, 该配置对当前登录用户全部有效vim ~/.gitconfig Git单独配置与全局配置 默认地, 所有项目提交时记录的账户信息均为本机的全局Git配置信息. 上面👆的配置是针对开发环境本地全局配置。 当有多个项目分别托管在 GitHub, GitLab 或自己搭建的内网 Git 服务器上时,\b 不同的服务器, 配置不用的秘钥, 每个项目可能需要配置不同的 Git 账户信息, 此时就需要单独配置某个项目的Git信息。 123456789101112# cd 项目目录cd projectName# edit config infovim .git/config# 示例[user] name = Lomo email = lomo@lomo.space# 示例# 添加账户信息即可, 默认该git项目的 .git/config文件中 可能没有user相关信息, 那么它就使用的是全局配置的账户信息 其它(分支)1234567891011121314git branch -r #远程分支git branch -a #所有分支git checkout newbranch origin/master #//在origin/master的基础上，创建一个新分支$ git merge origin/master# 或者$ git rebase origin/master#使用git merge命令或者git rebase命令，在本地分支上合并远程分支git remote rename oldname newname#修改远程仓库地址别名 撤销相关git add 后撤销： git reset HEAD filename 撤销所有的add: git reset HEAD . git commit 后撤销本次commit： git log git reset --soft commit_id(本次提交前的那次id) git push 后 撤销（回退）： git reset --hard &lt;版本号&gt; // 注意使用 --hard 参数会抛弃当前工作区的修改, // --soft 参数的话会回退到之前的版本，但是保留当前工作区的修改，可以重新提交 git reset --soft f7b385a //(本次提交的上一次提交的版本号) git push lomo develop --force //覆盖掉远端的版本信息，使远端的仓库也回退到相应的版本 分支的创建与合并【create】 创建并切换至新创建的分支： git checkout -b newbranchName 只创建： git branch 分支名 delete 分支 git branch -d 分支名 切换至某分支： git checkout 分支名 【rebase/merge】 将dev分支合并至master: git checkout master git merge dev 或 git rebase dev 区别： merge操作会生成一个新的节点，之前的提交分开显示； 而rebase操作不会生成新的节点，是将两个分支融合成一个线性的提交，可以线性的看到每一次提交； 合并时冲突： merge 操作遇到冲突的时候，当前merge不能继续进行下去。手动修改冲突内容后，add 修改，commit 就可以； 而rebase 操作的话，会中断rebase,同时会提示去解决冲突。 解决冲突后,将修改add后执行git rebase —continue继续操作，或者git rebase —skip忽略冲突。 实际使用总结 当多人协同开发一个项目时，一般不会直接在master分支直接开发，而是把master分支保留作为最终稳定、发行版本. 假设现在自己在本地develop分支开发了新功能、或者修改了老功能代码，现在需要提交，那么自己在提交之前，一定要按照如下顺序： ①git fetch origin （从远端中央仓库获取最新版本） ②如果本地有修改未提交，则会提示git stash, 之后再git stash pop出来本地修改即可. ③fetch完之后，在本地完成合并，git rebase origin/分支名, rebase的目的就是每次提交前都必须保证自己的本地仓库版本号必须要大于等于中央仓库版本号. ④git push xx, 合并后, stash里的该pop就pop，该add的add， 然后push到自己fork的远端仓库，然后向中央仓库发起Pull Request即可。 这样既保证了自己本地仓库和中央仓库版本一致性，也保证了自己远端仓库版本一致性(从自己fork那一刻起到自己首次进行代码提交，中央仓库可能有很多更新和push合并,而自己fork到自己远端的仓库并不会自动与中央仓库进行同步，所以自己远端仓库的版本号并不一定和中央仓库版本号一致) 本地手动合并他人代码 假设拥有合并中央仓库代码权限! ①git checkout -B/-b newTest origin/develop (newTest:新的远端仓库别名，origin&#x2F;develop:分支) ②如果本地有修改，需要git stash操作 ③git branch 可以查看当前所在分支(默认第一步创建完后自动切换至最新的分支上去) ④git pull --rebase git@github.com:xxxx.git develop (拉取其他人的最新提交的分支develop代码 到本地刚才新建的分支上 同时进行合并操作，若其他人提交的这个版本比中央仓库的低，则会有冲突，需要手动解决冲突) ⑤本地手动完成合并后，再push上去，git push origin newTest:develop 将本地的newTest分支提交到远程仓库的develop分支,将本地的xx分支提交到远程的xxx分支语法，如上，用 : 链接2个分支;若 冒号：左边分支为空，则会删除远程分支，本地保留；如：git push origin :test ; &#x2F;&#x2F;远程test分支会被删除 push完之后，本地gitk即可借助GUI的小界面工具查看提交. ⑤确认后，切换本地自己开发分支 git checkout develop; 然后git rebase origin/develop 将本地合并到自己的开发分支中 ⑥最后，git push lomo develop (假设自己不是在中央仓库上直接开发的，而是重新fork 的，但是自己有合并代码的权限针对之前合并代码操作而言)，这一步是将本地最新版本(在合并完别人提交的代码到中央仓库后)push到自己fork的那个远端仓库，保持自己远端仓库版本和中央仓库版本号的一致性.","categories":[{"name":"study","slug":"study","permalink":"http://lomo.space/categories/study/"}],"tags":[{"name":"git","slug":"git","permalink":"http://lomo.space/tags/git/"}]},{"title":"php operate Object","slug":"php-operate-Object","date":"2016-06-09T03:00:07.000Z","updated":"2022-01-14T11:40:22.885Z","comments":true,"path":"2016/06/09/php-operate-Object/","link":"","permalink":"http://lomo.space/2016/06/09/php-operate-Object/","excerpt":"","text":"PHP操作Object对象 如： 通过curl请求获取到JOSN数据后，其为JSON 字串，通过gettype()获得其类型是string类型!能否像js里操作对象一样，直接使用xx.key就可以获得其属性值呢？ 通过curl获取到的json数据: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&#123; &quot;error&quot;: &#123; &quot;returnCode&quot;: &quot;0&quot;, &quot;returnMessage&quot;: &quot;success&quot; &#125;, &quot;data&quot;: &#123; &quot;allRisk&quot;: &quot;3&quot;, &quot;list&quot;: [ &#123; &quot;type&quot;: &quot;1&quot;, &quot;title&quot;: &quot;Bug未收敛&quot;, &quot;count&quot;: &quot;0&quot; &#125;, &#123; &quot;type&quot;: &quot;2&quot;, &quot;title&quot;: &quot;提测Delay&quot;, &quot;count&quot;: &quot;0&quot; &#125;, &#123; &quot;type&quot;: &quot;3&quot;, &quot;title&quot;: &quot;沟通问题&quot;, &quot;count&quot;: &quot;0&quot; &#125;, &#123; &quot;type&quot;: &quot;4&quot;, &quot;title&quot;: &quot; 流程问题&quot;, &quot;count&quot;: &quot;0&quot; &#125;, &#123; &quot;type&quot;: &quot;5&quot;, &quot;title&quot;: &quot;环境问题&quot;, &quot;count&quot;: &quot;0&quot; &#125;, &#123; &quot;type&quot;: &quot;6&quot;, &quot;title&quot;: &quot;需求变更&quot;, &quot;count&quot;: &quot;0&quot; &#125;, &#123; &quot;type&quot;: &quot;7&quot;, &quot;title&quot;: &quot;项目计划问题&quot;, &quot;count&quot;: &quot;0&quot; &#125;, &#123; &quot;type&quot;: &quot;8&quot;, &quot;title&quot;: &quot;其他&quot;, &quot;count&quot;: &quot;3&quot; &#125; ] &#125;&#125; 此数据为string类型； 1$obj = json_decode($response); 转换为Object对象，默认 json_decode未加参数true则转换后的为Object类型，反之为Array； 获取对象中的属性值; 1print_r($obj-&gt;&#123;&quot;error&quot;&#125;) ; //打印对象error属性 输出： 1stdClass Object ( [returnCode] =&gt; 0 [returnMessage] =&gt; success ) 或 1var_dump($obj-&gt;&#123;&quot;error&quot;&#125;); 输出： 1234/Users/xxx/xx/xx../xx/api/processQualityReport/reportDataDetail.php:54:object(stdClass)[2] public &#x27;returnCode&#x27; =&gt; string &#x27;0&#x27; (length=1) public &#x27;returnMessage&#x27; =&gt; string &#x27;success&#x27; (length=7) 输出对象属性只能用 print_r() 函数或 var_dump()函数. 以json字串形式输出Object对象属性1echo json_encode($obj-&gt;data); //将Object对象中的Data属性以JSON字串形式输出 输出： 123456789101112131415161718192021222324252627282930313233343536373839404142434445&#123; &quot;allRisk&quot;: &quot;3&quot;, &quot;list&quot;: [ &#123; &quot;type&quot;: &quot;1&quot;, &quot;title&quot;: &quot;Bug未收敛&quot;, &quot;count&quot;: &quot;0&quot; &#125;, &#123; &quot;type&quot;: &quot;2&quot;, &quot;title&quot;: &quot;提测Delay&quot;, &quot;count&quot;: &quot;0&quot; &#125;, &#123; &quot;type&quot;: &quot;3&quot;, &quot;title&quot;: &quot;沟通问题&quot;, &quot;count&quot;: &quot;0&quot; &#125;, &#123; &quot;type&quot;: &quot;4&quot;, &quot;title&quot;: &quot; 流程问题&quot;, &quot;count&quot;: &quot;0&quot; &#125;, &#123; &quot;type&quot;: &quot;5&quot;, &quot;title&quot;: &quot;环境问题&quot;, &quot;count&quot;: &quot;0&quot; &#125;, &#123; &quot;type&quot;: &quot;6&quot;, &quot;title&quot;: &quot;需求变更&quot;, &quot;count&quot;: &quot;0&quot; &#125;, &#123; &quot;type&quot;: &quot;7&quot;, &quot;title&quot;: &quot;项目计划问题&quot;, &quot;count&quot;: &quot;0&quot; &#125;, &#123; &quot;type&quot;: &quot;8&quot;, &quot;title&quot;: &quot;其他&quot;, &quot;count&quot;: &quot;3&quot; &#125; ]&#125; 获取data中的risk属性: 1echo json_encode($obj-&gt;data-&gt;allRisk); 输出：”3” 1echo json_encode($obj-&gt;data-&gt;list[1]); //获取第二组数据，因为list已经是个数组 输出： 12345&#123; &quot;type&quot;: &quot;2&quot;, &quot;title&quot;: &quot;提测Delay&quot;, &quot;count&quot;: &quot;0&quot;&#125;","categories":[{"name":"program","slug":"program","permalink":"http://lomo.space/categories/program/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://lomo.space/tags/PHP/"}]},{"title":"js operate date","slug":"js-operate-date","date":"2016-05-26T02:53:55.000Z","updated":"2022-01-14T11:40:22.882Z","comments":true,"path":"2016/05/26/js-operate-date/","link":"","permalink":"http://lomo.space/2016/05/26/js-operate-date/","excerpt":"","text":"JS 关于时间的一些操作 为了正确，一般时间要求严格准确的操作、管理，都是在server端完成，某些情况下，也需要前端对时间的一些基本操作。 1234567891011121314var x = new Date(); // x -&gt; Fri May 26 2016 10:56:33 GMT+0800 (CST), 注意这是CST时区//然后就可以得到需要的格式，必须yyyy-MM-dd 年月日，yyyy-MM-dd hh:mm:ss 年月日时分秒格式...x.getFullYear(); //年x.getMonth() + 1; //中国时区的 月份x.getDate(); // 这个月的几号x.getHours(); //小时x.getMinutes(); //分x.getSeconds(); //秒Math.floor((x.getMonth()+3)/3); //获得当前属于第几个季度x.getMilliseconds(); //微秒 参考： http://www.cnblogs.com/zhangpengshou/archive/2012/07/19/2599053.html","categories":[{"name":"study","slug":"study","permalink":"http://lomo.space/categories/study/"}],"tags":[{"name":"js","slug":"js","permalink":"http://lomo.space/tags/js/"},{"name":"date","slug":"date","permalink":"http://lomo.space/tags/date/"}]},{"title":"install Brew tools on Mac","slug":"install-Brew-tools-on-Mac","date":"2016-05-23T11:09:24.000Z","updated":"2022-01-14T11:40:22.880Z","comments":true,"path":"2016/05/23/install-Brew-tools-on-Mac/","link":"","permalink":"http://lomo.space/2016/05/23/install-Brew-tools-on-Mac/","excerpt":"","text":"Mac安装Brew1$ ruby -e &quot;$(curl -fsSL https://raw.github.com/Homebrew/homebrew/go/install)&quot; 安装 cask — 基于homebrew的一个增强工具 brew tap phinze/cask brew install brew-cask homebrew-cask是一套建立在homebrew基础上的Mac软件安装命令行工具. 同时安装4个软件sublime-text skitch dropbox google-chorme brew cask install sublime-text skitch dropbox google-chrome brew常用命令12345678brew cask search #列出所有可以被安装的软件brew cask search drop #查找所有和 *drop* 相关的应用brew cask info xxx #查看 xx 如：*迅雷* 应用的信息，这货安装的可是最新版本的迅雷哦！brew cask uninstall qq #卸载 *QQ*brew update &amp;&amp; brew upgrade #更新所有应用程序brew cask ls #列出通过brew cask 安装的软件brew cask cleanup #清除下载缓存及链接信息 homebrew-cask是将应用程序放置在/opt/homebrew-cask/Caskroom/ Mac命令行增强工具安装oh-my-zsh 1$ sh -c &quot;$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot; cat /etc/shells 即可看到刚才安装的zsh; 切换到最新安装的bash: chsh -s /bin/zsh zsh问题：切换shell 从bash切换至zsh后， ~/.bash_profile里的环境变量失效解决： 在~&#x2F;.zshrc添加 source ~/.bash_profile zsh主题https://github.com/robbyrussell/oh-my-zsh/wiki/themes 在此选择好主题后， vim ~/.zshrc 找到ZSH_THEME= 修改其为需要的主题名即可.","categories":[{"name":"read","slug":"read","permalink":"http://lomo.space/categories/read/"}],"tags":[{"name":"Mac","slug":"Mac","permalink":"http://lomo.space/tags/Mac/"},{"name":"Brew","slug":"Brew","permalink":"http://lomo.space/tags/Brew/"},{"name":"zsh","slug":"zsh","permalink":"http://lomo.space/tags/zsh/"}]},{"title":"Java Constructor","slug":"Java-Constructor","date":"2016-04-14T07:41:07.000Z","updated":"2022-01-14T11:40:22.870Z","comments":true,"path":"2016/04/14/Java-Constructor/","link":"","permalink":"http://lomo.space/2016/04/14/Java-Constructor/","excerpt":"","text":"Java构造器及其子类构造器定义与类名相同。提供对象初始化赋值等操作，使得new一个对象时就可以获取该类的一些固有属性（new时就自动加载了构造器保存于内存中） 构造函数不能直接被调用,必须用在new表达式里. 方法名必须与类名相同；不要声明返回类型；不能被static、final、synchronized、abstract、native等修饰.可以处于public、protected、private和默认default四种访问级别之一。 如果一个类中，未显式地声明构造器，则初始化该类时会自动调用系统默认的无参构造器; 如果一个类中，显式地声明了构造器，则初始化该类时会调用声明的构造器。 一个类中，可以根据参数类型、列表等声明多个构造器。 构造器与继承结论1： 当父类手动创建了构造器后，继承的子类就会首先调用父类的构造器.[如果父类中只显式地声明了带参构造器，那么子类的构造函数必须首先调用父类带参数的构造器，使用super(xx); 方法并传入一致的参数] 结论2： 一个类中只显式声明了有参构造器后，系统默认的无参构造器将会自动消失！！！ 当父类中显式地声明了无参构造器和多个有参构造器，那么子类中，可以调用显示地使用super()方法调用父类无参构造器，或子类的构造器中什么也不做，同样在执行时，也会默认调用父类的无参数构造器. 子类不继承父类的构造函数，只是显式(子类构造函数内第一行 使用super(xx), 传入和父类中构造函数一致的参数)或隐式(默认的无参，系统会默认调用父类无参构造函数super(); )地调用。 示例1 123456789101112131415161718192021222324252627282930313233public class Dog extends Animal&#123; public Dog()&#123; //super(); &#125; public static void main(String[] args) throws Exception&#123; //或使用new的方式创建对象 Dog dog = (Dog)Class.forName(&quot;javaClassExercise.constructorTest.Dog&quot;).newInstance(); // 1 //无论在Dog 这个子类中是否使用super()方法去调用父类的无参构造器，都是调用父类的无参数构造器并输出1. //当然，子类不显式声明构造函数时，此时 也可以new对象。因为：父类中有无参构造器，子类即使未声明构造器，在执行子类时，也会使用系统默认的构造器 &#125;&#125;class Animal &#123; private String name; private int age; public Animal() &#123; System.out.println(&quot;1&quot;); &#125; public Animal(String name) &#123; this.name = name; &#125; public Animal(int age) &#123; this.age = age; &#125; public String getName() &#123; return name; &#125;&#125; 结论3： 如果父类中只显式声明了带参构造器，那么父类默认的无参构造器就会不存在了，子类的构造器就必须在其首行使用super(xx);传入一致的参数去显式调用父类的构造器. 示例2 123456789101112131415161718192021222324252627282930313233343536373839public class Dog extends Animal&#123; public Dog()&#123; super(123); //或 //super(&quot;Lomo&quot;); &#125; public static void main(String[] args) throws Exception&#123; Dog dog = (Dog)Class.forName(&quot;javaClassExercise.constructorTest.Dog&quot;).newInstance(); System.out.println(dog.getAge()); //123 //注释父类Animal() 这个无参数的构造器后，Dog这个子类执行时，由于继承自父类，要先初始化父类的有参构造器，所以子类Dog中若未显式声明带参构造器就不会通过编译。 //当父类Animal类没有无参构造器时，继承该类的子类Dog类中，必须显式声明构造器，可以是无参数的，但是必须使用super(xx)传入与父类一直的参数，然后初始化父类的有参构造器后才可,否则编译都无法通过！ &#125;&#125;class Animal &#123; private String name; private int age;// public Animal() &#123;// System.out.println(&quot;1&quot;);// &#125; public Animal(String name) &#123; this.name = name; &#125; public Animal(int age) &#123; this.age = age; &#125; public String getName() &#123; return name; &#125; public int getAge() &#123; return age; &#125;&#125; 总结： 通常，在父类中声明有参构造器，子类继承该父类后，就必须在子类构造器中使用super(xx)，来执行初始化父类的构造器，然后通过父类有参构造器获取一些属性。","categories":[{"name":"study","slug":"study","permalink":"http://lomo.space/categories/study/"}],"tags":[{"name":"java","slug":"java","permalink":"http://lomo.space/tags/java/"}]},{"title":"jquery get data from table","slug":"jquery-get-one-col-from-table","date":"2016-04-07T16:44:36.000Z","updated":"2022-01-14T11:40:22.881Z","comments":true,"path":"2016/04/08/jquery-get-one-col-from-table/","link":"","permalink":"http://lomo.space/2016/04/08/jquery-get-one-col-from-table/","excerpt":"","text":"jQuery获取table数据 当鼠标点击某一行时，需要获取该行的第一列数据或被点击的这一整行或部分数据，然后传递给API。 jQuery的两个函数：closet() 和 find() closet()函数，从根开始遍历DOM树，第一个发现的即元素即所查找的元素,closet会包含自己 find()函数，查看对应的元素。不包含自己！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051 &lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;Bootstrap 实例 - 基本的表格&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;http://cdn.static.runoob.com/libs/bootstrap/3.3.7/css/bootstrap.min.css&quot;&gt; &lt;script src=&quot;http://cdn.static.runoob.com/libs/jquery/2.1.1/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;http://cdn.static.runoob.com/libs/bootstrap/3.3.7/js/bootstrap.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;table class=&quot;table table-responsive table-hover&quot; id=&quot;table&quot;&gt; &lt;caption&gt;基本的表格布局&lt;/caption&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;名称&lt;/th&gt; &lt;th&gt;城市&lt;/th&gt; &lt;th&gt;Get&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody class=&quot;tbody&quot;&gt; &lt;tr&gt; &lt;td class=&quot;name&quot;&gt;Tanmay&lt;/td&gt; &lt;td &gt;Bangalore&lt;/td&gt; &lt;td&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-default&quot;&gt;Get1&lt;/button&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=&quot;name&quot;&gt;Sachin&lt;/td&gt; &lt;td&gt;Mumbai&lt;/td&gt; &lt;!--&lt;td onclick=&quot;alert(this.rowSpan);&quot;&gt;--&gt; &lt;td&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-default&quot;&gt;Get2&lt;/button&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt;&lt;/body&gt; &lt;script&gt; $(&quot;.btn.btn-default&quot;).click(function() &#123; var $row = $(this).closest(&quot;tr&quot;); // Find the current row var $text = $row.find(&quot;.name&quot;).text(); // Find the text by the className // test it out alert($text);&#125;);&lt;/script&gt; &lt;/html&gt; 如下图: 关于HTMLTableCellElement 参考 https://developer.mozilla.org/en-US/docs/Web/API/HTMLTableCellElement 从这些API只能获取一些基本信息，通常都用不到(比如 rowSpan, colSpan, cellIndex) 其它参考： Stack Overflow","categories":[{"name":"program","slug":"program","permalink":"http://lomo.space/categories/program/"}],"tags":[{"name":"js","slug":"js","permalink":"http://lomo.space/tags/js/"},{"name":"jquery","slug":"jquery","permalink":"http://lomo.space/tags/jquery/"}]},{"title":"Lomo","slug":"Lomo","date":"2016-03-31T11:41:05.000Z","updated":"2022-01-14T11:40:22.871Z","comments":true,"path":"2016/03/31/Lomo/","link":"","permalink":"http://lomo.space/2016/03/31/Lomo/","excerpt":"","text":"About LOMO LOMO＝Let Our Life be Magic and Open！ LOMO前世上个世纪50年代在苏联圣彼得堡一个专门生产军事光学镜片的工厂，叫列宁格勒光学仪器厂（Leningradskoje Opitiko Mechanitscheskoje Objedinenie）是俄罗斯最大的光学仪器生产厂，LOMO LC-A是该厂在前苏联时期研制生产的35毫米自动曝光旁轴相机。 LOMO今生 “Lomo不止是一种创作性的摄影，而是一种存在的方式. 宗旨: 要借千千万万的Snap Shots去纪录地球上的一事一物。 Lomo相机的特色是镜头宽(32mm)、速度快、色彩强烈、没有闪光灯，在灯光越暗的情况下照出来效果越好。它还有一种特殊的“隧道效果”：照片的四周会显得比中间暗很多。不过这些技术上或光学上的特性都不是Lomo的特点。它的主要吸引力反而体现在一种跨地域性的地下创造活动。","categories":[{"name":"essay","slug":"essay","permalink":"http://lomo.space/categories/essay/"}],"tags":[]},{"title":"js count length","slug":"js-count-length","date":"2016-03-30T06:37:30.000Z","updated":"2022-01-14T11:40:22.882Z","comments":true,"path":"2016/03/30/js-count-length/","link":"","permalink":"http://lomo.space/2016/03/30/js-count-length/","excerpt":"","text":"JavaScript计算对象长度直接封装函数: 12345678910111213141516function countObjectLength(obj) &#123; var Length = 0; if ((typeof obj) == &quot;string&quot;) &#123; return obj.length; &#125; else if ((typeof obj) == &quot;object&quot;) &#123; for (var key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; Length++; &#125; &#125; return Length; &#125; else &#123; console.log(&quot;既不是字符串也不是对象无法计算长度&quot;); return; &#125;&#125; 测试该函数: 12345678910111213141516//Test Objectvar a = &#123;&quot;name&quot;:&quot;Lomo&quot;, &quot;amy&quot;:&quot;Sherry&quot;,&quot;age&quot;:&quot;26&quot;&#125;alert(typeof a); //objectalert(countObjectLength(a)); //3//Test Arrayvar b = [1,2,3,&quot;lomo&quot;];alert(typeof b); //objectalert(countObjectLength(b));//Test stringvar c = &#x27;lomoao&#x27;;alert(countObjectLength(c)); //6var arr = new Array(&quot;123&quot;,&quot;345&quot;,&quot;chnhawk&quot;,&quot;Sherry&quot;,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;);alert(countObjectLength(arr)); //7 看起来，好像没毛病啊！！！ 但是测试的对象里并不包含特殊情况，所以是存在问题的！ 关于hasOwnProperty hasOwnProperty() 方法返回的是一个bool型。如: a.hasOwnProperty(b), 判断a是否包含属性b, 属性b可能是个成员变量, 也可能是个成员方法.在JavaScript中, 利用 hasOwnProperty() 方法去判断某个对象是否含有指定属性时, 在某些特殊情况下, 这个对象的属性名可能恰好使用的是这个关键字. 例如： 1234567891011 var foo = &#123; hasOwnProperty: function() &#123; return false; &#125;, bar: &#x27;Here be dragons&#x27;, lomo: &quot;lo&quot;&#125;; foo.hasOwnProperty(&#x27;bar&#x27;); // 始终返回 falsefoo.hasOwnProperty(&#x27;hasOwnProperty&#x27;); //始终返回错误foo.hasOwnProperty(&quot;lomo&quot;); //false 此时，使用开头的封装函数测试，也是无法得到正确结果的。 为什么？ 因为：因为冲突，被覆盖！ 解决办法: 使用外部原型链上的、或Object的hasOwnProperty属性方法去判断 12345// 直接使用原型链上真正的 hasOwnProperty 方法(&#123;&#125;).hasOwnProperty.call(foo, &#x27;lomo&#x27;); // true// 也可以使用 Object 原型上的 hasOwnProperty 属性Object.prototype.hasOwnProperty.call(foo, &#x27;bar&#x27;); // true 对开头封装的函数进行改进： 1234567891011121314151617 function countObjectLength(obj) &#123; var Length = 0; if ((typeof obj) == &quot;string&quot;) &#123; return obj.length; &#125;else if ((typeof obj) == &quot;object&quot;) &#123; for (var key in obj) &#123; //使用外部原型链 if((&#123;&#125;).hasOwnProperty.call(obj, key)) &#123; Length ++; &#125; &#125; return Length; &#125;else &#123; console.log(&quot;既不是字符串也不是对象无法计算长度&quot;); return; &#125;&#125; 或 1234567891011121314151617 function countObjectLength(obj) &#123; var Length = 0; if ((typeof obj) == &quot;string&quot;) &#123; return obj.length; &#125;else if ((typeof obj) == &quot;object&quot;) &#123; for (var key in obj) &#123; //使用Object上的hasOwnproperty方法 if(Object.prototype.hasOwnProperty.call(obj, key)) &#123; Length ++; &#125; &#125; return Length; &#125;else &#123; console.log(&quot;既不是字符串也不是对象无法计算长度&quot;); return; &#125;&#125; 测试 123456789var foo = &#123; hasOwnProperty: function() &#123; return false; &#125;, bar: &#x27;Here be dragons&#x27;, lomo: &quot;lo&quot;&#125;;countObjectLength(foo); // 输出：3 这两种函数都算是一个考虑很周(考虑到了特殊字符)的长度计算的最佳方法.","categories":[{"name":"program","slug":"program","permalink":"http://lomo.space/categories/program/"}],"tags":[{"name":"js","slug":"js","permalink":"http://lomo.space/tags/js/"}]},{"title":"Java Singleton Patterns","slug":"Java-Singleton-Patterns","date":"2016-03-26T11:00:37.000Z","updated":"2022-01-14T11:40:22.871Z","comments":true,"path":"2016/03/26/Java-Singleton-Patterns/","link":"","permalink":"http://lomo.space/2016/03/26/Java-Singleton-Patterns/","excerpt":"","text":"Java设计模式之单例模式[笔记]定义一个类有且仅有一个实例，并且自行实例化向整个系统提供实例调用。 在应用中，单例模式可以使得单例对象保存在JVM中，该对象只有一个实例存在。 应用场景1. 某些类创建频繁(对于大型对象如果每次都去new对象，将会增大系统开销) 2.省去new操作符，降低内存使用频率，减轻GC(垃圾回收)的压力 3.保证核心功能实例对象可以控制整个系统流程 示例 One 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package javaClassExercise.designPatterns.singleton;/** * Created by lomo. * * 单例模式 * */public class Singleton &#123; /* 私有静态变量instance, 防止被引用; instance变量在此处赋值为null, 实现延迟加载 -- 有的类比较大 延迟加载提升性能*/ private static Singleton instance = null; /* 定义私有类型的构造函数(默认为public级别)， 可以防止被实例化new*/ private Singleton() &#123;&#125; /*public访问级别、静态static类型的返回类型为Singleton引用类型的getInstance方法； getInstance方法作用：获取本类实例*/// public static Singleton getInstance() &#123;// if (instance == null) &#123;// return new Singleton();// &#125;//// return instance;// &#125; //第一次改进后的： //加了synchronized关键字保证了同步性，只需要在创建时上一次锁，(也避免每次调用该方法时对调用对象上锁) //此时，调用的时候是不需要加锁，当instance为null，并创建对象时才需要加锁， //问题：此时还是存在问题，当2个线程同时需要调用该方法时，第一个线程访问后，在内存里创建了实例对象， // 但是由于JVM的一些优化机制，导致线程2调用Singleton实例时，发现Singleton未被实例，获取不到内存中保存的实例对象，就会报错 public static Singleton getInstance() &#123; if (instance == null) &#123; synchronized (Singleton.class) &#123; if (instance == null) &#123; return new Singleton(); &#125; &#125; &#125; return instance; &#125; public Object readResolve() &#123; return instance; &#125;// public static void main(String... args) &#123;// System.out.print(Singleton.getInstance().hashCode());// System.out.println(instance); //null// System.out.println(instance instanceof Singleton); // false// Singleton singleton = new Singleton(); //Exception in thread &quot;main&quot; java.lang.NullPointerException, 空指针异常// Singleton singleton1 = new Singleton();// &#125;&#125;// 当多个线程同时调用该单例类的方法时，对于无保护的这种类，如何改进避免出现异常问题？ Two使用一个内部类来维护、创建单例类的实例 1234567891011121314151617181920212223242526272829package javaClassExercise.designPatterns.singleton;/** * Created by lomo . * * 对Singleton类升级 -&gt; 一个完整的单例类 * */public class CompleteSingleton &#123; /* 定义私有类型的构造函数(默认为public级别)， 可以防止被实例化new*/ private CompleteSingleton()&#123;&#125; /* 使用一个内部类来专门维护单例类 */ private static class SingletonFactory&#123; private static CompleteSingleton instance = new CompleteSingleton(); &#125; /* 获取单例类的实例 */ public static CompleteSingleton getInstance() &#123; return SingletonFactory.instance; &#125; /* 如果该对象被用于序列化，可以保证对象在序列化前后保持一致 */ /* 序列化：就是讲Java对象转换为字节序列的过程 */ /* 序列化作用：将Java对象序列化成字节 然后保存于磁盘 或用于在网络传送字节 */ public Object readResove() &#123; return getInstance(); &#125;&#125; Three使用synchronized关键字，提供一个单例类实例创建的方法 123456789101112131415161718192021222324252627282930package javaClassExercise.designPatterns.singleton;/** * Created by lomo. */public class SingletonTest &#123; /* 私有静态变量instance, 防止被引用; instance变量在此处赋值为null, 实现延迟加载 -- 有的类比较大 延迟加载提升性能*/ private static SingletonTest instance = null; /* 私有构造函数，防止被new实例化 */ private SingletonTest() &#123;&#125; /* syncInit方法用来初始化单例类实例(限于单例内的内部) */ // 同步性，synchronized关键字锁定的是对象 private static synchronized void syncInit() &#123; if (instance == null) &#123; new SingletonTest(); &#125; &#125; /* public级别的可供外部内访问的方法，用来获取单例类实例对象 */ public static SingletonTest getInstance() &#123; if (instance == null) &#123; syncInit(); &#125; return instance; &#125;&#125; 第二种和第三种大同小异，视情况选择. 实际项目分析 公司内部项目代码简单分析 一条测试case 1234567891011public class FinancialServicePageClickTest extends AbstractTestCases &#123; @Test(testName = &quot;xx001&quot;, description = &quot;xxxx&quot;, groups = &quot;pc&quot;) public void ClickJiuDingInvestmentTest() throws Exception &#123; NavigationPage navigationPage = new NavigationPage(driver); EnterprisePCPage enterprisePCPage = navigationPage.clickEnterpriseLink(); FinancialServicePCPage financialServicePCPage = enterprisePCPage.clickFinancialServiceLink(); financialServicePCPage.GoToJiuDingInvestment(); WebReporter.log(driver, driver.getTitle(), true, true); &#125;&#125; 测试子类FinancialServicePageClickTest继承自AbstractTestCases类，父类AbstractTestCases实现了针对APP、PC端的driver的初始化(在执行具体的测试方法前就为测试类中的方法准备好必须的driver) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//testng自定义的监听器@Listeners(&#123; filter.MethodSelector.class &#125;)public class AbstractTestCases &#123; public static WebDriver driver; public static AppiumDriver appiumDirver; /** * Init driver * * @throws Exception */ @BeforeMethod public void initDriver() throws Exception &#123; switch (ConfigUtil.getConfigUtil().getConfigFileContent(&quot;deviceType&quot;)) &#123; case &quot;pc&quot;: driver = DriverFactory.createNewDriver(); break; case &quot;phone&quot;: appiumDirver = DriverFactory.createAppiumDriver(); break; default: break; &#125; &#125; /** * Destory driver */ @AfterMethod public void destoryDriver() &#123; switch (ConfigUtil.getConfigUtil().getConfigFileContent(&quot;deviceType&quot;)) &#123; case &quot;phone&quot;: WebReporter.log(appiumDirver, true, true, true); DriverFactory.closeAppiumDriver(); break; case &quot;pc&quot;: WebReporter.log(driver, driver.getTitle(), true, true); DriverFactory.CloseDriver(); break; default: break; &#125; &#125; /** * log message to TestNG result * * @param str */ public static void logMessage(String str) &#123; Reporter.log(str, 5, true); // Making a log entry. &#125;&#125; 关于TestNG的@Listeners注解： 看TestNG这个注解的源码： 1234567891011121314151617181920212223242526272829303132package org.testng.annotations;import static java.lang.annotation.ElementType.TYPE;import org.testng.IAnnotationTransformer;import org.testng.IAnnotationTransformer2;import org.testng.ITestNGListener;import java.lang.annotation.Retention;import java.lang.annotation.Target;/** * This annotation lets you define listeners directly on a test class * instead of doing so in your testng.xml. Any class that implements * the interface &#123;@link org.testng.ITestNGListener&#125; is allowed, * except &#123;@link IAnnotationTransformer&#125; and &#123;@link IAnnoationTransformer2&#125;, * which need to be defined in XML since they have to be known before we even * start looking for annotations. * * Note that listeners specified this way are global to your entire suite, just * like listeners specified in testng.xml. * * @author Cedric Beust, Mar 26, 2010 * */@Retention(java.lang.annotation.RetentionPolicy.RUNTIME)@Target(&#123;TYPE&#125;)//TestNG的自定义注解public @interface Listeners &#123; Class&lt;? extends ITestNGListener&gt;[] value() default &#123;&#125;;&#125; 关于TestNG此注解的详细，可点我查看 关于 TestNG 的详细使用教程, 可参考这篇全英文教程, 很详细. 点我 DriverFactory类： 使用单例的设计模式实现对driver的初始化，使得在case运行过程中，都保障其操作都是一个driver实例. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143public class DriverFactory &#123; private static WebDriver driver = null; private static AppiumDriver appiumDriver = null; private static Logger log = LogFactory.getLogger(DriverFactory.class); private static ConfigUtil configUtil = ConfigUtil.getConfigUtil(); private static String osType = System.getProperty(&quot;os.name&quot;).toLowerCase(); //定义一个private访问级别的构造函数，防止被实例化new对象 private DriverFactory() &#123; &#125; /** * create method to get OS type and auto choose the driver for it * * @return */ private static boolean isMacOS() &#123; return osType.indexOf(&quot;mac&quot;) &gt;= 0; &#125; private static boolean isWindows() &#123; return osType.indexOf(&quot;window&quot;) &gt;= 0; &#125; /** * Create a new driver for FF,CHROME,IE * * @return WebDriver that you want style * @throws Exception */ private static WebDriver CreateBroswerDriver() throws Exception &#123; if (configUtil.getConfigFileContent(&quot;isRemoteDriver&quot;).equals(&quot;false&quot;)) &#123; switch (configUtil.getConfigFileContent(&quot;broswerType&quot;)) &#123; case &quot;firefox&quot;: return new FirefoxDriver(switchLocalDriverPath()); case &quot;chrome&quot;: return new ChromeDriver(switchLocalDriverPath()); case &quot;ie&quot;: return new InternetExplorerDriver(switchLocalDriverPath()); case &quot;safari&quot;: return new SafariDriver(switchLocalDriverPath()); default: return driver; &#125; &#125; else &#123; URL remoteUrl = new URL(configUtil.getConfigFileContent(&quot;remoteDriverURL&quot;)); switch (configUtil.getConfigFileContent(&quot;broswerType&quot;)) &#123; case &quot;firefox&quot;: return new RemoteWebDriver(remoteUrl, switchLocalDriverPath()); case &quot;chrome&quot;: return new RemoteWebDriver(remoteUrl, switchLocalDriverPath()); case &quot;ie&quot;: return new RemoteWebDriver(remoteUrl, switchLocalDriverPath()); case &quot;safari&quot;: return new RemoteWebDriver(remoteUrl, switchLocalDriverPath()); default: return driver; &#125; &#125; &#125; //单例模式创建驱动Driver public static WebDriver createNewDriver() throws Exception &#123; log.info(&quot;Current Driver is null : &quot; + (driver == null)); if (driver == null) &#123; synchronized (WebDriver.class) &#123; if (driver == null) &#123; driver = CreateBroswerDriver(); setUpDriverSize(driver).get(configUtil.getConfigFileContent(&quot;defaultURL&quot;)); return driver; &#125; &#125; &#125; return driver; &#125; //提供一个获取Driver实例的方法 public static WebDriver getCurrentDriver() throws Exception &#123; return createNewDriver(); &#125; /** * Create a new Appium driver for iOS,Android * * * @return Appium drive that you want style */ public static AppiumDriver createAppiumDriver() throws MalformedURLException &#123; log.info(&quot;Current Driver is null : &quot; + (appiumDriver == null)); if (appiumDriver == null) &#123; synchronized (AppiumDriver.class) &#123; if (appiumDriver == null) &#123; DesiredCapabilities capabilities = new DesiredCapabilities(); capabilities.setCapability(&quot;platformName&quot;, ConfigUtil.getConfigUtil().getConfigFileContent(&quot;phonePlatform&quot;)); capabilities.setCapability(&quot;platformVersion&quot;, ConfigUtil.getConfigUtil().getConfigFileContent(&quot;platformVersion&quot;)); capabilities.setCapability(&quot;deviceName&quot;, ConfigUtil.getConfigUtil().getConfigFileContent(&quot;deviceName&quot;)); capabilities.setCapability(&quot;app&quot;, ConfigUtil.getConfigUtil().getConfigFileContent(&quot;applactionLocation&quot;)); if (ConfigUtil.getConfigUtil().getConfigFileContent(&quot;phonePlatform&quot;).equals(&quot;iOS&quot;)) &#123; capabilities.setCapability(&quot;autoAcceptAlerts&quot;, true); appiumDriver = new IOSDriver( new URL(ConfigUtil.getConfigUtil().getConfigFileContent(&quot;appiumDriverURL&quot;)), capabilities); &#125; else appiumDriver = new AndroidDriver( new URL(ConfigUtil.getConfigUtil().getConfigFileContent(&quot;appiumDriverURL&quot;)), capabilities); return appiumDriver; &#125; &#125; &#125; return appiumDriver; &#125; //略去... //.... //一些其它方法..... /** * Close broswer driver */ public static void CloseDriver() &#123; driver.quit(); driver = null; &#125; /** * Close appium driver */ public static void closeAppiumDriver() &#123; appiumDriver.quit(); appiumDriver = null; &#125;&#125; 在DriverFactory类中，分别实现了对PC Driver的初始化和对APP端包括iOS、Android的Driver初始化，其可以进一步使用抽象工厂设计模式，将其进一步优化.","categories":[{"name":"study","slug":"study","permalink":"http://lomo.space/categories/study/"}],"tags":[{"name":"java","slug":"java","permalink":"http://lomo.space/tags/java/"},{"name":"DesignPatterns","slug":"DesignPatterns","permalink":"http://lomo.space/tags/DesignPatterns/"}]},{"title":"Java Factory Method Abstract","slug":"Java-Factory-Method-Abstract","date":"2016-03-26T10:41:11.000Z","updated":"2022-01-14T11:40:22.870Z","comments":true,"path":"2016/03/26/Java-Factory-Method-Abstract/","link":"","permalink":"http://lomo.space/2016/03/26/Java-Factory-Method-Abstract/","excerpt":"","text":"Java设计模式之抽象工厂模式[笔记]缘由 工厂方法，对类的创建依赖于工厂类，如果要拓展程序，就要修改原来的这个工厂类，所以使用抽象工厂模式，创建多个工厂类，对于扩展的程序，增加一个对应的工厂类即可；其实，这相当于对工厂模式再次升级，将工厂里的方法进行再一次抽象(一般，将这个工厂类里的这个公有方法抽象成另一个接口)，然后再在这些工厂类里实现这个接口即可。 实例功能模块类接口interface 之Sender接口 123456789package javaClassExercise.designPatterns.abstractFactory;/** * Created by lomo. * * 实现各个功能模块的公有接口 */public interface Sender &#123; public void send();&#125; 工厂类公有方法抽象成的类接口interface 之Provider接口 1234567891011121314151617package javaClassExercise.designPatterns.abstractFactory;/** * Created by lomo. * * 提供一个工厂类共有的接口, 各个具体功能模块对应的工厂类实现该接口的方法即可 * 调用时，只需要调用对象功能模块的工厂类即可获取对应功能类的实例 * 拓展时，只需要增加一个功能模块类(实现功能公有的接口)，和另一个 工厂类(实现工厂类公有的接口) 即可。 * * 为何声明返回类型为Sender类型？ * 该接口声明一个返回类型为Sender类型的produce方法，实现该接口的类时必须实现对应的produce方法， * 这样一来，实现的工厂类 类中实现该produce方法即可获得对应功能模块的实例 * 调用时只要new该工厂类实例，然后调用对应的方法即可获得对应的功能类实例; */public interface Provider &#123; public Sender produce();&#125; 具体的功能模块类1：(实现Sender接口的) 1234567891011package javaClassExercise.designPatterns.abstractFactory;/** * Created by lomo . */public class MailSender implements Sender &#123; @Override public void send() &#123; System.out.println(&quot;您调用了抽象工厂模式下的功能类MailSender里的send方法 -- 具体实现功能类1！！&quot;); &#125;&#125; 具体的功能模块类2：(实现Sender接口的) 1234567891011package javaClassExercise.designPatterns.abstractFactory;/** * Created by lomo. */public class SmsSender implements Sender &#123; @Override public void send() &#123; System.out.println(&quot;您调用了抽象工厂模式下的功能类SmsSender里的send方法 -- 具体实现功能类2！！&quot;); &#125;&#125; 工厂类1, 实现了对功能类1 mail的实例化创建 12345678910111213package javaClassExercise.designPatterns.abstractFactory;/** * Created by lomo. * * SendMailFactory工厂类 实现了 对MailSender功能类的实例创建 */public class SendMailFactory implements Provider &#123; @Override public Sender produce() &#123; return new MailSender(); &#125;&#125; 工厂类2, 实现了对功能类2 sms的实例化创建 12345678910111213package javaClassExercise.designPatterns.abstractFactory;/** * Created by lomo. * * 工厂类SendSmsFactory 实现了 对SmsSender类实例的创建 */public class SendSmsFactory implements Provider&#123; @Override public Sender produce() &#123; return new SmsSender(); &#125;&#125; 测试类 1234567891011121314151617181920212223242526272829package javaClassExercise.designPatterns.abstractFactory;/** * Created by lomo. * * 测试抽象工厂类 * * 详细解释见注释！！！ */public class abstractFactoryTest &#123; public static void main(String[] args) &#123; //创建一个工厂类SendMailFactory的实例provider Provider provider = new SendMailFactory(); //获得一个MailSender类的实例sender Sender sender = provider.produce(); sender.send(); //您调用了抽象工厂模式下的功能类MailSender里的send方法 -- 具体实现功能类1！！ /* 详细注释 + 解释 */ //通过 工厂类SendSmsFactory 创建一个provider1实例, 并将该实例存储在provider1对象中 Provider provider1 = new SendSmsFactory(); //通过对provider1这个对象的produce方法调用，可以获得SmsSender这个功能类的实例，并将其存储在sender1对象中 Sender sender1 = provider1.produce(); //调用sender1对象中存储的SmsSender实例的方法send() sender1.send(); //输出：您调用了抽象工厂模式下的功能类SmsSender里的send方法 -- 具体实现功能类2！！ &#125;&#125;","categories":[{"name":"study","slug":"study","permalink":"http://lomo.space/categories/study/"}],"tags":[{"name":"java","slug":"java","permalink":"http://lomo.space/tags/java/"},{"name":"DesignPatterns","slug":"DesignPatterns","permalink":"http://lomo.space/tags/DesignPatterns/"}]},{"title":"Java Factory Method","slug":"Java-Factory-Method","date":"2016-03-25T10:36:53.000Z","updated":"2022-01-14T11:40:22.870Z","comments":true,"path":"2016/03/25/Java-Factory-Method/","link":"","permalink":"http://lomo.space/2016/03/25/Java-Factory-Method/","excerpt":"","text":"Java设计模式之工厂模式[笔记]简介 设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便 分类三大类[主要]： 一、创建型模式(5种) ①工厂方法 ②抽象工厂 ③单例 ④创建者 ⑤原型 二、结构型模式(7种) ①适配器模式 ②装饰器模式 ③代理模式 ④外观模式 ⑤桥接模式 ⑥组合模式 ⑦享元模式 三、行为型模式(11种) ①策略模式 ②模板方法模式 ③观察者模式 ④迭代子模式 ⑤责任链模式 ⑥命令模式 ⑦备忘录模式 ⑧状态模式 ⑨访问者模式 🔟中介者模式 ①①解释器模式 其他两大类： 12一、并发型 二、线程池 工厂模式工厂模式，类的创建依赖于工厂类， a. 一般工厂模式 一般，将工厂模式里的类设置为static静态的，不需要创建，直接调用。[静态工厂模式] 一个工厂类里就一个工厂方法，根据传入字段创建不同类的实例； b. 多个工厂模式 将a升级，一个工厂类中声明多个工厂方法，不同的方法产生不同类的实例； c. 静态工厂模式 将b升级，工厂类中的多个工厂方法声明为static类型，使用时不用new对象，直接使用工厂类名.方法名即可； 相比较a,b,c， 通常选择c 静态工厂方法模式； 实例 所有实例及分析基本都在代码及其注释中，便于阅读理解其含义！ 一般工厂模式123456789package javaClassExercise.designPatterns.factoryMethod.generalFactoryMethod;/** * Created by lomo. * 创建一个发送邮件和发送短信共用的一个接口Sender */public interface Sender &#123; public void send();&#125; 123456789101112package javaClassExercise.designPatterns.factoryMethod.generalFactoryMethod;/** * Created by lomo. * 实现Sender接口中的send()方法 */public class SmsSender implements Sender &#123; @Override public void send() &#123; System.out.println(&quot;这是另一个Sender接口实现类 -- SmsSender ！！！&quot;); &#125;&#125; 1234567891011121314package javaClassExercise.designPatterns.factoryMethod.generalFactoryMethod;/** * Created by lomo. * 实现Sender接口中的send()方法 */public class MailSender implements Sender &#123; @Override public void send() &#123; System.out.println(&quot;这是Sender接口实现类 -- MailSender !!!&quot;); &#125;&#125; 工厂类 123456789101112131415161718192021222324252627282930313233package javaClassExercise.designPatterns.factoryMethod.generalFactoryMethod;/** * Created by lomo. * * 【定义】普通工厂模式：就是建立一个工厂类，对实现了同一接口的一些类进行实例的创建。 * * * 发送消息的工厂类, 这个工厂类的作用就是对实现Sender接口的2个类：MailSender类和SmsSender类 **进行实例(new）的创建** -- Sender类型的produce方法. * * 此实例中的普通工厂模式 即：只有一个工厂类【这个工厂类里对多个方法类进行了new操作】, 对各个类方法new时需要根据传入参数区分来创建对应的实例. * */public class SendFactory &#123; /* 根据传入的type类型 返回不同类的实例，而这2个类都是实现了同一个接口(类)，所以produce方法类型即为自定义类型：Sender类型. */ public Sender produce(String type) &#123; if (&quot;mail&quot;.equals(type)) &#123; return new MailSender(); &#125; else if (&quot;sms&quot;.equals(type)) &#123; return new SmsSender(); &#125; else &#123; System.out.println(&quot;请输入正确的type ！&quot;); return null; //思考🤔：此处退出程序为什么需要返回null? 那么return, return 0可以吗? &#125; &#125;&#125;/*答：produce方法定义其返回类型必须为Sender类的引用类型，只有null可以，直接return是无返回类型void， return 0的必须要求produce方法定义的返回类型为int或Interger类型.*/ 首先，Java中是对大小写敏感, 只有null, 无NULL、Null这类写法。null也是Java中的关键字; 就像其它类型一样，每种原始类型都有其默认值，int类型默认值0，boolean默认值false； 而null是任何引用类型的默认值, 在Java中任何引用类型变量(Integer、Short、Double等,但是int、short、double这些则不可!)将null作为默认值 例如： 123Object object = null; //正确✔Object object = NULL; //错误❌Object object = Null; //错误❌，IDE直接报错d 关于Java中null的九件事, 点击查看. > 测试类 12345678910111213141516171819202122232425262728package javaClassExercise.designPatterns.factoryMethod.generalFactoryMethod;/** * Created by lomo. * 创建一个测试工厂方法类的测试类 * 工厂类中已经实现了对Sender接口类的创建， 这个工厂类的作用就是实现了对 实现同一个接口 但是不同方法类的创建/new */public class GeneralFactoryMethodTest &#123; public static void main(String... args) &#123; SendFactory sendFactory = new SendFactory(); //new实例化一个SendFactory工厂类 Sender sender = sendFactory.produce(&quot;sms&quot;); sender.send(); //这是另一个Sender接口实现类 -- SmsSender ！！！ Sender sender1 = sendFactory.produce(&quot;mail&quot;); sender1.send(); //这是Sender接口实现类 -- MailSender !!! &#125;&#125;/* 思考: 这样设计一个Sender 发送功能的接口，然后再创建2个发送邮件和发送短信的功能类，再创建一个工厂类对这2个功能类进行实例化创建， 有什么好处？？？ 如何不这样设计呢？ 如果现在需要增加一个发送即时消息(和短信类似)的功能，那么如果不按照这种设计模式写，代码会是怎样的呢？ 按照常有的思考模式: 创建一个类，类中包含三个方法，一个是发送邮件、一个发送短信、加上新增的发送即时消息的方法，测试使用时，需要new这个类，然后再调用对应的方法。 这样写下去，如果以后还有其它好多个发送类的方法需要扩展，则需要修改这个原始类文件，使得这个类变得臃肿，难以维护. 而， 使用工厂模式呢？ 多有发送类的具体方法都属于各自的类(这些类又实现自同一个Sender接口类)，这个发送类的方法不用考虑是否影响其他类功能， 只需要专注实现、完美自己的功能，然后再在对应的工厂类中实现对应实例的创建，在调用的时候只需new工厂类，通过工厂类去创建对应方法的实例， 实现层级化(层级清晰，不是传统的流水账模式)，同时便于拓展、维护！ */ 多个工厂模式 对一般工厂模式中的工厂类升级 123456789101112131415161718package javaClassExercise.designPatterns.factoryMethod.manyFactoryMethod;/** * Created by lomo. * * 多个工厂类模式，对普通工厂模式(一个工厂类)升级, 普通工厂模式中的工厂类中只有一个方法并依据传入的参数进行对应方法类的new * 多个工厂类模式，针对不用方法类定义不同的方法进行对应方法类的实例化new * 这样一来，就方便使用什么发送方法就调用这个工厂类中对应方法即可. * */public class ManyFactoryMethod &#123; public Sender produceMail() &#123; return new MailSender(); &#125; public Sender produceSms() &#123; return new SmsSender(); &#125;&#125; 测试类： 1234567891011121314151617181920package javaClassExercise.designPatterns.factoryMethod.manyFactoryMethod;/** * Created by lomo. * * 对个工厂方法模式测试 * 多个工厂方法模式好处：调用哪个类的方法，是使用new的工厂类实例.那个对应的new这个类方法(工厂类里的方法) */public class ManyFactoryMethodTest &#123; public static void main(String[] args) &#123; ManyFactoryMethod manyFactoryMethod = new ManyFactoryMethod(); //System.out.println(manyFactoryMethod.produceMail().getClass()); //class javaClassExercise.designPatterns.factoryMethod.manyFactoryMethod.MailSender Sender sender = manyFactoryMethod.produceMail(); sender.send(); //这是Sender接口实现类 -- MailSender2 !!! Sender sender1 = manyFactoryMethod.produceSms(); sender1.send(); //这是另一个Sender接口实现类 -- SmsSender2 ！！！ &#125;&#125; 总结: 多个工厂模式即：将一般工厂模式的一个工厂类中的一个方法进行升级改造，改写成一个工厂类多个方法，各个方法对应具体功能模块类的实例化new. 静态工厂模式 将多工厂模式升级改造，将工厂类声明为static静态类型，使其不用实例化对象就可以直接调用对应的方法直接创建对应功能模块类的实例对象, 使用方式: 类名.方法名. 静态工厂类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package javaClassExercise.designPatterns.factoryMethod.staticFactoryMethod;/** * Created by lomo on 2017/3/25. * * 静态工厂方法模式（静态static的、多个工厂方法类） * 静态工厂方法模式好处：不用new实例，直接调用， 工厂类名.方法名即可 * * 顺便复习下static关键字 */public class StaticFactoryMethod &#123; //static静态的返回类型为Sender类型的produceMail方法 //类中的静态方法中对于本类而言：①只能访问本类的静态变量和类中其他静态方法 ②无this //private String name; public static Sender produceMail() &#123; return new MailSender(); //System.out.println(name); //报错, 静态方法中不能调用类外的非静态变量 //test t = new test(); // 提示错误： nreachable statement, 无法访问的 &#125; public static Sender produceSms() &#123; return new SmsSender(); &#125;// test t = new test(); //此处访问Ok// static &#123;// System.out.print(&quot;静态static代码块中调用：&quot;);// test t = new test(); // 在static 代码块中访问也Ok.// &#125;// public void noStaticMethod() &#123;// test t = new test(); //非static里访问也OK// t.testC();// t.testD(); //非静态方法中访问其他类的非静态方法--ok!// &#125;// public static void main(String[] args) &#123;// test t = new test();// //输出:// //静态static代码块中调用：您调用了test类的构造方法 !// //您调用了test类的构造方法 !// //先执行的是本类中的static静态代码块，再执行new test()操作 -- test类中的构造函数.////// t.testC();//// //输出：//// //您调用了test类中的非静态的testC() 方法 !//// t.testD();//// //输出：//// //调用的是test类中的静态方法testD() 方法 !// // noStaticMethod(); // 主函数是static的，故也不可以调用非此静态方法// &#125;&#125;class test&#123; public test() &#123; System.out.println(&quot;您调用了test类的构造方法 !&quot;); &#125; public void testC() &#123; System.out.println(&quot;您调用了test类中的非静态的testC() 方法 !&quot;); &#125; public static void testD() &#123; System.out.println(&quot;调用的是test类中的静态方法testD() 方法 !&quot;); &#125;&#125;//无静态类，尝试创建static 的class时会自动报错 测试类 123456789101112131415package javaClassExercise.designPatterns.factoryMethod.staticFactoryMethod;/** * Created by lomo. * 测试类：测试 静态工厂方法模式 */public class StaticFactoryMethodTest &#123; public static void main(String... args) &#123; //不需要创建实例，直接类型.方法名 Sender sender = StaticFactoryMethod.produceMail(); sender.send(); // 这是Sender接口实现类 -- MailSender3 !!! Sender sender1 = StaticFactoryMethod.produceSms(); sender1.send(); // 这是另一个Sender接口实现类 -- SmsSender3 ！！！ &#125;&#125; 对于工厂模式，一般选择第三种: 静态工厂模式即可.","categories":[{"name":"study","slug":"study","permalink":"http://lomo.space/categories/study/"}],"tags":[{"name":"java","slug":"java","permalink":"http://lomo.space/tags/java/"},{"name":"DesignPatterns","slug":"DesignPatterns","permalink":"http://lomo.space/tags/DesignPatterns/"}]},{"title":"Java String/StringBuffer/StringBuilder","slug":"java-String-StringBuffer-StringBuilder","date":"2016-03-13T06:42:35.000Z","updated":"2022-01-14T11:40:22.881Z","comments":true,"path":"2016/03/13/java-String-StringBuffer-StringBuilder/","link":"","permalink":"http://lomo.space/2016/03/13/java-String-StringBuffer-StringBuilder/","excerpt":"","text":"Java 数据类型[学习笔记]Java数据类型基本数据类型 int 、short、float、double、long、byte、boolean、char 其中char类型变量，声明初始化时用单引号&#39;&#39; 包装类 Integer、Short、Float、Double、Long、Byte、Boolean、Character String类型 String类型数据 声明初始化时 使用双引号 &quot;&quot; String不是基本数据类型；它是由final修饰的，所以也不可以继承； String类型变量的2种赋值方式: 12345//一种直接赋值，例如 String a = &quot;hello world&quot;；//另一种是用构造方法，例如 String b = new String (&quot;hello world&quot;); String 类型的可以认为有三种：String、StringBuffer、StringBuilder String类定义如： 1String s = &quot;chen&quot;; JVM的栈内存中保存变量s , 堆内存中保存字符串”chen”对象，s 指向字符串chen的地址. JVM在处理该类字符串时，会进行缓存，比如，如果再声明一个 1String t = &quot;chen&quot;; 则t和s指向的是同一个对象的地址，故：s &#x3D;&#x3D; t &#x2F;&#x2F; 输出true； 特征 String声明的字符串长度是不可变的，当一个String对象完成创建后，该对象的内容就固定； String类常用方法使用.length 获取字符串长度 StringBuffer 可变字符串类，长度不固定；使用StringBuffer()时，默认开辟16个字符的长度的空间； StringBuffer和StringBuilder都一样，且都继承了AbstractStringBuilder类 12345StringBuffer sb = new StringBuffer(&quot;hello&quot;); StringBuffer sb2 = new StringBuffer(&quot;hello&quot;); System.out.println(sb.equals(sb2)); //输出: false 分析：String类重写了Object类的equals方法，所以只需要看内容是否相等；但是StringBuffer类没有重写Object类的equals方法，此处的equals()仍然是调用Object类的，所以，调用StringBuffer类的equals()，只有地址和内容都相等的字符串，结果才会返回true. Java中字符串拼接最安全的方式是使用StringBuffer的apped方法.String类在追加的时候，源字符串不变（这就是为什么说String是不可变的字符串类型），和新串连接后，重新开辟 一个内存。这样就会造成每次连接一个新串后，都会让之前的串报废，因此也造成了不可避免的内存泄露. StringBuilder 可变字符串类，长度不固定； StringBuilder类的初始化和主要常用方法和上述的StringBuffer相同. 三者之间的区别 StringBuffer是线程安全，大多数方法前面都有关键字synchronized，这样就会有一定的性能消耗。 StringBuilder是非线程安全的，所以效率是三个中最高的。String是效率最低的 &#x3D;&#x3D;和equals区别String类的&#x3D;&#x3D;和equalse.g.1 12345678910111213141516171819 public class StringInit &#123; public static void main(String[] args) &#123; String s = &quot;hello world&quot;; String s1 = new String(&quot;hello world&quot;); String s2 = new String(&quot;hello world&quot;); String s3 = new String(&quot;hello&quot;); String s4 = &quot;hello world&quot;; System.out.println(s.equals(s1));; System.out.println(s1.equals(s2)); System.out.println(s1.equals(s3)); System.out.println(&quot;------------------&quot;); System.out.println(s == s1); System.out.println(s == s3); System.out.println(s == s4); &#125; &#125; 输出： 1234567truetruefalse------------------falsefalse true 查看源码发现，String类重写了Object类的equals方法： 123456789101112131415161718192021public boolean equals(Object anObject) &#123; if (this == anObject) &#123; return true; &#125; if (anObject instanceof String) &#123; String anotherString = (String) anObject; int n = value.length; if (n == anotherString.value.length) &#123; char v1[] = value; char v2[] = anotherString.value; int i = 0; while (n-- != 0) &#123; if (v1[i] != v2[i]) return false; i++; &#125; return true; &#125; &#125; return false;&#125; 所以： equals比较的是对象的内容，即JVM堆内存中的内容, &#x3D;&#x3D; 比较的是地址，即栈内存中的内容. 使用构造方法new 创建字符串时，和直接赋值是不一样的! StringBuffer与StringBuilder类的&#x3D;&#x3D;和equalse.g.2 12345678910111213141516171819202122232425public class equalsCompare &#123; public static void main(String[] args) &#123; String a = new String(&quot;cd&quot;); String b = new String(&quot;cd&quot;); System.out.println(&quot;String使用==比较的结果：&quot; + (a == b) ); // false System.out.println(&quot;String使用equals比较的结果：&quot; + a.equals(b)); //true StringBuffer sb = new StringBuffer(&quot;chen&quot;); StringBuffer sb2 = new StringBuffer(&quot;chen&quot;); System.out.println(&quot;StringBuffer使用==比较的结果：&quot; + (sb == sb2) ); // false System.out.println(&quot;StringBuffer使用equals比较的结果：&quot; + sb.equals(sb2) ); //false StringBuilder sbu = new StringBuilder(&quot;lomo&quot;); StringBuilder sbu2 = new StringBuilder(&quot;lomo&quot;); System.out.println(&quot;StringBuilder==的比较：&quot; + (sbu == sbu2)); //false// try &#123;// System.out.println(&quot;StringBuilder==的比较：&quot; + (sbu == sbu2)); //false// &#125;catch (Exception err)&#123;// System.out.println(err);// &#125; System.out.println(&quot;StringBuilder使用equals比较：&quot; + sbu.equals(sbu2)); // false &#125;&#125; 可以看到，StringBuffer和StringBuilder的&#x3D;&#x3D; 和 equals 比较使用的都是继承自Object类的equals方法，即：比较类型+值内容。 Object类的equals源码： 1234public boolean equals(Object obj) &#123; return (this == obj); &#125; &#x3D;&#x3D;和equals区别总结： StringBuffer、StringBuilder，使用equal或 == 比较时，使用的Object的equals方法，比较是否为同一个对象，即 类型+值的比较； 这三个String、StringBuilder、StringBuffer里只有String类重写了Object类的equals方法，使用equals比较时，只比较值是否相等；&#x3D;&#x3D;比较是否为同一个对象，比较类型+值。 Double、Integer、Long这些包装类数据类型都重写了Object类的equals方法和hashCode方法, 进而其比较的是值内容! 总之，只有String类重写了Object的equals和hashCode方法使其用equals比较时只比较值内容是否相等!!! &#x3D;&#x3D;&gt;&gt; [再次啰嗦总结] 八种包装数据类型：Integer、Short、Float、Double、Long、Byte、Boolean、Character 都重写了Object的equals方法，它们声明的变量使用equals比较时，都比较值的内容； 而对于String、StringBuilder、StringBuffer类型，只有String重写了Object类的equals方法，使用equals比较时(或使用 &#x3D;&#x3D; 比较)只有String类型的比较值内容，其它两个比较都是类型+内容！ 对于基本数据类型: int、double、float、char等比较，都是值比较. 如何自定义类型 自造数据类型 12345678910111213public class CustomDefineClaz&#123; public void method() &#123; //Todo &#125;&#125;//使用：CustomDefineClaz t = new CustomDefineClaz();//调用其方法t.method();//或 直接：new CustomDefineClaz().method(); &#x3D;&#x3D;&gt;&gt; 变量定义： 1类名 对象名 = new 类名(); 方法定义： 1234修饰符 类名 方法名(参数xxx) &#123; // // 返回类型，无则将方法声明为void&#125; 如： 12345678910111213141516class Person &#123;&#125;class newObj &#123; Person p1 = new Person(); public void method() &#123; //do sth.. //no return data &lt;- void &#125; public static Person methods() &#123; //do sth ... return new Person(); // return data 必须是Person类类型的对象，或者说返回类型必须是Person类对象/实例 &#125;&#125; 思想：java中一切都是class(类)，定义一个class，按需求填充所需属性、方法即可。","categories":[{"name":"study","slug":"study","permalink":"http://lomo.space/categories/study/"}],"tags":[{"name":"java","slug":"java","permalink":"http://lomo.space/tags/java/"},{"name":"String","slug":"String","permalink":"http://lomo.space/tags/String/"}]},{"title":"Establish Git Repository By Gogs","slug":"build-git-repository-by-gogs","date":"2016-03-10T08:22:55.000Z","updated":"2022-01-14T11:40:22.875Z","comments":true,"path":"2016/03/10/build-git-repository-by-gogs/","link":"","permalink":"http://lomo.space/2016/03/10/build-git-repository-by-gogs/","excerpt":"","text":"搭建内网Git仓库Introduce快速搭建内网或公司内部版的GitHub? Gogs, Google版GitHub. Gogs基于Go语言开发.Gogs 的目标是打造一个最简单、最快速和最轻松的方式搭建自助 Git 服务。使用 Go 语言开发使得 Gogs 能够通过独立的二进制分发，并且支持 Go 语言支持的 所有平台，包括 Linux、Mac OS X、Windows 以及 ARM 平台 一个树莓派的硬件配置即可使用Gogs快速搭建Git服务系统，便捷、快速、节省成本！！！ 本地尝鲜本地Mac系统先使用。 下载Mac系统对应的Gogs版本并解压. cd进入解压出来的目录. 运行.&#x2F;gogs web 即可, 默认端口为3000, 打开http://localhost:3000 即可访问、注册、登录进行体验. CentOS 上安装 CentOS 6.5&#x2F;64bit 下载对应CentOS架构的Gogs二进制安装包 解压安装包 进入解压后目录，.&#x2F;gogs web &amp; 运行即可访问. 上述方式运行方式需要一直保持当前session窗口激活状态，如果关闭窗口，则运行的服务就被停止无法访问。 解决方案： ①. 使用nohup 进行后台运行命令即可。 ②. 配置命令如下： 12cd /data/website/gogsnohup ./gogs web &amp; ③. 关于nohup 在使用nohup命令的时候，经常由于输出nohup.out的路径没有写入权限，而无法使用nohup4. 配置alias alias gogs=&quot;nohup /data/website/gogs/./gogs web &amp;&quot; 配置Email服务 如果首次安装时未配置email服务，则可按照如下配置进行。 第一步 找到 /custom/conf目录，找到该目录下的app.ini文件，修改其配置即可，具体配置如下： 12345678910111213141516171819[mailer]ENABLED = true # 必须开启 设置为trueHOST = smtp.exmail.qq.com:465 #对应邮箱服务设置里找此配置项FROM = xxx@qq.comUSER = xxx@qq.comPASSWD = 邮箱密码或授权码[service]## 要求注册用户必须验证邮箱REGISTER_EMAIL_CONFIRM = true## 激活该选项来发送通知邮件给关注者，例如创建 issue 时ENABLE_NOTIFY_MAIL = true## 激活该选项来禁止用户注册功能，只能由管理员创建帐号DISABLE_REGISTRATION = false## 激活该选项以在用户注册时要求输入验证码ENABLE_CAPTCHA = true## 激活该选项来要求用户必须登录才能浏览任何页面REQUIRE_SIGNIN_VIEW = true 2. 第二步 重启服务, 必须重启gogs服务!!! 以git账户运行. 【ssh登录后默认的是root账户，所以需要su git 切换至git账户，然后再切换回root账户，su root， 输入roor账户密码；输入alias gogs即可】 测试邮件激活服务： 重新注册账号，进入新注册邮箱，查看激活邮件。 点击链接， 确认激活即可。 查看数据库字段，再次确认是否激活。 未启动mailer之前，注册账号默认都是激活的, is_active字段默认为1. CentOS 升级Gogs 查看更新log决定是否更新： https://gogs.io/docs/intro/change_log 官网下载最新Gogs二进制安装包 https://gogs.io/docs/installation/install_from_binary 备份旧版本整个gogs文件夹(以备不测)，解压新版本gogs 按照官网说法，只需要删除旧版本的templates文件夹，并用最新版本的templates覆盖，经过测试，是有问题和bug的，所以现小记自己的升级更新之笔记. 经过上述操作完毕后, 可以单独备份&#x2F;gogs根目录下的以下文件夹(alternative): 二进制可执行文件 gogs&#x2F;gogs[ 如果服务启动运行中,需要停止服务,否则会提示 ‘Text file busy’导致无法拷贝粘贴文件,使用 fuser &#x2F;xx&#x2F;xx&#x2F;filename 查看进程ID并kill -9 ID即可 ]gogs&#x2F;public 文件夹gogs&#x2F;templates 文件夹gogs&#x2F;scriptes 文件夹 备份完毕，用最新版的对应文件替换上面备份过的文件夹即可。 二进制gogs可执行文件一定要更新，否则nohup.out文件里会提示相应错误 说明: templates 存放的都是前端模板 .tmpl文件，用来渲染数据public里面存的是最新样式相关资源js&#x2F;css&#x2F;img等, 【更新时需要同时更新，避免使用了新的CSS资源导致页面显示问题】更新这些文件夹，基本不用kill之前开启的gog服务进程, 直接覆盖即可. push 当push文件较大时，提示错误 1234error: RPC failed; HTTP 413 curl 22 The requested URL returned error: 413 Request Entity Too Largefatal: The remote end hung up unexpectedly....fatal: The remote end hung up unexpectedly 解决办法：使用ssh地址。 git remote remove xx(http:&#x2F;&#x2F;开头的) git remote add xxx2(ssh地址) 或： 修改Nginx配置, 使其支持大文件传输： client_max_body_size 50m; 参考：http://stackoverflow.com/questions/7489813/github-push-error-rpc-failed-result-22-http-code-413/15021750#15021750","categories":[{"name":"essay","slug":"essay","permalink":"http://lomo.space/categories/essay/"}],"tags":[{"name":"git","slug":"git","permalink":"http://lomo.space/tags/git/"},{"name":"gogs","slug":"gogs","permalink":"http://lomo.space/tags/gogs/"}]},{"title":"Hexo如何新创建新博文","slug":"how-to-write-a-new-article","date":"2016-02-24T05:40:48.000Z","updated":"2022-01-14T11:40:22.878Z","comments":true,"path":"2016/02/24/how-to-write-a-new-article/","link":"","permalink":"http://lomo.space/2016/02/24/how-to-write-a-new-article/","excerpt":"","text":"命令生成初始文章1$ hexo n &quot;how to write a new article&quot; 然后即可在./source/_posts 目录下创建对应的.md文件，例如我的： ~/Documents/Blog/source/_posts/how-to-write-a-new-article.md 同时，会在创建一个文件夹同名的文件夹，这个文件夹一般用来存放这篇博文相关的图片、自定义样式css、或其他js脚本文件等. 截图如下： –&gt;&gt; 注意观察命令行参数与所生产文件及文件夹名的对应关系！ 123222然后即可开始撰写文字。一般地，其格式如下： `title: hexo post #可以改成中文的，如“新文章” date: 2015-01-14 21:31:42 #发表日期，可自定义修改排序 categories: blog #文章文类 tags: [博客,文章] #文章标签，可以加入多标签 ---`","categories":[{"name":"essay","slug":"essay","permalink":"http://lomo.space/categories/essay/"}],"tags":[{"name":"write","slug":"write","permalink":"http://lomo.space/tags/write/"}]},{"title":"reading list in 2015","slug":"reading-list-in-2015","date":"2016-02-22T02:55:39.000Z","updated":"2022-01-14T11:40:22.886Z","comments":true,"path":"2016/02/22/reading-list-in-2015/","link":"","permalink":"http://lomo.space/2016/02/22/reading-list-in-2015/","excerpt":"","text":"Reading List In 2015 No. Book Language Author Status 1 Zero To One 英文版 Peter Thiel ✔ 2 Zero To One 中文版 Peter Thiel ✔ 3 平凡的世界 路遥 ✔ 4 像狗一样奔跑 ✔ 5 腾讯传 ✔ 6 品牌洗脑 ✔ 7 乔布斯内部信件 ✔ 8 乔布斯▪乔布斯管理日志 ✔ 9 雪国 ✔ 10 北平无战事 ✔ 11 平台战略 12 工业4.0 13 灿烂千阳 Khaled Hosseini ✔ 14 仲夏夜之梦 15 千纸鹤 16 海边的卡夫卡 村上春树 ✔ 17 变形计 ✔ 18 我以为你死了 Pete Nelson ✔ 19 世界是自己的 与他人无关 20 巴别塔之犬 Carolyn·Parkhurst ✔ 21 群山回唱 Khaled Hosseini ✔ 22 不懂色彩 不看电影 23 华盛顿 Washington Irving ✔ 24 浪漫自由路 25 一个人的朝圣 Rachel Joyce ✔ 26 明朝那些事儿:洪武大帝 ✔ 27 明朝那些事儿:万国来朝 ✔ 28 明朝那些事儿:妖孽宫廷 ✔ 29 明朝那些事儿:粉饰太平 ✔ 30 明朝那些事儿:帝国飘摇 31 明朝那些事儿:日暮西山 32 明朝那些事儿:大结局 33 汪国真经典诗文 ✔ 34 我把一切告诉你","categories":[{"name":"read","slug":"read","permalink":"http://lomo.space/categories/read/"}],"tags":[{"name":"read","slug":"read","permalink":"http://lomo.space/tags/read/"},{"name":"study","slug":"study","permalink":"http://lomo.space/tags/study/"}]},{"title":"js slice splice split","slug":"js-slice-splice-split","date":"2015-09-19T02:55:45.000Z","updated":"2022-01-14T11:40:22.882Z","comments":true,"path":"2015/09/19/js-slice-splice-split/","link":"","permalink":"http://lomo.space/2015/09/19/js-slice-splice-split/","excerpt":"","text":"JavaScript的三个易混淆函数slice&#x2F;splice&#x2F;splitslice 截取数组对数据进行截取，并返回一个数组副本。 语法： array.slice(startNo, endNo);参数start是截取的开始数组索引，end参数等于你要取的最后一个字符的位置值加上1. e.g.1 12345678var arr = [&#x27;lomo&#x27;, 2, 3, 7, 9, 12, &#x27;dong&#x27;];var arr2 = arr.slice(1,3);console.log(arr2); // [2, 3], 数组小标从0开始//如果你要从arr中截取出12，dong 这2个，那么应该这样：var arr3 = arr.slice(5, 7); console.log(arr.slice(3)); //[7, 9, 12, &quot;dong&quot;], 表示从数组下标3开始截取到最后结束。 slice 截取字符串123456var s = &quot;lomo.space&quot;;s.slice(3); // 输出：o.spaces.slice(1, 4); // omos.slice(1, 5); // omo.s.slice(1, 6); // omo.s splice 截取数组 splice() 方法从Array中移除一个或多个数组元素，并用新的item替换。 语法： array.splice(start, deleteCounts, item....); 参数start是从数组array中移除元素的开始位置(开始数组索引)。参数deleteCount是要移除的元素的个数, 有额外的参数item，那么item会插入到被移除元素的位置上。 该函数返回一个包含被移除元素的数组。 e.g.2 1234567891011var arr = [1,3, 5, 9, &#x27;lomo&#x27;, 2.5];var a = arr.splice(1, 2); // a -&gt; [3, 5] , 变量a存储的是从arr中移除的元素并按顺序形成新的数组aconsole.log(arr); //[1, 9, &quot;lomo&quot;, 2.5] , 数组arr被移除第二个和第三个元素后的结果var b = arr.splice(1, 2, &#x27;ch&#x27;, &#x27;don&#x27;);console.log(b); //[9, &quot;lomo&quot;], b存储被arr移除出来的2个元素console.log(arr); // [1, &quot;ch&quot;, &quot;don&quot;, 2.5], arr数组第二个元素3(数组小标为1) 和第三个元素5被移除并被新的元素 &#x27;ch&#x27; 和 &#x27;don&#x27; 依次替换。 123456var arr = [1,3, 5, 9, &#x27;lomo&#x27;, 2.5];var c = arr.splice(1, -2, &#x27;f&#x27;, &#x27;ff&#x27;); // c.length = 0console.log(arr); //[1, &quot;f&quot;, &quot;ff&quot;, 3, 5, 9, &quot;lomo&quot;, 2.5] 12345678910111213141516171819202122var arr = [1,3, 5, 9, &#x27;lomo&#x27;, 2.5];var c= arr.splice(-1, 2, &#x27;ee&#x27;, &#x27;ef&#x27;);console.log(c); // [2.5]console.log(arr); // [1, 3, 5, 9, &quot;lomo&quot;, &quot;ee&quot;, &quot;ef&quot;]var arr = [1,3, 5, 9, &#x27;lomo&#x27;, 2.5];arr.splice(-1, 3, &#x27;e&#x27;, &#x27;ee&#x27;, &#x27;eee&#x27;); //[2.5]console.log(arr); // [1, 3, 5, 9, &quot;lomo&quot;, &quot;e&quot;, &quot;ee&quot;, &quot;eee&quot;]var arr = [1,3, 5, 9, &#x27;lomo&#x27;, 3.5]; //arr.length = 6;arr.splice(-2, 2, &#x27;e&#x27;, &#x27;ee&#x27;, &#x27;eee&#x27;); // 6 +(-2) = 4; [&quot;lomo&quot;, 3.5], 所以从数组小标为4的第五个元素lomo开始截取替换console.log(arr); // [1, 3, 5, 9, &quot;f&quot;, &quot;ff&quot;] 可以看到splice()函数第一个参数为负数，看注释。 split语法： string.split(分隔符，optionnalLimit); 第一个参数必选，第二个可选，该函数用来分割字符串并产出一个分割后的新数组； 12345var a = &#x27;23324324&#x27;a.split(&#x27;&#x27;); // [&quot;2&quot;, &quot;3&quot;, &quot;3&quot;, &quot;2&quot;, &quot;4&quot;, &quot;3&quot;, &quot;2&quot;, &quot;4&quot;]var b = a.split(&#x27;&#x27;, 3);console.log(b); //[&quot;2&quot;, &quot;3&quot;, &quot;3&quot;] 参考： http://www.jb51.net/article/81663.htm","categories":[{"name":"study","slug":"study","permalink":"http://lomo.space/categories/study/"}],"tags":[{"name":"js","slug":"js","permalink":"http://lomo.space/tags/js/"}]},{"title":"create table dynamic","slug":"create-table-dynamic","date":"2015-07-09T04:31:34.000Z","updated":"2022-01-14T11:40:22.876Z","comments":true,"path":"2015/07/09/create-table-dynamic/","link":"","permalink":"http://lomo.space/2015/07/09/create-table-dynamic/","excerpt":"","text":"JS动态创建Table表接口返回JSON示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105&#123; &quot;BugCount&quot;: &#123; &quot;fieldExplain&quot;: &#123; &quot;month&quot;: &quot;月份&quot;, &quot;totalCount&quot;: &quot;整体BUG数量&quot;, &quot;online&quot;: &quot;纯线上Bug数量&quot;, &quot;offline&quot;: &quot;线下bug&quot;, &quot;onlinePercent&quot;: &quot;纯线上Bug占比&quot;, &quot;offlinePercent&quot;: &quot;线下Bug占比&quot; &#125;, &quot;BugCountDetail&quot;: [&#123; &quot;month&quot;: &quot;2017-03&quot;, &quot;totalCount&quot;: &quot;1564&quot;, &quot;online&quot;: &quot;291&quot;, &quot;offline&quot;: &quot;1273&quot;, &quot;onlinePercent&quot;: &quot;36.82%&quot;, &quot;offlinePercent&quot;: &quot;81.39%&quot; &#125;, &#123; &quot;month&quot;: &quot;2017-04&quot;, &quot;totalCount&quot;: &quot;1214&quot;, &quot;online&quot;: &quot;311&quot;, &quot;offline&quot;: &quot;903&quot;, &quot;onlinePercent&quot;: &quot;25.62%&quot;, &quot;offlinePercent&quot;: &quot;74.38%&quot; &#125;, &#123; &quot;month&quot;: &quot;2017-05&quot;, &quot;totalCount&quot;: &quot;1267&quot;, &quot;online&quot;: &quot;249&quot;, &quot;offline&quot;: &quot;1118&quot;, &quot;onlinePercent&quot;: &quot;18.22%&quot;, &quot;offlinePercent&quot;: &quot;81.78%&quot; &#125;, &#123; &quot;month&quot;: &quot;2017-06&quot;, &quot;totalCount&quot;: &quot;1572&quot;, &quot;online&quot;: &quot;278&quot;, &quot;offline&quot;: &quot;1294&quot;, &quot;onlinePercent&quot;: &quot;17.68%&quot;, &quot;offlinePercent&quot;: &quot;82.32%&quot; &#125;] &#125;, &quot;OnlineBug&quot;: &#123; &quot;fieldExplain&quot;: &#123; &quot;month&quot;: &quot;月份&quot;, &quot;totalCount&quot;: &quot;整体BUG数量&quot;, &quot;online&quot;: &quot;纯线上BUG数量&quot;, &quot;online_P0&quot;: &quot;纯线上Bug-P0&quot;, &quot;online_P1&quot;: &quot;纯线上Bug-P1&quot;, &quot;online_P2&quot;: &quot;纯线上Bug-P2&quot;, &quot;online_Others&quot;: &quot;纯线上Bug-其他&quot;, &quot;online_P0P1&quot;: &quot;纯线上P0P1&quot;, &quot;online_P2P3&quot;: &quot;纯线上P2P3&quot;, &quot;online_P012&quot;: &quot;纯线上P012&quot;, &quot;P0P1_Percent&quot;: &quot;P0P1占比&quot; &#125;, &quot;OnlineBugDetail&quot;: [&#123; &quot;month&quot;: &quot;2017-03&quot;, &quot;totalCount&quot;: &quot;1564&quot;, &quot;online&quot;: &quot;291&quot;, &quot;online_P0&quot;: &quot;25&quot;, &quot;online_P1&quot;: &quot;84&quot;, &quot;online_P2&quot;: &quot;156&quot;, &quot;online_Others&quot;: &quot;26&quot;, &quot;online_P0P1&quot;: &quot;109&quot;, &quot;online_P2P3&quot;: &quot;182&quot;, &quot;online_P012&quot;: &quot;265&quot;, &quot;P0P1_Percent&quot;: &quot;37.46%&quot; &#125;, &#123; &quot;month&quot;: &quot;2017-04&quot;, &quot;totalCount&quot;: &quot;1214&quot;, &quot;online&quot;: &quot;311&quot;, &quot;online_P0&quot;: &quot;30&quot;, &quot;online_P1&quot;: &quot;78&quot;, &quot;online_P2&quot;: &quot;187&quot;, &quot;online_Others&quot;: &quot;16&quot;, &quot;online_P0P1&quot;: &quot;108&quot;, &quot;online_P2P3&quot;: &quot;203&quot;, &quot;online_P012&quot;: &quot;295&quot;, &quot;P0P1_Percent&quot;: &quot;34.73%&quot; &#125;, &#123; &quot;month&quot;: &quot;2017-05&quot;, &quot;totalCount&quot;: &quot;1367&quot;, &quot;online&quot;: &quot;249&quot;, &quot;online_P0&quot;: &quot;21&quot;, &quot;online_P1&quot;: &quot;68&quot;, &quot;online_P2&quot;: &quot;147&quot;, &quot;online_Others&quot;: &quot;13&quot;, &quot;online_P0P1&quot;: &quot;89&quot;, &quot;online_P2P3&quot;: &quot;160&quot;, &quot;online_P012&quot;: &quot;236&quot;, &quot;P0P1_Percent&quot;: &quot;35.74%&quot; &#125;, &#123; &quot;month&quot;: &quot;2017-06&quot;, &quot;totalCount&quot;: &quot;1572&quot;, &quot;online&quot;: &quot;278&quot;, &quot;online_P0&quot;: &quot;36&quot;, &quot;online_P1&quot;: &quot;79&quot;, &quot;online_P2&quot;: &quot;140&quot;, &quot;online_Others&quot;: &quot;23&quot;, &quot;online_P0P1&quot;: &quot;115&quot;, &quot;online_P2P3&quot;: &quot;163&quot;, &quot;online_P012&quot;: &quot;255&quot;, &quot;P0P1_Percent&quot;: &quot;41.37%&quot; &#125;] &#125;&#125; fieldExplain 为表头 thead，BugCountDetail 和 OnlineBugDetail 为表格内容即: tbody。 js遍历Json123456789101112var jsonData = &quot;month&quot;:&quot;2017-03&quot;,&quot;totalCount&quot;:&quot;1564&quot;,&quot;online&quot;:&quot;291&quot;,&quot;offline&quot;:&quot;1273&quot;,&quot;onlinePercent&quot;:&quot;36.82%&quot;,&quot;offlinePercent&quot;:&quot;81.39%&quot;&#125;,&#123;&quot;month&quot;:&quot;2017-04&quot;,&quot;totalCount&quot;:&quot;1214&quot;,&quot;online&quot;:&quot;311&quot;,&quot;offline&quot;:&quot;903&quot;,&quot;onlinePercent&quot;:&quot;25.62%&quot;,&quot;offlinePercent&quot;:&quot;74.38%&quot;&#125;,&#123;&quot;month&quot;:&quot;2017-05&quot;,&quot;totalCount&quot;:&quot;1267&quot;,&quot;online&quot;:&quot;249&quot;,&quot;offline&quot;:&quot;1118&quot;,&quot;onlinePercent&quot;:&quot;18.22%&quot;,&quot;offlinePercent&quot;:&quot;81.78%&quot;&#125;,&#123;&quot;month&quot;:&quot;2017-06&quot;,&quot;totalCount&quot;:&quot;1572&quot;,&quot;online&quot;:&quot;278&quot;,&quot;offline&quot;:&quot;1294&quot;,&quot;onlinePercent&quot;:&quot;17.68%&quot;,&quot;offlinePercent&quot;:&quot;82.32%&quot;&#125;];for(var i=0; i&lt;jsonData.length ;i++)&#123; //循环多少个&#123;&#125;json串 for(var key in jsonData[i])&#123; //循环遍历一个&#123;...&#125; json串, //如:&#123;&quot;month&quot;:&quot;2017-04&quot;,&quot;totalCount&quot;:&quot;1214&quot;,&quot;online&quot;:&quot;311&quot;,&quot;offline&quot;:&quot;903&quot;,&quot;onlinePercent&quot;:&quot;25.62%&quot;,&quot;offlinePercent&quot;:&quot;74.38%&quot;&#125; console.log(key+&#x27;:&#x27;+jsonData[i][key]); //key 即为json中的key, jsonData[i][key] 对应其值 &#125;&#125; 表头thead12345678910// 拆分; 表头部分var json = &#123;&quot;month&quot;:&quot;月份&quot;,&quot;totalCount&quot;:&quot;整体BUG数量&quot;,&quot;online&quot;:&quot;纯线上Bug数量&quot;,&quot;offline&quot;:&quot;线下bug&quot;,&quot;onlinePercent&quot;:&quot;纯线上Bug占比&quot;,&quot;offlinePercent&quot;:&quot;线下Bug占比&quot;&#125;; var tHead = &#x27;&#x27;; //表头 for(var k in tHeadObj) &#123; tHead += &#x27;&lt;th&gt;&#x27; + tHeadObj[k] + &#x27;&lt;/th&gt;&#x27;; &#125; tHead = &#x27;&lt;thead&gt;&lt;tr&gt;&#x27; + tHead + &quot;&lt;/tr&gt;&lt;/thead&gt;&quot;; return tHead; tbody123456789101112131415161718//表body部分var jsonData = [&#123;&quot;month&quot;:&quot;2017-03&quot;,&quot;totalCount&quot;:&quot;1564&quot;,&quot;online&quot;:&quot;291&quot;,&quot;offline&quot;:&quot;1273&quot;,&quot;onlinePercent&quot;:&quot;36.82%&quot;,&quot;offlinePercent&quot;:&quot;81.39%&quot;&#125;,&#123;&quot;month&quot;:&quot;2017-04&quot;,&quot;totalCount&quot;:&quot;1214&quot;,&quot;online&quot;:&quot;311&quot;,&quot;offline&quot;:&quot;903&quot;,&quot;onlinePercent&quot;:&quot;25.62%&quot;,&quot;offlinePercent&quot;:&quot;74.38%&quot;&#125;,&#123;&quot;month&quot;:&quot;2017-05&quot;,&quot;totalCount&quot;:&quot;1267&quot;,&quot;online&quot;:&quot;249&quot;,&quot;offline&quot;:&quot;1118&quot;,&quot;onlinePercent&quot;:&quot;18.22%&quot;,&quot;offlinePercent&quot;:&quot;81.78%&quot;&#125;,&#123;&quot;month&quot;:&quot;2017-06&quot;,&quot;totalCount&quot;:&quot;1572&quot;,&quot;online&quot;:&quot;278&quot;,&quot;offline&quot;:&quot;1294&quot;,&quot;onlinePercent&quot;:&quot;17.68%&quot;,&quot;offlinePercent&quot;:&quot;82.32%&quot;&#125;];//创建表Bodyvar tBody = &#x27;&#x27;;var tBody_tr = &#x27;&#x27;;for(var i=0; i&lt;jsonData.length; i++)&#123; tBody += &#x27;&lt;tr&gt;&#x27;; for(var key in jsonData[i])&#123; //alert(jsonData[i][key]); tBody += &quot;&lt;td&gt;&quot; + jsonData[i][key] + &quot;&lt;/td&gt;&quot;; &#125; tBody_tr = tBody + &quot;&lt;/tr&gt;&quot;;&#125;tBody = &quot;&lt;tbody&gt;&quot; + tBody_tr + &quot;&lt;/tbody&gt;&quot;;console.log(tBody); 输出： 1&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;2017-03&lt;/td&gt;&lt;td&gt;1564&lt;/td&gt;&lt;td&gt;291&lt;/td&gt;&lt;td&gt;1273&lt;/td&gt;&lt;td&gt;36.82%&lt;/td&gt;&lt;td&gt;81.39%&lt;/td&gt;&lt;tr&gt;&lt;td&gt;2017-04&lt;/td&gt;&lt;td&gt;1214&lt;/td&gt;&lt;td&gt;311&lt;/td&gt;&lt;td&gt;903&lt;/td&gt;&lt;td&gt;25.62%&lt;/td&gt;&lt;td&gt;74.38%&lt;/td&gt;&lt;tr&gt;&lt;td&gt;2017-05&lt;/td&gt;&lt;td&gt;1267&lt;/td&gt;&lt;td&gt;249&lt;/td&gt;&lt;td&gt;1118&lt;/td&gt;&lt;td&gt;18.22%&lt;/td&gt;&lt;td&gt;81.78%&lt;/td&gt;&lt;tr&gt;&lt;td&gt;2017-06&lt;/td&gt;&lt;td&gt;1572&lt;/td&gt;&lt;td&gt;278&lt;/td&gt;&lt;td&gt;1294&lt;/td&gt;&lt;td&gt;17.68%&lt;/td&gt;&lt;td&gt;82.32%&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt; 将以上2部分合并为一个函数即可。 调用该函数时，主要传入headjson数据和body所需的数组json即可. 12345678910111213141516171819202122function createBugCountTable(captionTitle, tHeadObj, tBodyArr) &#123; // 表格标题 var caption = &#x27;&lt;table class=&quot;table table-bordered table-hover &quot;&gt;&lt;caption class=&quot;text-muted h4&quot;&gt;&#x27; + captionTitle + &#x27;&lt;/caption&gt;&#x27;; //TODO JS遍历json var tableHead = &#x27;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&#x27; + tHeadObj.month + &#x27;&lt;/th&gt;&lt;th&gt;&#x27; + tHeadObj.totalCount + &#x27;&lt;/th&gt;&lt;th&gt;&#x27; + tHeadObj.online + &#x27;&lt;/th&gt;&lt;th&gt;&#x27; + tHeadObj.offline + &#x27;&lt;/th&gt;&lt;th&gt;&#x27; + tHeadObj.onlinePercent + &#x27;&lt;/th&gt;&lt;th&gt;&#x27; + tHeadObj.offlinePercent + &#x27;&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&#x27;; var tableBody = &#x27;&#x27;; for (var i = 0; i &lt; tBodyArr.length; i++) &#123; tableBody += &#x27;&lt;tr&gt;&lt;td&gt;&#x27; + tBodyArr[i].month + &#x27;&lt;/td&gt;&lt;td&gt;&#x27; + tBodyArr[i].totalCount + &#x27;&lt;/td&gt;&lt;td&gt;&#x27; + tBodyArr[i].online + &#x27;&lt;/td&gt;&lt;td&gt;&#x27; + tBodyArr[i].offline + &#x27;&lt;/td&gt;&lt;td&gt;&#x27; + tBodyArr[i].onlinePercent + &#x27;&lt;/td&gt;&lt;td&gt;&#x27; + tBodyArr[i].offlinePercent + &#x27;&lt;/td&gt;&lt;/tr&gt;&#x27;; &#125; return caption + tableHead + tableBody + &#x27;&lt;/tbody&gt;&lt;/table&gt;&#x27;;&#125; var t = createBugCountTable(&quot;test&quot;, tHeadObj, tBodyArr);console.log(t);","categories":[{"name":"study","slug":"study","permalink":"http://lomo.space/categories/study/"}],"tags":[{"name":"js","slug":"js","permalink":"http://lomo.space/tags/js/"},{"name":"table","slug":"table","permalink":"http://lomo.space/tags/table/"}]},{"title":"使用GitHub Pages创建个人博客","slug":"howToCreateBlogByUsingGitHubPages","date":"2015-06-21T15:30:02.000Z","updated":"2022-01-14T11:40:22.880Z","comments":true,"path":"2015/06/21/howToCreateBlogByUsingGitHubPages/","link":"","permalink":"http://lomo.space/2015/06/21/howToCreateBlogByUsingGitHubPages/","excerpt":"","text":"基于Hexo+Pages创建Blog基于GitHub Pages 加上自己的域名lomo.space创建个人博客，并将博客相关数据、文件免费托管于Github. 2013年左右时，个人博客是基于WordPress二次开发并自己购买空间、域名进行第三方付费托管于维护。 【第一部分】安装 Hexo + 服务 + 各类依赖1$ npm install -g hexo-cli #全局安装cli 初始化 Hexo1$ hexo init +文件夹名 init过程可能遇到NPM warning 级别错误，提示deprecated swig的错误： 解决方案：npm install swig@latest 安装 Hexo1$ npm install hexo --save #非全局(-g) 生成静态资源文件1$ hexo g || hexo generate #生成静态可访问资源(html+css+js)，附带一个web示例 生成的示例可通过URL：http://localhost:4000/ 进行访问。 尝试启动服务1$ hexo s || hexo serve #启动本地服务器 由于是首次本地安装Hexo，故尝试起服务前，必须安装一个server依赖包，否则会报错！使用NPM安装serve依赖包： npm install hexo-server --save 再次重启服务：hexo g, hexo s -o, 自动打开浏览器，发现空白，只有一行提示：Cannot get / 这样的错误提示！ 针对以上错误 解决方案:123$ npm install hexo-renderer-ejs --save #hexo依赖$ npm install hexo-renderer-stylus --save #hexo依赖$ npm install hexo-renderer-marked --save #hexo依赖 重新生成、部署本地服务，hexo g, hexo s。浏览器重新打开URL：http://localhost:4000/ 访问OK，出现了基本页面。 至此，Hexo-cli、hexo 安装及基本依赖安装完毕。 【第二部分】主题 及theme配置、二次开发选取自己喜欢的主题即可，可参考知乎或GitHub上自行索取。 主题安装12$ cd themes$ git clone https://github.com/wuchong/jacman.git # 选用的主题 安装完主题后，在对应主题根目录下有一个和该Blog根目录下同名的 _config.yml 配置文件,注意区别！ 二次开发部分此处省略，直接参考整个Blog代码。 【第三部分】常用功能模块配置博客基本配置首页默认展示文章形式(缩略：只显示部分)，可修改，在主题配置文件 _config.yml中：index: expand: false #缩略显示 excerpt_link: Read More 根目录_config.yml配置为了便于deploy本地文件到GitHub上，在博客根目录的 _config.yml 文件中，找到deploy关键字，如果没有，则在文件最后加上如下： deploy: type: git repo: https://github.com/lomo1/lomo1.github.io.git #自己的github page地址 branch: master #分支 快捷部署至GitHub为了使用快捷部署功能：hexo d 或hexo deploy (hexo g本地生成最新public文件夹之后)，必须要先安装一个hexo依赖包： npm install hexo-deployer-git --save最后hexo d 即可将最新博客相关数据文件更新至GitHub Pages上。 主题基本配置安装完主题后，博客根目录 _config.yml 启动新的主题：theme: jacman stylus: compress: true 菜单部分配置对应主题文件夹下的_config.yml文件，可参考如下: menu: Home: / Essay: /categories/essay Write: /categories/write Read: /categories/read Study: /categories/study Code: /categories/program About: /about 菜单按照如上配置后，在博客根目录下的 source目录下创建(若无)对应的目录，并在每一个folder下创建index.md 填充内容，否则在浏览器点击导航栏的Link后，跳转的页面是空白页。 Widget配置1234567891011121314151617author: intro_line1: &quot;Lomo&#x27;s Introduce One...&quot; ## your introduction on the bottom of the page intro_line2: &quot;Lomo&#x27;s Introduce Two ....&quot; ## the 2nd line weibo: ## 微博ID, http://weibo.com/527123733/home?wvr=5 weibo_verifier: tsina: douban: chnhawk zhihu: chan-donald email: lomo@lomo.space twitter: chnhawk github: ## e.g. for https://github.com/lomo1 facebook: linkedin: google_plus: ## e.g. &quot;1111908813418008123&quot;, the &quot;&quot; is needed! stackoverflow: ## e.g. 123221 ## 填写对应的社交账户的ID后，网站底部就会显示个人的社交主页链接，访客可直接点击访问个人对应社交主页. 友情链接 配置主题目录下的 _config.yml 文件： #### Linkslinks: 看雪: http://www.kanxue.com/ GoogleCodeStyle: https://google.github.io/styleguide/ Sina WeiBo 配置 获取嵌入代码: http://app.weibo.com/tool/weiboshow, 选取样式，并copy iframe代码 cd /Users/lomo/Documents/Blog/themes/jacman/layout/_widget 编辑weibo.ejs（&#x2F;theme&#x2F;layout&#x2F;widget&#x2F;weibo.ejs）,paste刚才copy的 iframe代码 hexo g, hexo s 查看效果。 RSS配置1$ npm install hexo-generator-feed --save #插件 install 博客根目录下的_config.yml 文件做如下配置： feed: type: atom path: atom.xml limit: 20 hub: 主题根目录下配置文件做如下修改： rss: /atom.xml 重新生成、部署。 文章评论功能 设置123456duoshuo_shortname: lomo1 ## 多说注册时，要求填写的三级域名里的那个name##如果名称和域名里的那个name不一致，则用域名里的那个name，否则评论数据会消失.disqus_shortname: ## 国外的dispus评论功能插件. 使用多说 -&gt; http://duoshuo.com/ 目前主要就这么多总结，给自己做笔记，留个备份，方便后用。后续问题再补充进来。对了随时插入图片的问题，还没解决好，后续跟进…","categories":[{"name":"essay","slug":"essay","permalink":"http://lomo.space/categories/essay/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://lomo.space/tags/Hexo/"},{"name":"blog","slug":"blog","permalink":"http://lomo.space/tags/blog/"},{"name":"GitHub","slug":"GitHub","permalink":"http://lomo.space/tags/GitHub/"}]},{"title":"下载无水印Bing每日美图","slug":"下载无水印Bing每日美图","date":"2015-04-28T02:25:17.000Z","updated":"2022-01-14T11:40:22.888Z","comments":true,"path":"2015/04/28/下载无水印Bing每日美图/","link":"","permalink":"http://lomo.space/2015/04/28/%E4%B8%8B%E8%BD%BD%E6%97%A0%E6%B0%B4%E5%8D%B0Bing%E6%AF%8F%E6%97%A5%E7%BE%8E%E5%9B%BE/","excerpt":"","text":"下载Bing每日美图(无水印版)http://cn.bing.com 微软Bing每天首页背景都有很多美图，可以轮播，还有的可以动态播放，和短视频一样。 Bing右下角已提供了下载壁纸按钮，但是都是带水印的，那么如何下载无水印版呢？ 方法1：查源码。 利用chrome的审查元素工具，例如需要下载某张图时，打开审查元素工具，选中或搜索定位到id为hp_container的元素，该元素下的第一个子元素id为bgDiv，即可。 如下图： 根据source提供的美图URL Path部分，加上host：cn.bing.com，就能获得无水印版下载地址。 如：http://cn.bing.com/az/hprichbg/rb/CivitadiBagnoregio_ZH-CN12942138675_1920x1080.jpg http://cn.bing.com/az/hprichbg/rb/MirrorBeach_ZH-CN12835554220_1920x1080.jpg 方法2：chrome的开发者工具 利用开发者工具查看请求。 具体看图。 方法3：Charles&#x2F;Fiddler 利用抓包工具，查看请求的URL即可。和方法2利用开发者工具查看网络请求基本一样。","categories":[{"name":"essay","slug":"essay","permalink":"http://lomo.space/categories/essay/"}],"tags":[{"name":"Bing","slug":"Bing","permalink":"http://lomo.space/tags/Bing/"}]},{"title":"reading list in 2014","slug":"reading-list-in-2014","date":"2015-02-21T08:55:36.000Z","updated":"2022-01-14T11:40:22.886Z","comments":true,"path":"2015/02/21/reading-list-in-2014/","link":"","permalink":"http://lomo.space/2015/02/21/reading-list-in-2014/","excerpt":"","text":"Reading List In 2014 No. Book Language Author Status 1 华尔街幽灵 中文 ✔️ 2 思考致富 中文 Half 3 通向金融王国的自由之路 中文 Half 4 大数据云图 中文 ✔️ 5 站在两个世界的边缘 中文 程浩 ✔️ 6 我在雨中等你 中文 Garth Stein ✔️ 7 偷影子的人 中文 Marc Levy ✔️ 8 让我留在你身边 中文 ✔️ 9 总有一个梦想 我们愿为之付出一生 中文 ✔️ 10 小王子 中文 ✔️ 11 1984 中文 George Orwell ✔️ 12 别问我是谁 中文 ✔️ 13 他们最幸福 中文 大冰 ✔️ 14 唯有青春 最难将息 日 近藤大介 ✔️ 15 追风筝的人 中文 Khaled Hosseini ✔️ 16 送你一颗子弹 中文 刘瑜 ✔️ 17 囚徒健身 中文 Half 18 匆匆那年 中文 ✔️ 19 飘 中文 Half","categories":[{"name":"read","slug":"read","permalink":"http://lomo.space/categories/read/"}],"tags":[{"name":"read","slug":"read","permalink":"http://lomo.space/tags/read/"},{"name":"study","slug":"study","permalink":"http://lomo.space/tags/study/"}]},{"title":"Linux and BSD difference","slug":"Linux-and-BSD-difference","date":"2014-06-13T04:54:04.000Z","updated":"2022-01-14T11:40:22.871Z","comments":true,"path":"2014/06/13/Linux-and-BSD-difference/","link":"","permalink":"http://lomo.space/2014/06/13/Linux-and-BSD-difference/","excerpt":"","text":"Linux 与BSD关系 区别Linux 是只是一个内核。制作 Linux 发行版所要做的工作就是，汇集那些创建一个完整 Linux 操作系统所需的所有软件，将它组合成一个像 Ubuntu、Mint、Debian、RedHat 或者是 Arch 这样的 Linux 发行版。有许多不同的 Linux 发行版。 与此相反的是，BSD 这个名字则代表其内核和操作系统。例如，FreeBSD 提供了 FreeBSD 内核和 FreeBSD 操作系统。它是作为一个单一的项目维护的。换句话说，如果你想要安装 FreeBSD，就只有一个 FreeBSD 可供你安装。如果你想要安装 Linux，你首先需要在许多 Linux 发行版之间选择。 许可证是典型的差异，虽然它不会对大多数人产生影响。Linux 使用 GNU 通用公共许可证，即 GPL。如果你修改了 Linux 内核，并将其分发，你就必须放出您的修改的源代码。 BSD 使用 BSD 许可证。如果你修改了 BSD 内核或发行版，并且发布它，你根本不需要必须发布其源代码。你可以自由地对你的 BSD 代码做任何你想做的事情，你没有义务发布的你修改的源代码，当然你想发布也行。 以下是通常认可的三个“主流” BSD 操作系统：• FreeBSD: FreeBSD 是最受欢迎的 BSD，针对高性能和易用性。它支持英特尔和 AMD 的32位和64位处理器。• NetBSD: NetBSD 被设计运行在几乎任何架构上，支持更多的体系结构。在他们的主页上的格言是”理所当然，我们运行在 NetBSD 上”。• OpenBSD:OpenBSD 为最大化的安全性设计的 —— 这不仅仅它宣称的功能，在实践中也确实如此。它是为银行和其他重要机构的关键系统设计的。 还有两个其他的重要 BSD 操作系统：• DragonFly BSD: DragonFly BSD 的设计目标是提供一个运行在多线程环境中的操作系统 —— 例如，计算机集群。• Darwin &#x2F; Mac OS X: Mac OS X 实际上基于 Darwin 操作系统，而 Darwin 系统基于 BSD。它与其他的 BSD 有点不同，虽然底层内核和其他的软件是开源代码(BSD 代码)，但操作系统的大部分是闭源的 Mac OS 代码)。苹果在 BSD 基础上开发了 Mac OS X 和 iOS，这样他们就不必写操作系统底层，就像 谷歌在 Linux 基础上开发 android 系统一样。 如果你是一个 PC 桌面用户，你真的不需要太过在意 BSD。你可能会喜欢 Linux，因为它具有更先进的硬件支持，更容易安装，具有现代操作系统的特点。如果你关注服务器或嵌入式的设备，你可能会更喜欢 FreeBSD。","categories":[{"name":"read","slug":"read","permalink":"http://lomo.space/categories/read/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://lomo.space/tags/Linux/"},{"name":"BSD","slug":"BSD","permalink":"http://lomo.space/tags/BSD/"},{"name":"Darwin","slug":"Darwin","permalink":"http://lomo.space/tags/Darwin/"}]},{"title":"MS Bing CodeFlow Architecture","slug":"MS-Bing-CodeFlow","date":"2014-05-07T03:26:49.000Z","updated":"2022-01-14T11:40:22.871Z","comments":true,"path":"2014/05/07/MS-Bing-CodeFlow/","link":"","permalink":"http://lomo.space/2014/05/07/MS-Bing-CodeFlow/","excerpt":"","text":"Simple Analysis Microsoft’s Code Revew ToolIn Microsoft Company, how does they do the Code Revew? I am proud to know it a little about it, let’s see it Today ! CodeFlow CodeFlow Architecture Overview of the review process","categories":[{"name":"study","slug":"study","permalink":"http://lomo.space/categories/study/"}],"tags":[{"name":"MS","slug":"MS","permalink":"http://lomo.space/tags/MS/"},{"name":"Bing","slug":"Bing","permalink":"http://lomo.space/tags/Bing/"},{"name":"CodeFlow","slug":"CodeFlow","permalink":"http://lomo.space/tags/CodeFlow/"}]},{"title":"linux/centos 常用系统命令","slug":"linux-general-command","date":"2014-05-06T03:13:09.000Z","updated":"2022-01-14T11:40:22.883Z","comments":true,"path":"2014/05/06/linux-general-command/","link":"","permalink":"http://lomo.space/2014/05/06/linux-general-command/","excerpt":"","text":"系统1234567891011121314151617181920# uname -a # 查看内核/操作系统/CPU信息# head -n 1 /etc/issue # 查看操作系统版本# cat /proc/cpuinfo # 查看CPU信息# hostname # 查看计算机名# lspci -tv # 列出所有PCI设备# lsusb -tv # 列出所有USB设备# lsmod # 列出加载的内核模块# env # 查看环境变量#dmidecode | grep &quot;Product Nmae&quot; #查看服务器型号# date &#x27;+%Y-%m-%d %H:%M:%S&#x27; #查看系统时间# ps -ef #查看运行进程# uptime #查看服务器开机时长，用户数，平均负载# lsmod #查看所有加载的模块# crontab -l #查看计划任务#who -b 查看最后一次系统启动的时间#who -r 查看当前系统运行时间#last reboot可以看到Linux系统历史启动的时间#last reboot | head -1 #查看最后一次Linux系统启动的时间 资源1234567# free -m # 查看内存使用量和交换区使用量# df -h # 查看各分区使用情况# du -sh &lt;目录名&gt; # 查看指定目录的大小# grep MemTotal /proc/meminfo # 查看内存总量# grep MemFree /proc/meminfo # 查看空闲内存量# uptime # 查看系统运行时间、用户数、负载# cat /proc/loadavg # 查看系统负载 磁盘和分区12345# mount | column -t # 查看挂接的分区状态# fdisk -l # 查看所有分区# swapon -s # 查看所有交换分区# hdparm -i /dev/hda # 查看磁盘参数(仅适用于IDE设备)# dmesg | grep IDE # 查看启动时IDE设备检测状况 网络12345678910111213141516# ifconfig # 查看所有网络接口的属性# iptables -L # 查看防火墙设置# route -n # 查看路由表# netstat -lntp # 查看所有监听端口# netstat -antp # 查看所有已经建立的连接# netstat -s # 查看网络统计信息#查看网卡型号# lspci |grep Ethernet#DNS配置# cat /etc/resolv.conf# iptables -L #查看防火墙规则# route -n #查看路由表# netstat -s #查看网络统计信息 进程12# ps -ef # 查看所有进程# top # 实时显示进程状态 用户123456789101112# w # 查看活动用户# id &lt;用户名&gt; # 查看指定用户信息# last # 查看用户登录日志# cut -d: -f1 /etc/passwd # 查看系统所有用户# cut -d: -f1 /etc/group # 查看系统所有组# crontab -l # 查看当前用户的计划任务# whoami #查看当前登录用户名# id #查看当前用户及其属组# w #查看当前登录的用户及运行的命令# last #查看最近登录用户# cat /etc/passwd|awk -F: &#x27;&#123;print $1&#125;&#x27; #查看服务器上面所有用户 服务123456# chkconfig --list # 列出所有系统服务# chkconfig --list | grep on # 列出所有启动的系统服务#sshd 0:关闭 1:关闭 2:启用 3:启用 4:启用 5:启用 6:关闭#httpd 0:关闭 1:关闭 2:关闭 3:启用 4:关闭 5:关闭 6:关闭#chkconfig xxx on #设置某个服务开启启动 程序1# rpm -qa # 查看所有安装的软件包","categories":[{"name":"program","slug":"program","permalink":"http://lomo.space/categories/program/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://lomo.space/tags/Linux/"},{"name":"CentOS","slug":"CentOS","permalink":"http://lomo.space/tags/CentOS/"},{"name":"命令行","slug":"命令行","permalink":"http://lomo.space/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C/"}]},{"title":"reading list in 2013","slug":"reading-list-in-2013","date":"2014-03-20T11:55:21.000Z","updated":"2022-01-14T11:40:22.886Z","comments":true,"path":"2014/03/20/reading-list-in-2013/","link":"","permalink":"http://lomo.space/2014/03/20/reading-list-in-2013/","excerpt":"","text":"Reading List In 2013 No. Book Language Author Status 1 蹉跎坡旧事 中文 沈博爱 ✔️ 2 没有梦想 何必远方 中文 ✔️ 3 记住你是谁 中文 黛西·韦德曼 ✔️ 4 论世间苦难 中文 ✔️ 5 天才舍我其谁 中文 ✔️ 6 论生命之短暂 中文 ✔️ 7 乌合之众 中文 Gustave Le Bon ✔️ 8 谁的青春不迷茫 中文 ✔️ 9 你要去相信，没有到不了的明天 中文 ✔️","categories":[{"name":"read","slug":"read","permalink":"http://lomo.space/categories/read/"}],"tags":[{"name":"read","slug":"read","permalink":"http://lomo.space/tags/read/"},{"name":"study","slug":"study","permalink":"http://lomo.space/tags/study/"}]},{"title":"about love","slug":"love","date":"2013-03-05T02:17:59.000Z","updated":"2022-01-14T11:40:22.884Z","comments":true,"path":"2013/03/05/love/","link":"","permalink":"http://lomo.space/2013/03/05/love/","excerpt":"","text":"Love If i know what love is, it is because of you 一努力走过那么多条街，才遇到你。 二而你现在的气质里，藏着你走过的路，读过的书和爱过的人。 今天偶尔看到知乎上的一个问题，某清华博士回答了18条里，其中一条刚好也是我这条。又被击中。附上这位的18条。 1。知识改变命运。2。高中真的要好好学。3。好的大学真的不一样，985和211跟普通的大学真的不同。4。高三可能是最快乐的时光，同时也是最难忘的。5。上学比上班好。6。早睡早起身体好。7。要吃早饭，对胃很重要。8。保护好视力。9。能用钱解决的问题就不要欠人情。10。你得有足够的实力，你的原则和底线才会被人尊重，身无长技，不配爱人，这是真理。11。你如今的气质里，藏着你走过的路，读过的书，和爱过的人。12。有些人，说再见就真的再也不见了。13。不要随随便便答应跟一个不喜欢的人在一起。14。喜不喜欢，合不合适，能不能在一起，真的是三件事情。15。话别说太满，人别熟太快。16。门当户对真的很重要。17。脱贫比脱单重要。18。你这一生，很有可能，默默无闻，毫无建树。 知乎原文 三那个让你流泪的，是你最爱的人； 那个懂你眼泪的，是最爱你的人。 那个为你擦干眼泪的，才是最后和你相守的人。 四那个没能陪你到最后的人，却教会你怎样去爱一个人。 那个没能陪你爱到最后的，却因为你而成为更好的人。 五每个人都会犯错，你若深爱一个人，无论ta如何对你，无论犯什么错，或是一转身，或者一夜，或是在ta哄你喂你吃一颗葡萄🍇的那一刻，或是吵完架后ta还死皮赖脸地冲你傻笑，你都会原谅，甚至为ta找理由。 你若不爱一个人，可能对方只说错一句话，或做错了一件小事，就会遭到你反感，就会立刻翻脸闹分手。 当一个人抓住你的小错或是过往依依不挠，不是因为你的错或过往多么不堪，而是因为不爱你。 原谅这种小事，只和爱的深浅有关，有多少爱，就有多少原谅 六父母在，人生尚有来处 父母去，人生只剩归途 也许某天和爸妈不经意间说了再见 这辈子就再也不见","categories":[{"name":"write","slug":"write","permalink":"http://lomo.space/categories/write/"}],"tags":[{"name":"love","slug":"love","permalink":"http://lomo.space/tags/love/"},{"name":"lomo","slug":"lomo","permalink":"http://lomo.space/tags/lomo/"}]}],"categories":[{"name":"study","slug":"study","permalink":"http://lomo.space/categories/study/"},{"name":"program","slug":"program","permalink":"http://lomo.space/categories/program/"},{"name":"essay","slug":"essay","permalink":"http://lomo.space/categories/essay/"},{"name":"write","slug":"write","permalink":"http://lomo.space/categories/write/"},{"name":"read","slug":"read","permalink":"http://lomo.space/categories/read/"}],"tags":[{"name":"k8s","slug":"k8s","permalink":"http://lomo.space/tags/k8s/"},{"name":"docker","slug":"docker","permalink":"http://lomo.space/tags/docker/"},{"name":"Python","slug":"Python","permalink":"http://lomo.space/tags/Python/"},{"name":"PDB","slug":"PDB","permalink":"http://lomo.space/tags/PDB/"},{"name":"mysql","slug":"mysql","permalink":"http://lomo.space/tags/mysql/"},{"name":"sql","slug":"sql","permalink":"http://lomo.space/tags/sql/"},{"name":"js","slug":"js","permalink":"http://lomo.space/tags/js/"},{"name":"rxjs","slug":"rxjs","permalink":"http://lomo.space/tags/rxjs/"},{"name":"react","slug":"react","permalink":"http://lomo.space/tags/react/"},{"name":"python","slug":"python","permalink":"http://lomo.space/tags/python/"},{"name":"java","slug":"java","permalink":"http://lomo.space/tags/java/"},{"name":"DesignPatterns","slug":"DesignPatterns","permalink":"http://lomo.space/tags/DesignPatterns/"},{"name":"observable","slug":"observable","permalink":"http://lomo.space/tags/observable/"},{"name":"angular","slug":"angular","permalink":"http://lomo.space/tags/angular/"},{"name":"appium","slug":"appium","permalink":"http://lomo.space/tags/appium/"},{"name":"wda","slug":"wda","permalink":"http://lomo.space/tags/wda/"},{"name":"angularjs","slug":"angularjs","permalink":"http://lomo.space/tags/angularjs/"},{"name":"ldap","slug":"ldap","permalink":"http://lomo.space/tags/ldap/"},{"name":"nodejs","slug":"nodejs","permalink":"http://lomo.space/tags/nodejs/"},{"name":"git","slug":"git","permalink":"http://lomo.space/tags/git/"},{"name":"gogs","slug":"gogs","permalink":"http://lomo.space/tags/gogs/"},{"name":"highcharts","slug":"highcharts","permalink":"http://lomo.space/tags/highcharts/"},{"name":"PHP","slug":"PHP","permalink":"http://lomo.space/tags/PHP/"},{"name":"MySQL","slug":"MySQL","permalink":"http://lomo.space/tags/MySQL/"},{"name":"WebDriver","slug":"WebDriver","permalink":"http://lomo.space/tags/WebDriver/"},{"name":"Chrome","slug":"Chrome","permalink":"http://lomo.space/tags/Chrome/"},{"name":"gulp","slug":"gulp","permalink":"http://lomo.space/tags/gulp/"},{"name":"xcode","slug":"xcode","permalink":"http://lomo.space/tags/xcode/"},{"name":"MacOSX","slug":"MacOSX","permalink":"http://lomo.space/tags/MacOSX/"},{"name":"nginx","slug":"nginx","permalink":"http://lomo.space/tags/nginx/"},{"name":"discuzX","slug":"discuzX","permalink":"http://lomo.space/tags/discuzX/"},{"name":"tree","slug":"tree","permalink":"http://lomo.space/tags/tree/"},{"name":"osx","slug":"osx","permalink":"http://lomo.space/tags/osx/"},{"name":"Hexo","slug":"Hexo","permalink":"http://lomo.space/tags/Hexo/"},{"name":"donate","slug":"donate","permalink":"http://lomo.space/tags/donate/"},{"name":"css","slug":"css","permalink":"http://lomo.space/tags/css/"},{"name":"yaml","slug":"yaml","permalink":"http://lomo.space/tags/yaml/"},{"name":"maven","slug":"maven","permalink":"http://lomo.space/tags/maven/"},{"name":"idea","slug":"idea","permalink":"http://lomo.space/tags/idea/"},{"name":"CentOS","slug":"CentOS","permalink":"http://lomo.space/tags/CentOS/"},{"name":"FTP","slug":"FTP","permalink":"http://lomo.space/tags/FTP/"},{"name":"reflect","slug":"reflect","permalink":"http://lomo.space/tags/reflect/"},{"name":"Linu","slug":"Linu","permalink":"http://lomo.space/tags/Linu/"},{"name":"扩展","slug":"扩展","permalink":"http://lomo.space/tags/%E6%89%A9%E5%B1%95/"},{"name":"upgrade","slug":"upgrade","permalink":"http://lomo.space/tags/upgrade/"},{"name":"cookie","slug":"cookie","permalink":"http://lomo.space/tags/cookie/"},{"name":"SSH","slug":"SSH","permalink":"http://lomo.space/tags/SSH/"},{"name":"Login","slug":"Login","permalink":"http://lomo.space/tags/Login/"},{"name":"Mac","slug":"Mac","permalink":"http://lomo.space/tags/Mac/"},{"name":"JDK","slug":"JDK","permalink":"http://lomo.space/tags/JDK/"},{"name":"sublime","slug":"sublime","permalink":"http://lomo.space/tags/sublime/"},{"name":"Linux","slug":"Linux","permalink":"http://lomo.space/tags/Linux/"},{"name":"centOS","slug":"centOS","permalink":"http://lomo.space/tags/centOS/"},{"name":"LAMP","slug":"LAMP","permalink":"http://lomo.space/tags/LAMP/"},{"name":"Apache","slug":"Apache","permalink":"http://lomo.space/tags/Apache/"},{"name":"cors","slug":"cors","permalink":"http://lomo.space/tags/cors/"},{"name":"ES7","slug":"ES7","permalink":"http://lomo.space/tags/ES7/"},{"name":"date","slug":"date","permalink":"http://lomo.space/tags/date/"},{"name":"Brew","slug":"Brew","permalink":"http://lomo.space/tags/Brew/"},{"name":"zsh","slug":"zsh","permalink":"http://lomo.space/tags/zsh/"},{"name":"jquery","slug":"jquery","permalink":"http://lomo.space/tags/jquery/"},{"name":"String","slug":"String","permalink":"http://lomo.space/tags/String/"},{"name":"write","slug":"write","permalink":"http://lomo.space/tags/write/"},{"name":"read","slug":"read","permalink":"http://lomo.space/tags/read/"},{"name":"study","slug":"study","permalink":"http://lomo.space/tags/study/"},{"name":"table","slug":"table","permalink":"http://lomo.space/tags/table/"},{"name":"blog","slug":"blog","permalink":"http://lomo.space/tags/blog/"},{"name":"GitHub","slug":"GitHub","permalink":"http://lomo.space/tags/GitHub/"},{"name":"Bing","slug":"Bing","permalink":"http://lomo.space/tags/Bing/"},{"name":"BSD","slug":"BSD","permalink":"http://lomo.space/tags/BSD/"},{"name":"Darwin","slug":"Darwin","permalink":"http://lomo.space/tags/Darwin/"},{"name":"MS","slug":"MS","permalink":"http://lomo.space/tags/MS/"},{"name":"CodeFlow","slug":"CodeFlow","permalink":"http://lomo.space/tags/CodeFlow/"},{"name":"命令行","slug":"命令行","permalink":"http://lomo.space/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C/"},{"name":"love","slug":"love","permalink":"http://lomo.space/tags/love/"},{"name":"lomo","slug":"lomo","permalink":"http://lomo.space/tags/lomo/"}]}